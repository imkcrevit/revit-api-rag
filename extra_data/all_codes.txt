=== CODE_BLOCK_0001 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
         ref string message, Autodesk.Revit.DB.ElementSet elements)
       {
           if (null == commandData)
           {
               throw new ArgumentNullException("commandData");
           }

           Document doc = commandData.Application.ActiveUIDocument.Document;
           ViewsMgr view = new ViewsMgr(doc);

           AllViewsForm dlg = new AllViewsForm(view);

           try
           {
               if (dlg.ShowDialog() == DialogResult.OK)
               {
                   return view.GenerateSheet(doc);
               }
           }
           catch (Exception e)
           {
               message = e.Message;
               return Autodesk.Revit.UI.Result.Failed;
           }

           return Autodesk.Revit.UI.Result.Succeeded;
      }

      #endregion IExternalCommand Members Implementation
      }

    /// <summary>
    /// Generating a new sheet that has all the selected views placed in.
    /// Updating and retrieving properties of a selected viewport.
    /// </summary>
    public class ViewsMgr : IDisposable
    {
      private TreeNode m_allViewsNames = new TreeNode("Views (all)");
      private ViewSet m_allViews = new ViewSet();
      private ViewSet m_selectedViews = new ViewSet();
      private FamilySymbol m_titleBlock;
      private IList<Element> m_allTitleBlocks = new List<Element>();
      private ArrayList m_allTitleBlocksNames = new ArrayList();
      private string m_sheetName;
      private double m_rows;

      private double TITLEBAR = 0.2;
      private double GOLDENSECTION = 0.618;

      private Document m_doc;

      private Viewport m_VP;

      /// <summary>
      /// Update Form data members bonded to UI controls.
      /// </summary>
      /// <param name="form">The Form to be updated.</param>
      public void UpdateViewportProperties(AllViewsForm form)
      {
         form.m_getMinBoxOutline = m_VP.GetBoxOutline().MinimumPoint;
         form.m_getMaxBoxOutline = m_VP.GetBoxOutline().MaximumPoint;

         form.m_getMinLabelOutline = m_VP.GetLabelOutline().MinimumPoint;
         form.m_getMaxLabelOutline = m_VP.GetLabelOutline().MaximumPoint;

         form.m_getLabelLineOffset = m_VP.LabelOffset;
         form.m_getLabelLineLength = m_VP.LabelLineLength;

         form.m_getBoxCenter = m_VP.GetBoxCenter();
         form.m_getOrientation = m_VP.Rotation;
      }

      /// <summary>
      /// Select a viewport by its associated view name and sheet name.
      /// </summary>
      /// <param name="form">The Form to be updated.</param>
      /// <param name="selectSheetName"> Sheet name.</param>
      /// <param name="selectAssociatedViewName">Associated view name.</param>
      public bool SelectViewport(AllViewsForm form, string selectSheetName, string selectAssociatedViewName)
      {
         m_VP = null;
         form.invalidViewport = true;

         FilteredElementCollector fec = new FilteredElementCollector(m_doc);
         fec.OfClass(typeof(Autodesk.Revit.DB.View));
         var viewSheets = fec.Cast<Autodesk.Revit.DB.View>().Where<Autodesk.Revit.DB.View>(vp => !vp.IsTemplate && vp.ViewType == ViewType.DrawingSheet);

         foreach (var view in viewSheets)
         {
            if (view.Name.Equals(selectSheetName))
            {
               ViewSheet viewSheet = (ViewSheet)view;
               foreach (var vp in viewSheet.GetAllViewports())
               {
                  Viewport VP = (Viewport)(m_doc.GetElement(vp));

                  Autodesk.Revit.DB.View associatedView = m_doc.GetElement(VP.ViewId) as Autodesk.Revit.DB.View;

                  if (associatedView.Name.Equals(selectAssociatedViewName))
                  {
                     m_VP = VP;
                     break;
                  }
               }
            }
         }

         if (m_VP == null)
         {
            throw new InvalidOperationException("Viewport not found.");
         }

         form.invalidViewport = false;
         UpdateViewportProperties(form);
         return true;
      }

      /// <summary>
      /// Change viewport label offset.
      /// </summary>
      /// <param name="form">The Form to be updated.</param>
      /// <param name="labelOffsetX">Label offset X component.</param>
      /// <param name="labelOffsetY">Label offset Y component.</param>
      public void SetLabelOffset(AllViewsForm form,
         double labelOffsetX, double labelOffsetY)
      {
         using (Transaction t = new Transaction(m_doc, "Change label offset"))
         {
            t.Start();

            m_VP.LabelOffset = new XYZ(labelOffsetX, labelOffsetY, 0.0);

            t.Commit();

            UpdateViewportProperties(form);
         }
      }

      /// <summary>
      /// Change viewport label length.
      /// </summary>
      /// <param name="form">The Form to be updated.</param>
      /// <param name="labelLineLength">Label line length.</param>
      public void SetLabelLength(AllViewsForm form, double labelLineLength)
      {
         using (Transaction t = new Transaction(m_doc, "Change label length"))
         {
            t.Start();

            m_VP.LabelLineLength = labelLineLength;

            t.Commit();

            UpdateViewportProperties(form);
         }
      }

      /// <summary>
      /// Change viewport orientation.
      /// </summary>
      /// <param name="form">The Form to be updated.</param>
      /// <param name="rotation">Label line rotation.</param>
      public void SetRotation(AllViewsForm form, ViewportRotation rotation)
      {
         using (Transaction t = new Transaction(m_doc, "Change label orientation"))
         {
            t.Start();

            m_VP.Rotation = rotation;

            t.Commit();

            UpdateViewportProperties(form);
         }
      }

        /// <summary>
        /// Tree node store all views' names.
        /// </summary>
        public TreeNode AllViewsNames
        {
            get
            {
                return m_allViewsNames;
            }
        }

        /// <summary>
        /// List of all title blocks' names.
        /// </summary>
        public ArrayList AllTitleBlocksNames
        {
            get
            {
                return m_allTitleBlocksNames;
            }
        }

        /// <summary>
        /// The selected sheet's name.
        /// </summary>
        public string SheetName
        {
            get
            {
                return m_sheetName;
            }
            set
            {
                m_sheetName = value;
            }
        }

        /// <summary>
        /// Constructor of views object.
        /// </summary>
        /// <param name="doc">the active document</param>
        public ViewsMgr(Document doc)
        {
            m_doc = doc;
            GetAllViews(doc);
            GetTitleBlocks(doc);
        }

        /// <summary>
        /// Finds all the views in the active document.
        /// </summary>
        /// <param name="doc">the active document</param>
        private void GetAllViews(Document doc)
        {
            FilteredElementCollector collector = new FilteredElementCollector(doc);
            FilteredElementIterator itor = collector.OfClass(typeof(Autodesk.Revit.DB.View)).GetElementIterator();
            itor.Reset();
            while (itor.MoveNext())
            {
                Autodesk.Revit.DB.View view = itor.Current as Autodesk.Revit.DB.View;
                // skip view templates because they're invisible in project browser
                if (null == view || view.IsTemplate)
                {
                    continue;
                }
                else
                {
                    ElementType objType = doc.GetElement(view.GetTypeId()) as ElementType;
                    if (null == objType || objType.Name.Equals("Schedule")
                        || objType.Name.Equals("Drawing Sheet"))
                    {
                        continue;
                    }
                    else
                    {
                        m_allViews.Insert(view);
                        AssortViews(view.Name, objType.Name);
                    }
                }
            }
        }

        /// <summary>
        /// Assort all views for tree view displaying.
        /// </summary>
        /// <param name="view">The view assorting</param>
        /// <param name="type">The type of view</param>
        private void AssortViews(string view, string type)
        {
            foreach (TreeNode t in AllViewsNames.Nodes)
            {
                if (t.Tag.Equals(type))
                {
                    t.Nodes.Add(new TreeNode(view));
                    return;
                }
            }

            TreeNode categoryNode = new TreeNode(type);
            categoryNode.Tag = type;
            if (type.Equals("Building Elevation"))
            {
                categoryNode.Text = "Elevations [" + type + "]";
            }
            else
            {
                categoryNode.Text = type + "s";
            }
            categoryNode.Nodes.Add(new TreeNode(view));
            AllViewsNames.Nodes.Add(categoryNode);
        }

        /// <summary>
        /// Retrieve the checked view from tree view.
        /// </summary>
        public void SelectViews()
        {
            ArrayList names = new ArrayList();
            foreach (TreeNode t in AllViewsNames.Nodes)
            {
                foreach (TreeNode n in t.Nodes)
                {
                    if (n.Checked && 0 == n.Nodes.Count)
                    {
                        names.Add(n.Text);
                    }
                }
            }

            foreach (Autodesk.Revit.DB.View v in m_allViews)
            {
                foreach (string s in names)
                {
                    if (s.Equals(v.Name))
                    {
                        m_selectedViews.Insert(v);
                        break;
                    }
                }
            }
        }

      /// <summary>
      /// Generate sheet in active document.
      /// </summary>
      /// <param name="doc">the currently active document</param>
      public Autodesk.Revit.UI.Result GenerateSheet(Document doc)
      {
         if (null == doc)
         {
                throw new ArgumentNullException("doc");
         }

         if (m_selectedViews.IsEmpty)
         {
                throw new InvalidOperationException("No view be selected, generate sheet be canceled.");
         }

         Result result = Result.Succeeded;

         using (Transaction newTran = new Transaction(doc, "AllViews_Sample"))
         {
            newTran.Start();

            try
            {
                  ViewSheet sheet = ViewSheet.Create(doc, m_titleBlock.Id);
                  sheet.Name = SheetName;
                  PlaceViews(m_selectedViews, sheet);
            }
            catch(Exception)
            {
                  result = Result.Failed;
            }

            if (result == Result.Succeeded)
            {
                  newTran.Commit();
            }
            else
            {
                  newTran.RollBack();
                  throw new InvalidOperationException("Failed to generate sheet view and/or its viewports.");
            }
         }

         return result;
      }

        /// <summary>
        /// Retrieve the title block to be generate by its name.
        /// </summary>
        /// <param name="name">The title block's name</param>
        public void ChooseTitleBlock(string name)
        {
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentNullException("name");
            }

            foreach (FamilySymbol f in m_allTitleBlocks)
            {
               if (name.Equals(f.Family.Name + ":" + f.Name))
               {
                  m_titleBlock = f;
                  return;
               }
            }
        }

        /// <summary>
        /// Retrieve all available title blocks in the currently active document.
        /// </summary>
        /// <param name="doc">the currently active document</param>
        private void GetTitleBlocks(Document doc)
        {
            FilteredElementCollector filteredElementCollector = new FilteredElementCollector(doc);
            filteredElementCollector.OfClass(typeof(FamilySymbol));
            filteredElementCollector.OfCategory(BuiltInCategory.OST_TitleBlocks);
            m_allTitleBlocks = filteredElementCollector.ToElements();
            if (0 == m_allTitleBlocks.Count)
            {
                throw new InvalidOperationException("There is no title block to generate sheet.");
            }

            foreach (Element element in m_allTitleBlocks)
            {
                FamilySymbol f = element as FamilySymbol;
                AllTitleBlocksNames.Add(f.Family.Name + ":" + f.Name);
                if (null == m_titleBlock)
                {
                   m_titleBlock = f;
                }
            }
        }

        /// <summary>
        /// Place all selected views on this sheet's appropriate location.
        /// </summary>
        /// <param name="views">all selected views</param>
        /// <param name="sheet">all views located sheet</param>
        private void PlaceViews(ViewSet views, ViewSheet sheet)
        {
            double xDistance = 0;
            double yDistance = 0;
            CalculateDistance(sheet.Outline, views.Size, ref xDistance, ref yDistance);

            Autodesk.Revit.DB.UV origin = GetOffSet(sheet.Outline, xDistance, yDistance);
            //Autodesk.Revit.DB.UV temp = new Autodesk.Revit.DB.UV (origin.U, origin.V);
            double tempU = origin.U;
            double tempV = origin.V;
            int n = 1;
            foreach (Autodesk.Revit.DB.View v in views)
            {
                Autodesk.Revit.DB.UV location = new Autodesk.Revit.DB.UV(tempU, tempV);
                Autodesk.Revit.DB.View view = v;
                Rescale(view, xDistance, yDistance);
                try
                {
                    //sheet.AddView(view, location);
                    Viewport.Create(view.Document, sheet.Id, view.Id, new XYZ(location.U, location.V, 0));
                }
                catch (ArgumentException /*ae*/)
                {
                    throw new InvalidOperationException("The view '" + view.Name +
                        "' can't be added, it may have already been placed in another sheet.");
                }

                if (0 != n++ % m_rows)
                {
                    tempU = tempU + xDistance * (1 - TITLEBAR);
                }
                else
                {
                    tempU = origin.U;
                    tempV = tempV + yDistance;
                }
            }
        }

        /// <summary>
        /// Retrieve the appropriate origin.
        /// </summary>
        /// <param name="bBox"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        private Autodesk.Revit.DB.UV GetOffSet(BoundingBoxUV bBox, double x, double y)
        {
            return new Autodesk.Revit.DB.UV(bBox.Min.U + x * GOLDENSECTION, bBox.Min.V + y * GOLDENSECTION);
        }

        /// <summary>
        /// Calculate the appropriate distance between the views lay on the sheet.
        /// </summary>
        /// <param name="bBox">The outline of sheet.</param>
        /// <param name="amount">Amount of views.</param>
        /// <param name="x">Distance in x axis between each view</param>
        /// <param name="y">Distance in y axis between each view</param>
        private void CalculateDistance(BoundingBoxUV bBox, int amount, ref double x, ref double y)
        {
            double xLength = (bBox.Max.U - bBox.Min.U) * (1 - TITLEBAR);
            double yLength = (bBox.Max.V - bBox.Min.V);

            //calculate appropriate rows numbers.
            double result = Math.Sqrt(amount);

            while (0 < (result - (int)result))
            {
                amount = amount + 1;
                result = Math.Sqrt(amount);
            }
            m_rows = result;
            double area = xLength * yLength / amount;

            //calculate appropriate distance between the views.
            if (bBox.Max.U > bBox.Max.V)
            {
                x = Math.Sqrt(area / GOLDENSECTION);
                y = GOLDENSECTION * x;
            }
            else
            {
                y = Math.Sqrt(area / GOLDENSECTION);
                x = GOLDENSECTION * y;
            }
        }

        /// <summary>
        /// Rescale the view's Scale value for suitable.
        /// </summary>
        /// <param name="view">The view to be located on sheet.</param>
        /// <param name="x">Distance in x axis between each view</param>
        /// <param name="y">Distance in y axis between each view</param>
        static private void Rescale(Autodesk.Revit.DB.View view, double x, double y)
        {
            double Rescale = 2;
            Autodesk.Revit.DB.UV outline = new Autodesk.Revit.DB.UV(view.Outline.Max.U - view.Outline.Min.U,
                view.Outline.Max.V - view.Outline.Min.V);

            if (outline.U > outline.V)
            {
                Rescale = outline.U / x * Rescale;
            }
            else
            {
                Rescale = outline.V / y * Rescale;
            }

            if (1 != view.Scale && 0 != Rescale)
            {
                view.Scale = (int)(view.Scale * Rescale);
            }
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                m_allViews.Dispose();
                m_selectedViews.Dispose();
            }

            // TODO: free unmanaged resources (unmanaged objects) and override finalizer
            // TODO: set large fields to null
        }

        public void Dispose()
        {
            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
   }
}

=== CODE_BLOCK_0003 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
        {
            UIApplication uiApp = commandData.Application;
            UIDocument uiDoc = uiApp.ActiveUIDocument;
            Document doc = uiDoc.Document;
            s_docName = doc.PathName;

            Element element = null;
            try
            {
                element = doc.GetElement(uiDoc.Selection.PickObject(ObjectType.Element, "Select an element for the AVF demonstration."));
            }
            catch (System.Exception)
            {
                message = "User aborted the tool.";
                return Result.Cancelled;
            }
            
            // Set up SpatialFieldManager to hold results
            s_activeViewId = doc.ActiveView.Id; 
            SpatialFieldManager oldSfm = null; 
            View oldView = null;
            if (s_oldViewId != null) oldView = doc.GetElement(s_oldViewId) as View;
            if (oldView != null) oldSfm = SpatialFieldManager.GetSpatialFieldManager(oldView);
            // If a previous SFM was being managed, delete it
            if (oldSfm != null) oldSfm.RemoveSpatialFieldPrimitive(s_oldSpatialFieldId);

            // Setup container object for executing the calculation
            MultithreadedCalculationContainer container = CreateContainer(element);

            // Register updater to watch for geometry changes
            SpatialFieldUpdater updater = new SpatialFieldUpdater(container,uiApp.ActiveAddInId);
            if (!UpdaterRegistry.IsUpdaterRegistered(updater.GetUpdaterId())) 
                UpdaterRegistry.RegisterUpdater(updater, doc);
            IList<ElementId> idCollection = new List<ElementId>();
            idCollection.Add(element.Id);
            UpdaterRegistry.RemoveAllTriggers(s_updaterId);
            UpdaterRegistry.AddTrigger(updater.GetUpdaterId(), doc, idCollection, Element.GetChangeTypeGeometry());

            // Register idling event
            uiApp.Idling += new EventHandler<IdlingEventArgs>(container.UpdateWhileIdling);

            // Start new thread
            Thread thread = new Thread(new ThreadStart(container.Run));
            thread.Start();

            return Autodesk.Revit.UI.Result.Succeeded;
        }

        /// <summary>
        /// Prepares a container object that carries out the calculations without invoking Revit API calls.
        /// </summary>
        /// <param name="element">The element for the calculations.</param>
        /// <returns>The container.</returns>
        public static MultithreadedCalculationContainer CreateContainer(Element element)
        {
            Document doc = element.Document;
            View activeView = doc.GetElement(s_activeViewId) as View;

            // Figure out which is the largest face facing the user
            XYZ viewDirection = activeView.ViewDirection.Normalize();   
            Face biggestFace = GetBiggestFaceFacingUser(element, viewDirection);
                 
            // Get or create SpatialFieldManager for AVF results
            SpatialFieldManager sfm = SpatialFieldManager.GetSpatialFieldManager(activeView);
            if (sfm == null) sfm = SpatialFieldManager.CreateSpatialFieldManager(activeView, 1);

            // Reference the target face
            s_spatialFieldId = sfm.AddSpatialFieldPrimitive(biggestFace.Reference);

            // Compute the range of U and V for the calculation
            BoundingBoxUV bbox = biggestFace.GetBoundingBox();

            return new MultithreadedCalculationContainer(doc.PathName, bbox.Min, bbox.Max);
       }

        /// <summary>
        /// Gets the biggest face which faces the user.  Assumes that the element is a wall, or floor, or other "2-sided" element, and that
        /// one of the two biggest faces will be facing roughly towards the viewer.
        /// </summary>
        /// <param name="element">The element.</param>
        /// <param name="viewDirection">The view direction.</param>
        /// <returns>The face.  Face.Reference will also be populated.</returns>
        private static Face GetBiggestFaceFacingUser(Element element, XYZ viewDirection)
        {
            
            // Holds the faces sorted by area
            SortedDictionary<double, List<Face>> faceAreas = new SortedDictionary<double, List<Face>>();

            // Get the element geometry
            Options options = new Options();
            options.ComputeReferences = true;
            GeometryElement geomElem = element.get_Geometry(options);
            
            // Look at the faces in each solid
            foreach (GeometryObject geomObj in geomElem)
            {
                Solid solid = geomObj as Solid;
                if (solid != null)
                {
                    foreach (Face face in solid.Faces)
                    {
                        double area = face.Area;
                        // Save the face to the collection
                        if (faceAreas.ContainsKey(area))
                        {
                            faceAreas[area].Add(face);
                        }
                        else
                        {
                            List<Face> faces = new List<Face>();
                            faces.Add(face);
                            faceAreas.Add(area, faces);
                        }
                    }
                }
            }

            // Get biggest two faces.  There might be two faces in the last item, or one face in the last item.
            int count = faceAreas.Count;
            KeyValuePair<double, List<Face>> faceCollection1 = faceAreas.ElementAt<KeyValuePair<double, List<Face>>>(count - 1);
            KeyValuePair<double, List<Face>> faceCollection2 = faceAreas.ElementAt<KeyValuePair<double, List<Face>>>(count - 2);

            Face face1 = null;
            Face face2 = null;
            // Two or more equal faces.  Use the first two.
            if (faceCollection1.Value.Count > 1)
            {
                face1 = faceCollection1.Value[0];
                face2 = faceCollection1.Value[1];
            }
            // One largest face.  Use the first face from the next item for comparison.
            else
            {
                face1 = faceCollection1.Value[0];
                face2 = faceCollection2.Value[0];
            }

            // Compute face normal
            BoundingBoxUV box = face1.GetBoundingBox();
            UV faceCenter = (box.Max + box.Min) / 2;
            XYZ faceNormal = face1.ComputeNormal(faceCenter).Normalize();

            // Compute angle to the view direction.  If less than 90 degrees, keep this face.
            double angle = viewDirection.AngleTo(faceNormal);

            Face biggestFace = null;
            if (Math.Abs(angle) < Math.PI / 2)
                biggestFace = face1;
            else
                biggestFace = face2;

            return biggestFace;
        }

        /// <summary>
        /// Updater called when wall geometry changes, so analysis results can update.
        /// </summary>
        public class SpatialFieldUpdater : IUpdater
        {
            // The old container object.
            MultithreadedCalculationContainer containerOld;

            public SpatialFieldUpdater(MultithreadedCalculationContainer _container, AddInId addinId)
            {
                containerOld = _container;
                s_updaterId = new UpdaterId(addinId, new Guid("FBF2F6B2-4C06-42d4-97C1-D1B4EB593EFF"));
            }

            // Execution method for the updater
            public void Execute(UpdaterData data)
            {
                // Remove old idling event callback
                UIApplication uiApp = new UIApplication(data.GetDocument().Application);
                uiApp.Idling -= containerOld.UpdateWhileIdling;
                containerOld.Stop();

                // Clear the current AVF results
                Document doc = data.GetDocument();
                View activeView = doc.GetElement(s_activeViewId) as View;
                SpatialFieldManager sfm = SpatialFieldManager.GetSpatialFieldManager(activeView);
                sfm.Clear();

                // Restart the multithread calculation with a new container
                Element modifiedElem = doc.GetElement(data.GetModifiedElementIds().First<ElementId>());
                MultithreadedCalculationContainer container = MultithreadedCalculation.CreateContainer(modifiedElem);
                containerOld = container;

                // Setup the new idling callback
                uiApp.Idling += new EventHandler<IdlingEventArgs>(container.UpdateWhileIdling);

                // Start the thread
                Thread threadNew = new Thread(new ThreadStart(container.Run));
                threadNew.Start();
            }

            public string GetAdditionalInformation() { return "AVF DMU Thread sample"; }
            public ChangePriority GetChangePriority() { return ChangePriority.FloorsRoofsStructuralWalls; }
            public UpdaterId GetUpdaterId() { return s_updaterId; }
            public string GetUpdaterName() { return "AVF DMU Thread"; }
        }

        /// <summary>
        /// Container class that manages the multithreaded calculation and idling activity.
        /// </summary>
        public class MultithreadedCalculationContainer
        {
            private volatile bool m_stop = false;
            UV m_min;
            UV m_max;
            
            string m_docName;
            IList<ResultsData> results = new List<ResultsData>();
            IList<UV> m_uvToCalculate = new List<UV>();
            int m_uvToCalculateCount;
            IList<UV> uvPts = new List<UV>();
            IList<ValueAtPoint> valList = new List<ValueAtPoint>();

            public MultithreadedCalculationContainer(string _docName, UV _min, UV _max)
            {
                m_docName = _docName;
                m_min = _min;
                m_max = _max;
            }

            public void Run()
            {
                m_uvToCalculate = DetermineFacePoints();
                m_uvToCalculateCount = m_uvToCalculate.Count;
                Calculate();
            }

            /// <summary>
            /// Stops the thread/calculation and application via idling.
            /// </summary>
            public void Stop()
            {
                m_stop = true;
            }


            /// <summary>
            /// The idling callback which adds data to the AVF results.
            /// </summary>
            /// <param name="sender"></param>
            /// <param name="e"></param>
            public void UpdateWhileIdling(object sender, IdlingEventArgs e)
            {
                UIApplication uiApp = sender as UIApplication;

                // Get SpatialFieldManager

                AnalysisResultSchema resultSchema = new AnalysisResultSchema("Schema Name", "Description");
                SpatialFieldManager sfm = SpatialFieldManager.GetSpatialFieldManager(uiApp.ActiveUIDocument.Document.ActiveView);
                
                if (sfm == null) sfm = SpatialFieldManager.CreateSpatialFieldManager(uiApp.ActiveUIDocument.Document.ActiveView, 1);
                int schemaIndex = sfm.RegisterResult(resultSchema);
                // If stopping, clear results and unset event.
                if (m_stop)
                {
                    lock (results)
                    {
                        results.Clear();
                    }
                    uiApp.Idling -= UpdateWhileIdling;
                    return;
                }

                // If document was closed and new document opened, do not run the update.
                if (uiApp.ActiveUIDocument.Document.PathName == m_docName) 
                {
                    // Lock access to current calculated results
                    lock (results)
                    {
                        if (results.Count == 0) return;

                        // Turn each result to an AVF ValueAtPoint
                        foreach (ResultsData rData in results)
                        {
                            uvPts.Add(new UV(rData.UV.U, rData.UV.V));
                            IList<double> doubleList = new List<double>();
                            doubleList.Add(rData.Value);
                            valList.Add(new ValueAtPoint(doubleList));
                        }
                        FieldDomainPointsByUV pntsByUV = new FieldDomainPointsByUV(uvPts);
                        FieldValues fieldValues = new FieldValues(valList);

                        // Update with calculated values
                        Transaction t = new Transaction(uiApp.ActiveUIDocument.Document);
                        t.SetName("AVF");
                        t.Start();
                        if (!m_stop)
                            sfm.UpdateSpatialFieldPrimitive(s_spatialFieldId, pntsByUV, fieldValues, schemaIndex);
                        t.Commit();  

                        // Clear results already processed.
                        results.Clear();

                        // If no more results to process, remove the idling event
                        if (m_uvToCalculateCount == 0)
                        {
                            uiApp.Idling -= UpdateWhileIdling;
                            s_oldViewId = s_activeViewId;
                            s_oldSpatialFieldId = s_spatialFieldId;
                        }
                    }
                }
            }

            // Calculate the results in a loop 
            void Calculate()
            {
                foreach (UV uv in m_uvToCalculate)
                {
                    if (m_stop)
                    {
                        m_uvToCalculateCount = 0;
                        return;
                    }
                    // Lock access to results while the data is added
                    lock (results)
                    {
                        results.Add(new ResultsData(uv, 1000 * Math.Sin(Math.Abs(uv.U * uv.V))));
                        Thread.Sleep(500); // to simulate the effect of a complex computation
                        m_uvToCalculateCount--;
                    }
                }
            }

            private const int numberOfUPnts = 10;
            private const int numberOfVPnts = 5;

            // Setup the list of UV points to calculate results for
            IList<UV> DetermineFacePoints()
            {
                IList<UV> uvList = new List<UV>();
                double upnt = m_min.U;
                double incrementU = (m_max.U - m_min.U) / (numberOfUPnts - 1);
                double incrementV = (m_max.V - m_min.V) / (numberOfVPnts - 1);
                while (upnt <= m_max.U)
                {
                    double vpnt = m_min.V;
                    while (vpnt <= m_max.V)
                    {
                        uvList.Add(new UV(upnt,vpnt));
                        vpnt = vpnt + incrementV;
                    }
                    upnt = upnt + incrementU;
                }
                return uvList;
            }
        }

        // Represents a set of results for the calculation
        public class ResultsData
        {
            public UV UV;
            public double Value;
            public ResultsData(UV uv, double value)
            {
                this.UV = uv;
                Value = value;
            }
        }
    }
}

=== CODE_BLOCK_0005 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)
      {
         ExternalCommandData cdata = commandData;
         Autodesk.Revit.ApplicationServices.Application app = commandData.Application.Application;
         Document doc = commandData.Application.ActiveUIDocument.Document;
         UIDocument uiDoc = commandData.Application.ActiveUIDocument;

         Transaction trans = new Transaction(doc, "Revit.SDK.Samples.AnalysisVisualizationFramework");
         trans.Start();

         SpatialFieldManager sfm = SpatialFieldManager.GetSpatialFieldManager(doc.ActiveView);         
         if (sfm == null) sfm = SpatialFieldManager.CreateSpatialFieldManager(doc.ActiveView, 1);

         IList<Reference> refList = new List<Reference>();
         refList = uiDoc.Selection.PickObjects(Autodesk.Revit.UI.Selection.ObjectType.Face);
                 foreach (Reference reference in refList)
                 {

                         IList<UV> uvPts = new List<UV>();

                         List<double> doubleList = new List<double>();
                         IList<ValueAtPoint> valList = new List<ValueAtPoint>();
                         Face face = doc.GetElement(reference).GetGeometryObjectFromReference(reference)as Face;
                         BoundingBoxUV bb = face.GetBoundingBox();
                         UV min = bb.Min;
                         UV max = bb.Max;

                         for (double u = min.U; u < max.U; u += (max.U - min.U) / 10)
                         {
                             for (double v = min.V; v < max.V; v += (max.V - min.V) / 10)
                             {
                                 UV uv = new UV(u, v);
                                 if (face.IsInside(uv))
                                 {
                                     uvPts.Add(uv);
                                     doubleList.Add(v + DateTime.Now.Second);
                                     valList.Add(new ValueAtPoint(doubleList));
                                     doubleList.Clear();
                                 }
                             }
                         }

                         FieldDomainPointsByUV pnts = new FieldDomainPointsByUV(uvPts);
                         FieldValues vals = new FieldValues(valList);
                         int idx = sfm.AddSpatialFieldPrimitive(reference);
                         AnalysisResultSchema resultSchema = new AnalysisResultSchema("Schema 1", "Schema 1 Description"); 
                         sfm.UpdateSpatialFieldPrimitive(idx, pnts, vals, sfm.RegisterResult(resultSchema));
                 }



         trans.Commit();
         return Result.Succeeded;
      }
   }
}

=== CODE_BLOCK_0007 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, "Revit.SDK.Samples.AreaReinCurve");
            trans.Start();
            ElementSet selected = new ElementSet();
            foreach (ElementId elementId in revit.Application.ActiveUIDocument.Selection.GetElementIds())
            {
               selected.Insert(revit.Application.ActiveUIDocument.Document.GetElement(elementId));
            }

            try
            {
                m_doc = revit.Application.ActiveUIDocument.Document;

                //selected is not one rectangular AreaReinforcement
                if (!PreData(selected))
                {
                    message = "Please select only one rectangular AreaReinforcement.";
                    trans.RollBack();
                    return Autodesk.Revit.UI.Result.Failed;
                }

                //fail to turn off layers
                if (!TurnOffLayers())
                {
                    message = "Can't turn off layers as expected or can't find these layers.";
                    trans.RollBack();
                    return Autodesk.Revit.UI.Result.Failed;
                }

                //fail to remove hooks
                if (!ChangeHookType())
                {
                    message = "Can't remove HookTypes as expected.";
                    trans.RollBack();
                    return Autodesk.Revit.UI.Result.Failed;
                }
            }
            catch (ApplicationException appEx)
            {
                message = appEx.ToString();
                trans.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }
            catch
            {
                message = "Unexpected error happens.";
                trans.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }

            //command is successful
            string msg = "All layers but Major Direction Layer or Exterior Direction Layer ";
            msg += "have been turn off; ";
            msg += "Removed the Hooks from one boundary curve of the Major Direction Layer ";
            msg += "or Exterior Direction Layer.";
            TaskDialog.Show("Revit", msg);
            trans.Commit();
            return Autodesk.Revit.UI.Result.Succeeded;
        }

        /// <summary>
        /// check whether the selected is expected, prepare necessary data
        /// </summary>
        /// <param name="selected">selected elements</param>
        /// <returns>whether the selected AreaReinforcement is expected</returns>
        private bool PreData(ElementSet selected)
        {
            //selected is not only one AreaReinforcement
            if (selected.Size != 1)
            {
                return false;
            }
            foreach (Object o in selected)
            {
                m_areaRein = o as AreaReinforcement;
                if (null == m_areaRein)
                {
                    return false;
                }
            }

            //whether the selected AreaReinforcement is rectangular
            CurveArray curves = new CurveArray();
            m_areaReinCurves = new List<AreaReinforcementCurve>();
            IList<ElementId> curveIds = m_areaRein.GetBoundaryCurveIds();
            foreach (ElementId o in curveIds)
            {
                AreaReinforcementCurve areaCurve = m_doc.GetElement(o) as AreaReinforcementCurve;
                if (null == areaCurve)
                {
                    ApplicationException appEx = new ApplicationException
                        ("There is unexpected error with selected AreaReinforcement.");
                    throw appEx;
                }
                m_areaReinCurves.Add(areaCurve);
                curves.Append(areaCurve.Curve);
            }
            bool flag = GeomUtil.IsRectangular(curves);

            return flag;
        }

        /// <summary>
        /// turn off all layers but the Major Direction Layer or Exterior Direction Layer
        /// </summary>
        /// <returns>whether the command is successful</returns>
        private bool TurnOffLayers()
        {
            //AreaReinforcement is on the floor or slab
            bool flag = true;
            flag = ParameterUtil.SetParaInt(m_areaRein,
                BuiltInParameter.REBAR_SYSTEM_ACTIVE_BOTTOM_DIR_1, 0);
            flag &= ParameterUtil.SetParaInt(m_areaRein,
                BuiltInParameter.REBAR_SYSTEM_ACTIVE_BOTTOM_DIR_2, 0);
            flag &= ParameterUtil.SetParaInt(m_areaRein,
                BuiltInParameter.REBAR_SYSTEM_ACTIVE_TOP_DIR_2, 0);

            //AreaReinforcement is on the wall
            if (!flag)
            {
                flag = true;
                flag &= ParameterUtil.SetParaInt(m_areaRein, "Interior Major Direction", 0);
                flag &= ParameterUtil.SetParaInt(m_areaRein, "Exterior Minor Direction", 0);
                flag &= ParameterUtil.SetParaInt(m_areaRein, "Interior Minor Direction", 0);
            }

            return flag;
        }

        /// <summary>
        /// remove the hooks from one boundary curve of the Major Direction Layer 
        /// or Exterior Direction Layer
        /// </summary>
        /// <returns>whether the command is successful</returns>
        private bool ChangeHookType()
        {
            //find two vertical AreaReinforcementCurve
            Line line0 = m_areaReinCurves[0].Curve as Line;
            Line line1 = m_areaReinCurves[1].Curve as Line;
            Line line2 = m_areaReinCurves[2].Curve as Line;
            AreaReinforcementCurve temp = null;
            if (GeomUtil.IsVertical(line0, line1))
            {
                temp = m_areaReinCurves[1];
            }
            else
            {
                temp = m_areaReinCurves[2];
            }

            //remove hooks
            ParameterUtil.SetParaInt(m_areaReinCurves[0],
                BuiltInParameter.REBAR_SYSTEM_OVERRIDE, -1);
            Parameter para = m_areaReinCurves[0].get_Parameter(
                BuiltInParameter.REBAR_SYSTEM_HOOK_TYPE_TOP_DIR_1);
            bool flag = ParameterUtil.SetParaNullId(para);

            ParameterUtil.SetParaInt(temp, BuiltInParameter.REBAR_SYSTEM_OVERRIDE, -1);
            para = temp.get_Parameter(
                BuiltInParameter.REBAR_SYSTEM_HOOK_TYPE_TOP_DIR_1);
            flag &= ParameterUtil.SetParaNullId(para);

            return flag;
        }
    }
}

=== CODE_BLOCK_0009 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message,
            ElementSet elements)
        {
            // set out default result to Failed.
            Autodesk.Revit.UI.Result retRes = Autodesk.Revit.UI.Result.Failed;

            m_application = commandData.Application.Application;
            m_document = commandData.Application.ActiveUIDocument.Document;
            Trace.Listeners.Clear();
            Trace.AutoFlush = true;

            //get the system type id of the duct
            ElementClassFilter systemTypeFilter = new ElementClassFilter(typeof(MEPSystemType));
            FilteredElementCollector C = new FilteredElementCollector(m_document);
            C.WherePasses(systemTypeFilter);
            foreach (MEPSystemType type in C)
            {
                if (type.SystemClassification == MEPSystemClassification.SupplyAir)
                {
                    systemTypeId = type.Id;
                    break;
                }
            }

            string outputFileName = Path.Combine(Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location), "AutoRoute.log");
            if (File.Exists(outputFileName))
            {
                File.Delete(outputFileName);
            }
            TextWriterTraceListener listener = new TextWriterTraceListener(outputFileName);
            Trace.Listeners.Add(listener);

            Transaction transaction = new Transaction(m_document, "Sample_AutoRoute");
            try
            {
                transaction.Start();

                //set the level of the duct            
                lvl = Level.Create(m_document, 0.0);

                //Lists to temporarily record the created elements
                List<Duct> ducts = new List<Duct>();
                List<GXYZ> points = new List<GXYZ>();
                List<Connector> connectors = new List<Connector>();
                List<Connector> baseConnectors = new List<Connector>();

                //Get the connectors and bounding boxes
                List<Autodesk.Revit.DB.ElementId> ids = new List<ElementId>();
                ids.Add(new ElementId(378728L));
                ids.Add(new ElementId(378707L));
                ids.Add(new ElementId(378716L));

                FamilyInstance[] instances = new FamilyInstance[3];
                Autodesk.Revit.DB.BoundingBoxXYZ[] boxes = new Autodesk.Revit.DB.BoundingBoxXYZ[3];
                Connector[] conns = new Connector[3];
                ConnectorSetIterator csi = null;
                for (int i = 0; i < ids.Count; ++i)
                {
                    Element element = m_document.GetElement(ids[i]);
                    if (null == element)
                    {
                        message = "Element " + ids[i].ToString() + " can't be found.";
                        return Autodesk.Revit.UI.Result.Failed;
                    }
                    instances[i] = element as FamilyInstance;
                    csi = ConnectorInfo.GetConnectors(ids[i]).ForwardIterator();
                    csi.MoveNext();
                    conns[i] = csi.Current as Connector;
                    boxes[i] = instances[i].get_BoundingBox(m_document.ActiveView);
                }

                //Find the "Out" and "SupplyAir" connector on the base equipment
                csi = ConnectorInfo.GetConnectors(ids[0]).ForwardIterator();
                while (csi.MoveNext())
                {
                    Connector conn = csi.Current as Connector;
                    if (conn.Direction == FlowDirectionType.Out && conn.DuctSystemType == DuctSystemType.SupplyAir)
                    {
                        conns[0] = conn;
                    }
                }

                //Create a mechanical system with a base air supply equipment and 2 terminals.
                m_mechanicalSystem = CreateMechanicalSystem(
                    //[378728][SupplyAir][Out][RectProfile][OST_MechanicalEquipment]
                        new ConnectorInfo(new ElementId(378728L), conns[0].Origin.X, conns[0].Origin.Y, conns[0].Origin.Z),
                    new ConnectorInfo[]{
                        //[378707][SupplyAir][In][RectProfile]
                        new ConnectorInfo(new ElementId(378707L), conns[1].Origin.X, conns[1].Origin.Y, conns[1].Origin.Z),
                        //[378716][SupplyAir][In][RectProfile]
                        new ConnectorInfo(new ElementId(378716L), conns[2].Origin.X, conns[2].Origin.Y, conns[2].Origin.Z)
                    },
                    DuctSystemType.SupplyAir
                );

                //Get the boundary of the system
                double minX = conns[0].Origin.X;
                double minY = conns[0].Origin.Y;
                double maxX = conns[0].Origin.X;
                double maxY = conns[0].Origin.Y;
                double maxZ = conns[0].Origin.Z;
                for (int i = 1; i < boxes.Length; ++i)
                {
                    if (conns[i].Origin.X < minX)
                        minX = conns[i].Origin.X;
                    if (conns[i].Origin.Y < minY)
                        minY = conns[i].Origin.Y;
                    if (conns[i].Origin.X > maxX)
                        maxX = conns[i].Origin.X;
                    if (conns[i].Origin.Y > maxY)
                        maxY = conns[i].Origin.Y;
                    if (conns[i].Origin.Z > maxZ)
                        maxZ = conns[i].Origin.Z;
                }

                //Calculate the optional values for the trunk ducts
                double midX = (minX + maxX) / 2;
                double midY = (minY + maxY) / 2;
                double[] baseXValues = new double[3] { midX, (minX + midX) / 2, (maxX + midX) / 2 };
                double[] baseYValues = new double[3] { midY, (minY + midY) / 2, (maxY + midY) / 2 };

                //Get the duct type for the ducts to be created
                dtRectangle = m_document.GetElement(ductTypeId) as DuctType;


                //Create the ducts and elbows that connect the base mechanical equipment
                GXYZ connectorDirection = conns[0].CoordinateSystem.BasisZ;

                if (0 == connectorDirection.DistanceTo(new GXYZ(-1, 0, 0)))
                {
                    points.Add(new GXYZ(conns[0].Origin.X - min1FittingLength, conns[0].Origin.Y, conns[0].Origin.Z));
                    points.Add(new GXYZ(conns[0].Origin.X - min2FittingsLength, conns[0].Origin.Y, conns[0].Origin.Z + min1FittingLength));
                    points.Add(new GXYZ(conns[0].Origin.X - min2FittingsLength, conns[0].Origin.Y, maxZ + verticalTrunkOffset - min1FittingLength));
                }
                else if (0 == connectorDirection.DistanceTo(new GXYZ(1, 0, 0)))
                {
                    points.Add(new GXYZ(conns[0].Origin.X + min1FittingLength, conns[0].Origin.Y, conns[0].Origin.Z));
                    points.Add(new GXYZ(conns[0].Origin.X + min2FittingsLength, conns[0].Origin.Y, conns[0].Origin.Z + min1FittingLength));
                    points.Add(new GXYZ(conns[0].Origin.X + min2FittingsLength, conns[0].Origin.Y, maxZ + verticalTrunkOffset - min1FittingLength));
                }
                else if (0 == connectorDirection.DistanceTo(new GXYZ(0, -1, 0)))
                {
                    points.Add(new GXYZ(conns[0].Origin.X, conns[0].Origin.Y - min1FittingLength, conns[0].Origin.Z));
                    points.Add(new GXYZ(conns[0].Origin.X, conns[0].Origin.Y - min2FittingsLength, conns[0].Origin.Z + min1FittingLength));
                    points.Add(new GXYZ(conns[0].Origin.X, conns[0].Origin.Y - min2FittingsLength, maxZ + verticalTrunkOffset - min1FittingLength));
                }
                else if (0 == connectorDirection.DistanceTo(new GXYZ(0, 1, 0)))
                {
                    points.Add(new GXYZ(conns[0].Origin.X, conns[0].Origin.Y + min1FittingLength, conns[0].Origin.Z));
                    points.Add(new GXYZ(conns[0].Origin.X, conns[0].Origin.Y + min2FittingsLength, conns[0].Origin.Z + min1FittingLength));
                    points.Add(new GXYZ(conns[0].Origin.X, conns[0].Origin.Y + min2FittingsLength, maxZ + verticalTrunkOffset - min1FittingLength));
                }
                ducts.Add(Duct.Create(m_document, ductTypeId, lvl.Id,conns[0], points[0]));


                ducts.Add(Duct.Create(m_document, systemTypeId, ductTypeId, lvl.Id, points[1], points[2]));
                connectors.Add(ConnectorInfo.GetConnector(ducts[0].Id, points[0]));
                connectors.Add(ConnectorInfo.GetConnector(ducts[1].Id, points[1]));
                connectors.Add(ConnectorInfo.GetConnector(ducts[1].Id, points[2]));
                connectors[0].ConnectTo(connectors[1]);
                m_document.Create.NewElbowFitting(connectors[0], connectors[1]);
                baseConnectors.Add(connectors[2]);

                //Create the vertical ducts for terminals
                points.Clear();
                ducts.Clear();

                points.Add(new GXYZ(conns[1].Origin.X, conns[1].Origin.Y, maxZ + verticalTrunkOffset - min1FittingLength));
                points.Add(new GXYZ(conns[2].Origin.X, conns[2].Origin.Y, maxZ + verticalTrunkOffset - min1FittingLength));
                ducts.Add(Duct.Create(m_document, ductTypeId, lvl.Id, conns[1], points[0]));
                ducts.Add(Duct.Create(m_document, ductTypeId, lvl.Id, conns[2], points[1]));
                baseConnectors.Add(ConnectorInfo.GetConnector(ducts[0].Id, points[0]));
                baseConnectors.Add(ConnectorInfo.GetConnector(ducts[1].Id, points[1]));

                //Connect the system by creating the trunk line of ducts and connect them to the base connectors
                SortConnectorsByX(baseConnectors);
                for (int i = 0; i < baseYValues.Length; ++i)
                {
                    if (ConnectSystemOnXAxis(baseConnectors, baseYValues[i]))
                    {
                        LogUtility.WriteMechanicalSystem(m_mechanicalSystem);
                        return Autodesk.Revit.UI.Result.Succeeded;
                    }
                }

                SortConnectorsByY(baseConnectors);
                for (int i = 0; i < baseXValues.Length; ++i)
                {
                    if (ConnectSystemOnYAxis(baseConnectors, baseXValues[i]))
                    {
                        LogUtility.WriteMechanicalSystem(m_mechanicalSystem);
                        return Autodesk.Revit.UI.Result.Succeeded;
                    }
                }

                //If all the cases fail to route the system, try the trunks out of the bounding box
                SortConnectorsByX(baseConnectors);
                if (ConnectSystemOnXAxis(baseConnectors, maxY + horizontalOptionalTrunkOffset))
                {
                    LogUtility.WriteMechanicalSystem(m_mechanicalSystem);
                    return Autodesk.Revit.UI.Result.Succeeded;
                }

                SortConnectorsByY(baseConnectors);
                if (ConnectSystemOnYAxis(baseConnectors, maxX + horizontalOptionalTrunkOffset))
                {
                    LogUtility.WriteMechanicalSystem(m_mechanicalSystem);
                    return Autodesk.Revit.UI.Result.Succeeded;
                }

                //If there's no path for the connection, choose one path and let Revit report the error
                connectors.Clear();
                SortConnectorsByX(baseConnectors);
                connectors.AddRange(CreateDuct(new GXYZ(baseConnectors[0].Origin.X + min1FittingLength, baseYValues[0], maxZ + verticalTrunkOffset), new GXYZ(baseConnectors[1].Origin.X - min1FittingLength, baseYValues[0], maxZ + verticalTrunkOffset)));
                connectors.AddRange(CreateDuct(new GXYZ(baseConnectors[1].Origin.X + min1FittingLength, baseYValues[0], maxZ + verticalTrunkOffset), new GXYZ(baseConnectors[2].Origin.X - min1FittingLength, baseYValues[0], maxZ + verticalTrunkOffset)));
                ConnectWithElbowFittingOnXAxis(baseConnectors[0], connectors[0]);
                ConnectWithElbowFittingOnXAxis(baseConnectors[2], connectors[3]);
                ConnectWithTeeFittingOnXAxis(baseConnectors[1], connectors[1], connectors[2], false);

            }
            catch (Exception ex)
            {
                Trace.WriteLine(ex.ToString());
                message = ex.Message;
                retRes = Autodesk.Revit.UI.Result.Failed;
            }
            finally
            {
                transaction.Commit();
                Trace.Flush();
                listener.Close();
                Trace.Close();
                Trace.Listeners.Remove(listener);
            }
            return retRes;
        }
        #endregion

        /// <summary>
        /// Connect the system with a trunk line of ducts on X axis
        /// </summary>
        /// <param name="baseConnectors">the upper connectors of the vertical ducts that derived from the terminals and the base equipment</param>
        /// <param name="baseY">the y value of the trunk line</param>
        /// <returns>
        /// true if the system can be connected
        /// false if the system cannot be connected
        /// </returns>
        private bool ConnectSystemOnXAxis(List<Connector> baseConnectors, double baseY)
        {
            //Check the count of the base connectors
            if (null == baseConnectors || 3 != baseConnectors.Count)
            {
                return false;
            }
            for (int i = 0; i < baseConnectors.Count; ++i)
            {
                //Check the distance of the connector from the trunk
                if (baseConnectors[i].Origin.Y != baseY && Math.Abs(baseConnectors[i].Origin.Y - baseY) < min1Duct2FittingsLength)
                {
                    return false;
                }
                //Check the distance of the connectors on X axis
                for (int j = i + 1; j < baseConnectors.Count; ++j)
                {
                    if (baseConnectors[j].Origin.X != baseConnectors[i].Origin.X && baseConnectors[j].Origin.X - baseConnectors[i].Origin.X < min2FittingsLength)
                    {
                        return false;
                    }
                }
            }
            try
            {
                double baseZ = baseConnectors[0].Origin.Z + min1FittingLength;
                //Create the ducts and elbow fittings to connect the vertical ducts and the trunk ducts
                List<Connector> connectors = new List<Connector>();

                if (baseConnectors[0].Origin.X == baseConnectors[1].Origin.X)
                {
                    //All 3 connectors are with the same X value
                    if (baseConnectors[1].Origin.X == baseConnectors[2].Origin.X)
                    {
                        return false;
                    }
                    else
                    {
                        //The 1st and 2nd base connectors are on the same side of the trunk
                        if (Math.Sign(baseConnectors[0].Origin.Y - baseY) * Math.Sign(baseConnectors[1].Origin.Y - baseY) == 1)
                        {
                            return false;
                        }

                        //Create the trunk
                        connectors = CreateDuct(new GXYZ(baseConnectors[0].Origin.X + min1FittingLength, baseY, baseZ), new GXYZ(baseConnectors[2].Origin.X - min1FittingLength, baseY, baseZ));

                        //Create a tee fitting connecting the 1st and 2nd base connectors to the trunk
                        ConnectWithTeeFittingOnXAxis(baseConnectors[0], baseConnectors[1], connectors[0], true);

                        //Create an elbow fitting connection the 3rd base connector to the trunk
                        ConnectWithElbowFittingOnXAxis(baseConnectors[2], connectors[1]);
                    }
                }
                else
                {
                    //Create the segment of duct on the trunk to be connected to the 1st base connector
                    connectors = CreateDuct(new GXYZ(baseConnectors[0].Origin.X + min1FittingLength, baseY, baseZ), new GXYZ(baseConnectors[1].Origin.X - min1FittingLength, baseY, baseZ));

                    //Create an elbow fitting connection the 1st base connector with the trunk
                    ConnectWithElbowFittingOnXAxis(baseConnectors[0], connectors[0]);

                    if (baseConnectors[1].Origin.X == baseConnectors[2].Origin.X)
                    {
                        //The 2nd and 3rd connectors are on the same side of the trunk
                        if (Math.Sign(baseConnectors[1].Origin.Y - baseY) * Math.Sign(baseConnectors[2].Origin.Y - baseY) == 1)
                        {
                            return false;
                        }
                        //Create a tee fitting connecting the 2nd and 3rd base connectors to the trunk
                        ConnectWithTeeFittingOnXAxis(baseConnectors[1], baseConnectors[2], connectors[1], true);
                    }
                    else
                    {
                        connectors.AddRange(CreateDuct(new GXYZ(baseConnectors[1].Origin.X + min1FittingLength, baseY, baseZ), new GXYZ(baseConnectors[2].Origin.X - min1FittingLength, baseY, baseZ)));
                        //Create a tee fitting connecting the 2nd base connector to the trunk
                        ConnectWithTeeFittingOnXAxis(baseConnectors[1], connectors[1], connectors[2], false);
                        //Create an elbow fitting connection the 3rd base connector to the trunk
                        ConnectWithElbowFittingOnXAxis(baseConnectors[2], connectors[3]);
                    }
                }

                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Connect a base connector to a connector on the trunk with an elbow fitting
        /// </summary>
        /// <param name="baseConn">the upper connector of the vertical duct that derived from a terminal or the base equipment</param>
        /// <param name="conn">the connector of a duct on the trunk</param>
        private void ConnectWithElbowFittingOnXAxis(Connector baseConn, Connector conn)
        {
            double baseY = conn.Origin.Y;
            double baseZ = conn.Origin.Z;
            List<Connector> connectors = new List<Connector>();

            //If the distance of the two connectors on the Y axis is greater than 2, create a duct on the Y axis and then connect it to the 2 connectors with elbow fittings
            if (Math.Abs(baseConn.Origin.Y - baseY) > min1Duct2FittingsLength)
            {
                connectors.AddRange(CreateDuct(new GXYZ(baseConn.Origin.X, baseConn.Origin.Y - Math.Sign(baseConn.Origin.Y - baseY), baseZ), new GXYZ(baseConn.Origin.X, baseY + Math.Sign(baseConn.Origin.Y - baseY), baseZ)));
                connectors[0].ConnectTo(baseConn);
                m_document.Create.NewElbowFitting(connectors[0], baseConn);
                connectors[1].ConnectTo(conn);
                m_document.Create.NewElbowFitting(connectors[1], conn);
            }
            //If the distance of the two connectors on the Y axis is less than 2, connect them with an elbow fitting
            else
            {
                baseConn.ConnectTo(conn);
                m_document.Create.NewElbowFitting(baseConn, conn);
            }
        }

        /// <summary>
        /// Connect 3 connectors on the trunk with a tee fitting
        /// </summary>
        /// <param name="conn1">the first connector</param>
        /// <param name="conn2">the second connector</param>
        /// <param name="conn3">the third connector</param>
        /// <param name="flag">a flag to indicate whether there are 2 base connectors or 1 base connector</param>
        private void ConnectWithTeeFittingOnXAxis(Connector conn1, Connector conn2, Connector conn3, bool flag)
        {
            double baseY = conn3.Origin.Y;
            double baseZ = conn3.Origin.Z;

            List<GXYZ> points = new List<GXYZ>();
            List<Duct> ducts = new List<Duct>();
            List<Connector> connectors = new List<Connector>();

            //Connect two base connectors to a connector on the trunk
            if (true == flag)
            {

                Connector baseConn1 = conn1;
                Connector baseConn2 = conn2;
                Connector conn = conn3;

                connectors.AddRange(CreateDuct(new GXYZ(baseConn1.Origin.X, baseConn1.Origin.Y - Math.Sign(baseConn1.Origin.Y - baseY), baseZ), new GXYZ(baseConn1.Origin.X, baseY + Math.Sign(baseConn1.Origin.Y - baseY), baseZ)));
                connectors.AddRange(CreateDuct(new GXYZ(baseConn2.Origin.X, baseConn2.Origin.Y - Math.Sign(baseConn2.Origin.Y - baseY), baseZ), new GXYZ(baseConn2.Origin.X, baseY + Math.Sign(baseConn2.Origin.Y - baseY), baseZ)));

                connectors[0].ConnectTo(baseConn1);
                connectors[2].ConnectTo(baseConn2);
                m_document.Create.NewElbowFitting(connectors[0], baseConn1);
                m_document.Create.NewElbowFitting(connectors[2], baseConn2);

                connectors[1].ConnectTo(connectors[3]);
                connectors[1].ConnectTo(conn);
                connectors[3].ConnectTo(conn);
                m_document.Create.NewTeeFitting(connectors[1], connectors[3], conn);
            }
            //Connect a base connector to two connectors on the trunk
            else
            {
                Connector baseConn = conn1;

                if (Math.Abs(baseConn.Origin.Y - baseY) > min1Duct2FittingsLength)
                {
                    connectors.AddRange(CreateDuct(new GXYZ(baseConn.Origin.X, baseConn.Origin.Y - Math.Sign(baseConn.Origin.Y - baseY), baseZ), new GXYZ(baseConn.Origin.X, baseY + Math.Sign(baseConn.Origin.Y - baseY), baseZ)));
                    baseConn.ConnectTo(connectors[0]);
                    m_document.Create.NewElbowFitting(connectors[0], baseConn);

                    connectors[1].ConnectTo(conn2);
                    connectors[1].ConnectTo(conn3);
                    conn2.ConnectTo(conn3);
                    m_document.Create.NewTeeFitting(conn2, conn3, connectors[1]);
                }
                else
                {
                    baseConn.ConnectTo(conn2);
                    baseConn.ConnectTo(conn3);
                    conn2.ConnectTo(conn3);
                    m_document.Create.NewTeeFitting(conn2, conn3, baseConn);
                }
            }
        }

        /// <summary>
        /// Sort the base connectors by their x values
        /// </summary>
        /// <param name="connectors">the connectors to be sorted</param>
        private void SortConnectorsByX(List<Connector> connectors)
        {
            for (int i = 0; i < connectors.Count; ++i)
            {
                double min = connectors[i].Origin.X;
                int minIndex = i;
                for (int j = i; j < connectors.Count; ++j)
                {
                    if (connectors[j].Origin.X < min)
                    {
                        min = connectors[j].Origin.X;
                        minIndex = j;
                    }
                }
                Connector t = connectors[i];
                connectors[i] = connectors[minIndex];
                connectors[minIndex] = t;
            }
        }

        /// <summary>
        /// Connect the system with a trunk line of ducts on Y axis
        /// </summary>
        /// <param name="baseConnectors">the upper connectors of the vertical ducts that derived from the terminals and the base equipment</param>
        /// <param name="baseX">the x value of the trunk line</param>
        /// <returns>
        /// true if the system can be connected
        /// false if the system cannot be connected
        /// </returns>
        private bool ConnectSystemOnYAxis(List<Connector> baseConnectors, double baseX)
        {
            //Check the count of the base connectors
            if (null == baseConnectors || 3 != baseConnectors.Count)
            {
                return false;
            }
            for (int i = 0; i < baseConnectors.Count; ++i)
            {
                //Check the distance of the connector from the trunk
                if (baseConnectors[i].Origin.X != baseX && Math.Abs(baseConnectors[i].Origin.X - baseX) < min1Duct2FittingsLength)
                {
                    return false;
                }
                //Check the distance of the connectors on Y axis
                for (int j = i + 1; j < baseConnectors.Count; ++j)
                {
                    if (baseConnectors[j].Origin.Y != baseConnectors[i].Origin.Y && baseConnectors[j].Origin.Y - baseConnectors[i].Origin.Y < min2FittingsLength)
                    {
                        return false;
                    }
                }
            }
            try
            {
                double baseZ = baseConnectors[0].Origin.Z + min1FittingLength;
                //Create the ducts and elbow fittings to connect the vertical ducts and the trunk ducts
                List<Connector> connectors = new List<Connector>();

                if (baseConnectors[0].Origin.Y == baseConnectors[1].Origin.Y)
                {
                    //All 3 connectors are with the same Y value
                    if (baseConnectors[1].Origin.Y == baseConnectors[2].Origin.Y)
                    {
                        return false;
                    }
                    else
                    {
                        //The 1st and 2nd base connectors are on the same side of the trunk
                        if (Math.Sign(baseConnectors[0].Origin.X - baseX) * Math.Sign(baseConnectors[1].Origin.X - baseX) == 1)
                        {
                            return false;
                        }

                        //Create the trunk
                        connectors = CreateDuct(new GXYZ(baseX, baseConnectors[0].Origin.Y + min1FittingLength, baseZ), new GXYZ(baseX, baseConnectors[2].Origin.Y - min1FittingLength, baseZ));

                        //Create a tee fitting connecting the 1st and 2nd base connectors to the trunk
                        ConnectWithTeeFittingOnYAxis(baseConnectors[0], baseConnectors[1], connectors[0], true);

                        //Create an elbow fitting connection the 3rd base connector to the trunk
                        ConnectWithElbowFittingOnYAxis(baseConnectors[2], connectors[1]);
                    }
                }
                else
                {
                    //Create the segment of duct on the trunk to be connected to the 1st base connector
                    connectors = CreateDuct(new GXYZ(baseX, baseConnectors[0].Origin.Y + min1FittingLength, baseZ), new GXYZ(baseX, baseConnectors[1].Origin.Y - min1FittingLength, baseZ));

                    //Create an elbow fitting connection the 1st base connector with the trunk
                    ConnectWithElbowFittingOnYAxis(baseConnectors[0], connectors[0]);

                    if (baseConnectors[1].Origin.Y == baseConnectors[2].Origin.Y)
                    {
                        //The 2nd and 3rd connectors are on the same side of the trunk
                        if (Math.Sign(baseConnectors[1].Origin.X - baseX) * Math.Sign(baseConnectors[2].Origin.X - baseX) == 1)
                        {
                            return false;
                        }
                        //Create a tee fitting connecting the 2nd and 3rd base connectors to the trunk
                        ConnectWithTeeFittingOnYAxis(baseConnectors[1], baseConnectors[2], connectors[1], true);
                    }
                    else
                    {
                        connectors.AddRange(CreateDuct(new GXYZ(baseX, baseConnectors[1].Origin.Y + min1FittingLength, baseZ), new GXYZ(baseX, baseConnectors[2].Origin.Y - min1FittingLength, baseZ)));
                        //Create a tee fitting connecting the 2nd base connector to the trunk
                        ConnectWithTeeFittingOnYAxis(baseConnectors[1], connectors[1], connectors[2], false);
                        //Create an elbow fitting connection the 3rd base connector to the trunk
                        ConnectWithElbowFittingOnYAxis(baseConnectors[2], connectors[3]);
                    }
                }

                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Connect a base connector to a connector on the trunk with an elbow fitting
        /// </summary>
        /// <param name="baseConn">the upper connector of the vertical duct that derived from a terminal or the base equipment</param>
        /// <param name="conn">the connector of a duct on the trunk</param>
        private void ConnectWithElbowFittingOnYAxis(Connector baseConn, Connector conn)
        {
            double baseX = conn.Origin.X;
            double baseZ = conn.Origin.Z;
            List<Connector> connectors = new List<Connector>();

            //If the distance of the two connectors on the X axis is greater than 2, create a duct on the X axis and then connect it to the 2 connectors with elbow fittings
            if (Math.Abs(baseConn.Origin.X - baseX) > min1Duct2FittingsLength)
            {
                connectors.AddRange(CreateDuct(new GXYZ(baseConn.Origin.X - Math.Sign(baseConn.Origin.X - baseX), baseConn.Origin.Y, baseZ), new GXYZ(baseX + Math.Sign(baseConn.Origin.X - baseX), baseConn.Origin.Y, baseZ)));
                connectors[0].ConnectTo(baseConn);
                m_document.Create.NewElbowFitting(connectors[0], baseConn);
                connectors[1].ConnectTo(conn);
                m_document.Create.NewElbowFitting(connectors[1], conn);
            }
            //If the distance of the two connectors on the X axis is less than 2, connect them with an elbow fitting
            else
            {
                baseConn.ConnectTo(conn);
                m_document.Create.NewElbowFitting(baseConn, conn);
            }
        }

        /// <summary>
        /// Connect 3 connectors on the trunk with a tee fitting
        /// </summary>
        /// <param name="conn1">the first connector</param>
        /// <param name="conn2">the second connector</param>
        /// <param name="conn3">the third connector</param>
        /// <param name="flag">a flag to indicate whether there are 2 base connectors or 1 base connector</param>
        private void ConnectWithTeeFittingOnYAxis(Connector conn1, Connector conn2, Connector conn3, bool flag)
        {
            double baseX = conn3.Origin.X;
            double baseZ = conn3.Origin.Z;

            List<GXYZ> points = new List<GXYZ>();
            List<Duct> ducts = new List<Duct>();
            List<Connector> connectors = new List<Connector>();

            //Connect two base connectors to a connector on the trunk
            if (true == flag)
            {

                Connector baseConn1 = conn1;
                Connector baseConn2 = conn2;
                Connector conn = conn3;

                connectors.AddRange(CreateDuct(new GXYZ(baseConn1.Origin.X - Math.Sign(baseConn1.Origin.X - baseX), baseConn1.Origin.Y, baseZ), new GXYZ(baseX + Math.Sign(baseConn1.Origin.X - baseX), baseConn1.Origin.Y, baseZ)));
                connectors.AddRange(CreateDuct(new GXYZ(baseConn2.Origin.X - Math.Sign(baseConn2.Origin.X - baseX), baseConn2.Origin.Y, baseZ), new GXYZ(baseX + Math.Sign(baseConn2.Origin.X - baseX), baseConn2.Origin.Y, baseZ)));

                connectors[0].ConnectTo(baseConn1);
                connectors[2].ConnectTo(baseConn2);
                m_document.Create.NewElbowFitting(connectors[0], baseConn1);
                m_document.Create.NewElbowFitting(connectors[2], baseConn2);

                connectors[1].ConnectTo(connectors[3]);
                connectors[1].ConnectTo(conn);
                connectors[3].ConnectTo(conn);
                m_document.Create.NewTeeFitting(connectors[1], connectors[3], conn);
            }
            //Connect a base connector to two connectors on the trunk
            else
            {
                Connector baseConn = conn1;

                if (Math.Abs(baseConn.Origin.X - baseX) > min1Duct2FittingsLength)
                {
                    connectors.AddRange(CreateDuct(new GXYZ(baseConn.Origin.X - Math.Sign(baseConn.Origin.X - baseX), baseConn.Origin.Y, baseZ), new GXYZ(baseX + Math.Sign(baseConn.Origin.X - baseX), baseConn.Origin.Y, baseZ)));
                    baseConn.ConnectTo(connectors[0]);
                    m_document.Create.NewElbowFitting(connectors[0], baseConn);

                    connectors[1].ConnectTo(conn2);
                    connectors[1].ConnectTo(conn3);
                    conn2.ConnectTo(conn3);
                    m_document.Create.NewTeeFitting(conn2, conn3, connectors[1]);
                }
                else
                {
                    baseConn.ConnectTo(conn2);
                    baseConn.ConnectTo(conn3);
                    conn2.ConnectTo(conn3);
                    m_document.Create.NewTeeFitting(conn2, conn3, baseConn);
                }
            }
        }

        /// <summary>
        /// Sort the base connectors by their y values
        /// </summary>
        /// <param name="connectors">the connectors to be sorted</param>
        private void SortConnectorsByY(List<Connector> connectors)
        {
            for (int i = 0; i < connectors.Count; ++i)
            {
                double min = connectors[i].Origin.Y;
                int minIndex = i;
                for (int j = i; j < connectors.Count; ++j)
                {
                    if (connectors[j].Origin.Y < min)
                    {
                        min = connectors[j].Origin.Y;
                        minIndex = j;
                    }
                }
                Connector t = connectors[i];
                connectors[i] = connectors[minIndex];
                connectors[minIndex] = t;
            }
        }

        /// <summary>
        /// Create a duct with two points
        /// </summary>
        /// <param name="point1">the first point</param>
        /// <param name="point2">the second point</param>
        /// <returns></returns>
        private List<Connector> CreateDuct(GXYZ point1, GXYZ point2)
        {
            List<Connector> connectors = new List<Connector>();

            Duct duct = Duct.Create(m_document, systemTypeId, ductTypeId, lvl.Id, point1, point2);

            connectors.Add(ConnectorInfo.GetConnector(duct.Id, point1));
            connectors.Add(ConnectorInfo.GetConnector(duct.Id, point2));

            return connectors;
        }

        /// <summary>
        /// Create a mechanical system
        /// </summary>
        /// <param name="baseConnector">the base connector of the mechanical system</param>
        /// <param name="connectors">the connectors of the mechanical system</param>
        /// <param name="systemType">the system type of the mechanical system</param>
        /// <returns>the created mechanical system</returns>
        private MechanicalSystem CreateMechanicalSystem(ConnectorInfo baseConnector, ConnectorInfo[] connectors, DuctSystemType systemType)
        {
            ConnectorSet cset = null;
            if (connectors != null)
            {
                cset = new ConnectorSet();
                foreach (ConnectorInfo ci in connectors)
                {
                    cset.Insert(ci.Connector);
                }
            }
            MechanicalSystem mechanicalSystem = m_document.Create.NewMechanicalSystem(baseConnector == null ? null : baseConnector.Connector, cset, systemType);
            return mechanicalSystem;
        }

        /// <summary>
        /// information of a connector
        /// </summary>
        public class ConnectorInfo
        {
            /// <summary>
            /// The owner's element ID
            /// </summary>
            ElementId m_ownerId;

            /// <summary>
            /// The origin of the connector
            /// </summary>
            GXYZ m_origin;

            /// <summary>
            /// The Connector object
            /// </summary>
            Connector m_connector;

            /// <summary>
            /// The connector this object represents
            /// </summary>
            public Connector Connector
            {
                get { return m_connector; }
                set { m_connector = value; }
            }

            /// <summary>
            /// The owner ID of the connector
            /// </summary>
            public ElementId OwnerId
            {
                get { return m_ownerId; }
                set { m_ownerId = value; }
            }

            /// <summary>
            /// The origin of the connector
            /// </summary>
            public GXYZ Origin
            {
                get { return m_origin; }
                set { m_origin = value; }
            }

            /// <summary>
            /// The constructor that finds the connector with the owner ID and origin
            /// </summary>
            /// <param name="ownerId">the ownerID of the connector</param>
            /// <param name="origin">the origin of the connector</param>
            public ConnectorInfo(ElementId ownerId, GXYZ origin)
            {
                m_ownerId = ownerId;
                m_origin = origin;
                m_connector = ConnectorInfo.GetConnector(m_ownerId, origin);
            }

            /// <summary>
            /// The constructor that finds the connector with the owner ID and the values of the origin
            /// </summary>
            /// <param name="ownerId">the ownerID of the connector</param>
            /// <param name="x">the X value of the connector</param>
            /// <param name="y">the Y value of the connector</param>
            /// <param name="z">the Z value of the connector</param>
            public ConnectorInfo(ElementId ownerId, double x, double y, double z)
                : this(ownerId, new GXYZ(x, y, z))
            {
            }

            /// <summary>
            /// Get the connector of the owner at the specific origin
            /// </summary>
            /// <param name="ownerId">the owner ID of the connector</param>
            /// <param name="connectorOrigin">the origin of the connector</param>
            /// <returns>if found, return the connector, or else return null</returns>
            public static Connector GetConnector(ElementId ownerId, GXYZ connectorOrigin)
            {
                ConnectorSet connectors = GetConnectors(ownerId);
                foreach (Connector conn in connectors)
                {
                    if (conn.ConnectorType == ConnectorType.Logical)
                        continue;
                    if (conn.Origin.IsAlmostEqualTo(connectorOrigin))
                        return conn;
                }
                return null;
            }

            /// <summary>
            /// Get all the connectors of an element with a specific ID
            /// </summary>
            /// <param name="ownerId">the owner ID of the connector</param>
            /// <returns>the connector set which includes all the connectors found</returns>
            public static ConnectorSet GetConnectors(ElementId ownerId)
            {
                Element element = m_document.GetElement(ownerId);
                return GetConnectors(element);
            }

            /// <summary>
            /// Get all the connectors of a specific element
            /// </summary>
            /// <param name="element">the owner of the connector</param>
            /// <returns>if found, return all the connectors found, or else return null</returns>
            public static ConnectorSet GetConnectors(Autodesk.Revit.DB.Element element)
            {
                if (element == null) return null;
                FamilyInstance fi = element as FamilyInstance;
                if (fi != null && fi.MEPModel != null)
                {
                    return fi.MEPModel.ConnectorManager.Connectors;
                }
                MEPSystem system = element as MEPSystem;
                if (system != null)
                {
                    return system.ConnectorManager.Connectors;
                }

                MEPCurve duct = element as MEPCurve;
                if (duct != null)
                {
                    return duct.ConnectorManager.Connectors;
                }
                return null;
            }

            /// <summary>
            /// Find the two connectors of the specific ConnectorManager at the two locations
            /// </summary>
            /// <param name="connMgr">The ConnectorManager of the connectors to be found</param>
            /// <param name="ptn1">the location of the first connector</param>
            /// <param name="ptn2">the location of the second connector</param>
            /// <returns>The two connectors found</returns>
            public static Connector[] FindConnectors(ConnectorManager connMgr, GXYZ pnt1, GXYZ pnt2)
            {
                Connector[] result = new Connector[2];
                ConnectorSet conns = connMgr.Connectors;
                foreach (Connector conn in conns)
                {
                    if (conn.Origin.IsAlmostEqualTo(pnt1))
                    {
                        result[0] = conn;
                    }
                    else if (conn.Origin.IsAlmostEqualTo(pnt2))
                    {
                        result[1] = conn;
                    }
                }
                return result;
            }

        };
    }

    public class LogUtility
    {
        /// <summary>
        /// Invalid string.
        /// </summary>
        public const string InvalidString = "[!]";

        /// <summary>
        /// Write the information of an element to the log file
        /// </summary>
        /// <param name="element">the element whose information is to be written</param>
        public static void WriteElement(Element element)
        {
            WriteElement(element, true);
        }
        /// <summary>
        /// Write the information of an element to the log file
        /// </summary>
        /// <param name="element">the element whose information is to be written</param>
        /// <param name="writeId">whether the id will be outputted</param>
        public static void WriteElement(Element element, bool writeId)
        {
            if (element == null)
            {
                Trace.WriteLine("null"); return;
            }
            ElementId elementId = element.Id;
            ElementId familyId = element.get_Parameter(BuiltInParameter.ELEM_FAMILY_PARAM).AsElementId();
            string familyName = LogUtility.InvalidString;
            Element objectType = GetElement<Element>(element.Document, familyId);
            string elementName = LogUtility.InvalidString;
            try { elementName = element.Name; }
            catch { }
            if (objectType != null)
            {
                Parameter familyNameParameter = objectType.get_Parameter(BuiltInParameter.ALL_MODEL_FAMILY_NAME);
                if (familyNameParameter != null)
                    familyName = familyNameParameter.AsString();
            }
            BuiltInCategory category = element.Category.BuiltInCategory;

            Trace.WriteLine("Type: " + element.GetType().FullName);
            Trace.WriteLine("Name: " + familyName + ":" + elementName);
            if (writeId) Trace.WriteLine("Id: " + elementId.ToString());
            Trace.WriteLine("Category: " + category);
            Trace.WriteLine("FamilyId: " + familyId.ToString());
        }

        /// <summary>
        /// Write the information of a mechanical system to the log file
        /// </summary>
        /// <param name="system">the mechanical system whose information is to be written</param>
        public static void WriteMechanicalSystem(MechanicalSystem system)
        {
            string flow = InvalidString;
            try { flow = system.GetFlow().ToString(); }
            catch (Exception) { }

            Trace.WriteLine("Flow: " + flow);
            Trace.WriteLine("IsWellConnected: " + system.IsWellConnected);
            Trace.WriteLine("SystemType: " + system.SystemType);
            Trace.WriteLine("+DuctNetwork");
            Trace.Indent();
            foreach (Element element in system.DuctNetwork)
            {
                LogUtility.WriteElement(element, false);
                Trace.WriteLine("");
            }
            Trace.Unindent();
            WriteMEPSystem(system);
        }

        /// <summary>
        /// Get element by its id and cast it to the specified type
        /// </summary>
        /// <param name="document">the owner document of the element</param>
        /// <param name="eid">the id of the element</param>
        /// <returns>the element of the specified type</returns>
        public static T GetElement<T>(Document document, ElementId eid) where T : Autodesk.Revit.DB.Element
        {
            return document.GetElement(eid) as T;
        }

        /// <summary>
        /// Write the information of a MEPSystem to the log file.
        /// </summary>
        /// <param name="system">the MEP system whose information is to be written</param>
        public static void WriteMEPSystem(MEPSystem system)
        {
            WriteElement(system.BaseEquipment);
            Trace.Unindent();
            Trace.WriteLine("+BaseEquipmentConnector");
            Trace.Indent();
            WriteConnector(system.BaseEquipmentConnector);
            Trace.Unindent();
            Trace.WriteLine("+Elements");
            Trace.Indent();
            foreach (Element element in system.Elements)
            {
                WriteElement(element);
                Trace.WriteLine("");
            }
            Trace.Unindent();
            Trace.WriteLine("+ConnectorManager");
            Trace.Indent();
            WriteConnectorManager(system.ConnectorManager);
            Trace.Unindent();
        }

        /// <summary>
        /// Write the information of a connector to the log file
        /// </summary>
        /// <param name="connector">the connector whose information is to be written</param>
        public static void WriteConnector(Connector connector)
        {
            if (connector == null)
            {
                Trace.WriteLine("null"); return;
            }
            object connType = InvalidString;
            object connDirection = InvalidString;
            object connShape = InvalidString;
            try { connShape = connector.Shape; }
            catch { }
            object connSize = InvalidString;
            try { connSize = GetShapeInfo(connector); }
            catch { }
            object connLocation = GetLocation(connector);
            object connAType = connector.ConnectorType;
            object connIsConnected = InvalidString;
            switch (connector.Domain)
            {
                case Domain.DomainElectrical:
                    connType = connector.ElectricalSystemType;
                    break;
                case Domain.DomainHvac:
                    connType = connector.DuctSystemType;
                    connDirection = connector.Direction;
                    connIsConnected = connector.IsConnected;
                    break;
                case Domain.DomainPiping:
                    connType = connector.PipeSystemType;
                    connDirection = connector.Direction;
                    connIsConnected = connector.IsConnected;
                    break;
                case Domain.DomainUndefined:
                default:
                    connType = Domain.DomainUndefined;
                    break;
            }
            Trace.WriteLine("Type: " + connAType);
            Trace.WriteLine("SystemType: " + connType);
            Trace.WriteLine("Direction: " + connDirection);
            Trace.WriteLine("Shape: " + connShape);
            Trace.WriteLine("Size: " + connSize);
            Trace.WriteLine("Location: " + connLocation);
            Trace.WriteLine("IsConnected: " + connIsConnected);
        }

        /// <summary>
        /// Write the information of a ConnectorManager to the log file
        /// </summary>
        /// <param name="connectorManager">the ConnectorManager whose information is to be written</param>
        public static void WriteConnectorManager(ConnectorManager connectorManager)
        {
            Trace.WriteLine("+Connectors");
            Trace.Indent();
            WriteConnectorSet2(connectorManager.Connectors);
            Trace.Unindent();
            Trace.WriteLine("+UnusedConnectors");
            Trace.Indent();
            WriteConnectorSet2(connectorManager.UnusedConnectors);
            Trace.Unindent();
        }

        /// <summary>
        /// Get the information string of a connector
        /// </summary>
        /// <param name="connector">the connector to be read</param>
        /// <returns>the information string of the connector</returns>
        public static string GetConnectorId(Connector connector)
        {
            if (connector == null)
            {
                return "null";
            }
            ElementId ownerId = connector.Owner.Id;
            string systemId = InvalidString;
            try { systemId = connector.MEPSystem.Id.ToString(); }
            catch { }
            object connType = InvalidString;
            object connDirection = InvalidString;
            object connShape = InvalidString;
            try { connShape = connector.Shape; }
            catch { }
            object connSize = InvalidString;
            try { connSize = GetShapeInfo(connector); }
            catch { }
            object connLocation = GetLocation(connector);
            object connAType = connector.ConnectorType;
            object connIsConnected = InvalidString;
            switch (connector.Domain)
            {
                case Domain.DomainElectrical:
                    connType = connector.ElectricalSystemType;
                    break;
                case Domain.DomainHvac:
                    connType = connector.DuctSystemType;
                    connDirection = connector.Direction;
                    connIsConnected = connector.IsConnected;
                    break;
                case Domain.DomainPiping:
                    connType = connector.PipeSystemType;
                    connDirection = connector.Direction;
                    connIsConnected = connector.IsConnected;
                    break;
                case Domain.DomainUndefined:
                default:
                    connType = Domain.DomainUndefined;
                    break;
            }
            return string.Format("[{0}]\t[{1}]\t[{2}]\t[{3}]\t[{4}]\t[{5}]\t[{6}]\t[{7}]\t[{8}]\t",
                ownerId.ToString(), connType, connDirection, connShape, connSize, connLocation,
                connAType, connIsConnected, systemId);
        }

        /// <summary>
        /// Get the shape information string of a connector
        /// </summary>
        /// <param name="conn">the element to be read</param>
        /// <returns>the shape information string of the connector</returns>
        private static string GetShapeInfo(Connector conn)
        {
            switch (conn.Shape)
            {
                case ConnectorProfileType.Invalid:
                    break;
                case ConnectorProfileType.Oval:
                    break;
                case ConnectorProfileType.Rectangular:
                    return string.Format("{0}\" x {1}\"", conn.Width, conn.Height);
                case ConnectorProfileType.Round:
                    return string.Format("{0}\"", conn.Radius);
                default:
                    break;
            }
            return InvalidString;
        }

        /// <summary>
        /// Get the location string of a connector
        /// </summary>
        /// <param name="conn">the connector to be read</param>
        /// <returns>the location information string of the connector</returns>
        private static object GetLocation(Connector conn)
        {
            if (conn.ConnectorType == ConnectorType.Logical)
            {
                return InvalidString;
            }
            Autodesk.Revit.DB.XYZ origin = conn.Origin;
            return string.Format("{0},{1},{2}", origin.X, origin.Y, origin.Z);
        }

        /// <summary>
        /// Write the information of a ConnectorSet to the log file.
        /// </summary>
        /// <param name="connectorSet">the ConnectorSet whose information is to be written</param>
        private static void WriteConnectorSet2(ConnectorSet connectorSet)
        {
            SortedDictionary<string, List<Connector>> connectors = new SortedDictionary<string, List<Connector>>();
            foreach (Connector conn in connectorSet)
            {
                string connId = GetConnectorId(conn);
                if (conn.ConnectorType == ConnectorType.Logical)
                {
                    foreach (Connector logLinkConn in conn.AllRefs)
                    {
                        connId += GetConnectorId(logLinkConn);
                    }
                }
                if (!connectors.ContainsKey(connId))
                {
                    connectors.Add(connId, new List<Connector>());
                }

                connectors[connId].Add(conn);
            }
            foreach (string key in connectors.Keys)
            {
                foreach (Connector conn in connectors[key])
                {
                    WriteConnector(conn);
                    Trace.WriteLine("+AllRefs");
                    Trace.Indent();
                    WriteConnectorSet(conn.AllRefs);
                    Trace.Unindent();
                    Trace.WriteLine("");
                }
            }
        }

        /// <summary>
        /// Write the information of a ConnectorSet to the log file.
        /// </summary>
        /// <param name="connectorSet">the mechanical system whose information is to be written</param>
        private static void WriteConnectorSet(ConnectorSet connectorSet)
        {
            SortedDictionary<string, List<Connector>> connectors = new SortedDictionary<string, List<Connector>>();
            foreach (Connector conn in connectorSet)
            {
                string connId = GetConnectorId(conn);
                if (conn.ConnectorType == ConnectorType.Logical)
                {
                    foreach (Connector logLinkConn in conn.AllRefs)
                    {
                        connId += GetConnectorId(logLinkConn);
                    }
                }
                if (!connectors.ContainsKey(connId))
                {
                    connectors.Add(connId, new List<Connector>());
                }

                connectors[connId].Add(conn);
            }

            foreach (string key in connectors.Keys)
            {
                foreach (Connector conn in connectors[key])
                {
                    WriteConnector(conn);
                    Trace.WriteLine("");
                }
            }
        }
    }
}

=== CODE_BLOCK_0011 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
                                               ref string message,
                                               ElementSet elements)
        {
            try
            {
                //Create a transaction
                Transaction documentTransaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "Document");
                documentTransaction.Start();
                // Create a new instance of class RoomsData
                RoomsData data = new RoomsData(commandData);

                System.Windows.Forms.DialogResult result;

                // Create a form to display the information of rooms
                using (AutoTagRoomsForm roomsTagForm = new AutoTagRoomsForm(data))
                {
                    result = roomsTagForm.ShowDialog();
                }

                if (result == System.Windows.Forms.DialogResult.OK)
                {
                    documentTransaction.Commit();
                    return Autodesk.Revit.UI.Result.Succeeded;
                }
                else
                {
                    documentTransaction.RollBack();
                    return Autodesk.Revit.UI.Result.Cancelled;
                }
            }
            catch (Exception ex)
            {
                // If there are something wrong, give error information and return failed
                message = ex.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
    }
}

=== CODE_BLOCK_0013 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "External Tool");
            try
            {
                transaction.Start();
            
                Resolver resolver = new Resolver(commandData);
                resolver.Resolve();                
            }
            catch (System.Exception e)
            {
                transaction.RollBack();
                message += e.ToString();
                return Autodesk.Revit.UI.Result.Failed;
            }
            finally
            {
                transaction.Commit();
            }
            return Autodesk.Revit.UI.Result.Succeeded;
        }

        #endregion        
    }
}

=== CODE_BLOCK_0015 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData revit, 
                                               ref string message, 
                                               ElementSet elements)
        {
            // Set currently executable application to private variable m_revit
            m_revit = revit.Application;           
            m_elements = elements;

            Transaction tran = new Transaction(m_revit.ActiveUIDocument.Document, "BeamAndSlabNewParameter");
            tran.Start();

            // Show UI
            using (BeamAndSlabParametersForm displayForm = new BeamAndSlabParametersForm(this))
            {
                displayForm.ShowDialog();
            }

            tran.Commit();
            return Autodesk.Revit.UI.Result.Succeeded;
        }

        /// <summary>
        /// Add a new parameter, "Unique ID", to the beams and slabs
        /// The following process should be followed: 
        /// Open the shared parameters file, via the Document.OpenSharedParameterFile method. 
        /// Access an existing group or create a new group, via the DefinitionFile.Groups property. 
        /// Access an existing or create a new external parameter definition, 
        /// via the DefinitionGroup.Definitions property. 
        /// Create a new Binding with the categories to which the parameter will be bound
        /// using an InstanceBinding or a TypeBinding.
        /// Finally add the binding and definition to the document
        /// using the Document.ParameterBindings object.
        /// </summary>
        /// <returns>bool type, a value that signifies  if  add parameter was successful</returns>
        public bool SetNewParameterToBeamsAndSlabs ()
        {
            //Open the shared parameters file 
            // via the private method AccessOrCreateExternalSharedParameterFile
            DefinitionFile informationFile = AccessOrCreateExternalSharedParameterFile();

            if (null == informationFile)
            {
                return false;
            }
    
            // Access an existing or create a new group in the shared parameters file
            DefinitionGroups informationCollections = informationFile.Groups;
            DefinitionGroup  informationCollection  = null;

            informationCollection = informationCollections.get_Item("MyParameters");

            if (null == informationCollection)
            {
                informationCollections.Create("MyParameters");
                informationCollection = informationCollections.get_Item("MyParameters");
            }

            // Access an existing or create a new external parameter definition 
            // belongs to a specific group
            Definition information = informationCollection.Definitions.get_Item("Unique ID");
                
            if (null == information)
            {
               ExternalDefinitionCreationOptions ExternalDefinitionCreationOptions = new ExternalDefinitionCreationOptions("Unique ID", Autodesk.Revit.DB.SpecTypeId.String.Text);
               informationCollection.Definitions.Create(ExternalDefinitionCreationOptions);
                information = informationCollection.Definitions.get_Item("Unique ID");
            }

            // Create a new Binding object with the categories to which the parameter will be bound
            CategorySet categories              = m_revit.Application.Create.NewCategorySet();
            Category structuralFramingCategorie = null;
            Category floorsClassification       = null;

            // use category in instead of the string name to get category 
            structuralFramingCategorie = m_revit.ActiveUIDocument.Document.Settings.Categories.get_Item(BuiltInCategory.OST_StructuralFraming);
            floorsClassification = m_revit.ActiveUIDocument.Document.Settings.Categories.get_Item(BuiltInCategory.OST_Floors);
            categories.Insert(structuralFramingCategorie);
            categories.Insert(floorsClassification);

            InstanceBinding caseTying = m_revit.Application.Create.NewInstanceBinding(categories);
            
            // Add the binding and definition to the document
            bool boundResult = m_revit.ActiveUIDocument.Document.ParameterBindings.Insert(information, caseTying);        

            return boundResult;
        }

        /// <summary>
        /// Set value(uuid) to Unique ID parameter
        /// </summary>
        public void SetValueToUniqueIDParameter()
        {
            ElementClassFilter beamClassFilter = new ElementClassFilter(typeof(FamilyInstance));
            ElementClassFilter slabClassFilter = new ElementClassFilter(typeof(Floor));
            ElementCategoryFilter beamTypeFilter = new ElementCategoryFilter(BuiltInCategory.OST_StructuralFraming);
            ElementCategoryFilter slabTypeFilter = new ElementCategoryFilter(BuiltInCategory.OST_Floors);

            LogicalAndFilter beamFilter = new LogicalAndFilter(beamClassFilter,beamTypeFilter);
            LogicalAndFilter slabFilter = new LogicalAndFilter(slabClassFilter,slabTypeFilter);

            LogicalOrFilter beamandslabFilter = new LogicalOrFilter(beamFilter, slabFilter);
            IEnumerable<Element> elems = from elem in
                                             new FilteredElementCollector(m_revit.ActiveUIDocument.Document).WherePasses(beamandslabFilter).ToElements()

            select elem;

            foreach (Element elem in elems)
            {
                // Find the parameter which is named "Unique ID" 
                // belongs to a specifically beam or slab
                ParameterSet attributes = elem.Parameters;
                IEnumerator iter = attributes.GetEnumerator();

                iter.Reset();
                while (iter.MoveNext())
                {
                    Parameter attribute = iter.Current as Autodesk.Revit.DB.Parameter;
                    Definition information = attribute.Definition;

                    if ((null != information)&&("Unique ID" == information.Name) && (null == attribute.AsString()) )
                    {
                        // The shared parameter "Unique ID" then be set to a UUID
                        Guid uuid = Guid.NewGuid();
                        attribute.Set(uuid.ToString());
                    }
                }
            }

        }

        /// <summary>
        /// Display the value of Unique ID parameter in a list box
        /// </summary>
        /// <returns></returns>
        public System.Collections.ArrayList SendValueToListBox()
        {
           ElementSet elements = new ElementSet();
            foreach (ElementId elementId in m_revit.ActiveUIDocument.Selection.GetElementIds())
            {
               elements.Insert(m_revit.ActiveUIDocument.Document.GetElement(elementId));
            }

            // all the elements of current document
            IEnumerator i = elements.GetEnumerator();  

            ArrayList parameterValueArrangeBox = new ArrayList();

            // if the selections include beams and slabs, find out their Unique ID's value for display
            i.Reset();
            bool moreElements = i.MoveNext();

            while (moreElements)
            {
                // Get beams and slabs from selections
                Element component = i.Current as Autodesk.Revit.DB.Element;

                if (null == component)
                {
                    moreElements = i.MoveNext();
                    continue;
                }

                if (null == component.Category)
                {
                    moreElements = i.MoveNext();
                    continue;
                }

                if (("Structural Framing" != component.Category.Name) &&
                    ("Floors" != component.Category.Name))
                {
                    moreElements = i.MoveNext();
                    continue;
                }

                // Get "Unique ID" parameter and display its value in a list box 
                ParameterSet attributes = component.Parameters;

                foreach(object o in attributes) 
                {
                    Parameter attribute = o as Parameter;

                    if ("Unique ID" == attribute.Definition.Name)
                    {    
                        if (null == attribute.AsString())
                        {
                            break;
                        }

                        parameterValueArrangeBox.Add(attribute.AsString());
                        break;
                    }            
                }
                moreElements = i.MoveNext();
            }    
            return parameterValueArrangeBox;
        }

        /// <summary>
        /// found the element which using the GUID 
        /// that was assigned to the shared parameter in the shared parameters file.
        /// </summary>
        /// <param name="UniqueIdValue"></param>
        public void FindElement(string UniqueIdValue)
        {
           ElementSet seleElements = new ElementSet();
            foreach (ElementId elementId in m_revit.ActiveUIDocument.Selection.GetElementIds())
            {
               seleElements.Insert(m_revit.ActiveUIDocument.Document.GetElement(elementId));
            }

            // all the elements of current document
            IEnumerator i = seleElements.GetEnumerator();


            // if the selections include beams and slabs, 
            // find out the element using the select value for display
            i.Reset();
            bool moreElements = i.MoveNext();

            while (moreElements)
            {
                // Get beams and slabs from selections
                Element component = i.Current as Autodesk.Revit.DB.Element;

                if (null == component)
                {
                    moreElements = i.MoveNext();
                    continue;
                }

                if (null == component.Category)
                {
                    moreElements = i.MoveNext();
                    continue;
                }

                if (("Structural Framing" != component.Category.Name) &&
                    ("Floors" != component.Category.Name))
                {
                    moreElements = i.MoveNext();
                    continue;
                }

                // Get "Unique ID" parameter
                ParameterSet attributes = component.Parameters;

                foreach (object o in attributes)
                {
                    Parameter attribute = o as Parameter;

                    if ("Unique ID" == attribute.Definition.Name)
                    {
                        if (null == attribute.AsString())
                        {
                            break;
                        }

                        // compare if the parameter's value is the same as the selected value.
                        // Clear the SelElementSet and add the found element into it. 
                        // So this element will highlight in Revit UI
                        if (UniqueIdValue == attribute.AsString())
                        {
                            seleElements.Clear();
                            seleElements.Insert(component);
                            return;
                        }

                        break;
                    }
                }

                moreElements = i.MoveNext();
            }

        }

        /// <summary>
        /// Access an existing or create a new shared parameters file
        /// </summary>
        /// <returns>a shared parameters file </returns>
        private DefinitionFile  AccessOrCreateExternalSharedParameterFile()
        {    
            // The Path of Revit.exe
            string currentExecutablePath = System.Windows.Forms.Application.ExecutablePath;
 
            // The path of ourselves shared parameters file
            string sharedParameterFile = Path.GetDirectoryName(currentExecutablePath);

            sharedParameterFile = sharedParameterFile + "\\MySharedParameters.txt";
            
            //Method's return
            DefinitionFile informationFile = null; 

            // Check if the file is exit
            System.IO.FileInfo documentMessage = new FileInfo(sharedParameterFile);
            bool fileExist = documentMessage.Exists;

            // Create file for external shared parameter since it does not exist
            if (!fileExist)
            {
                FileStream fileFlow = File.Create(sharedParameterFile);
                fileFlow.Close();    
            }
            
            // Set  ourselves file to  the externalSharedParameterFile 
            m_revit.Application.SharedParametersFilename = sharedParameterFile;
            informationFile = m_revit.Application.OpenSharedParameterFile();

            return informationFile;
        }
    }
}

=== CODE_BLOCK_0017 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                               ref string message,
                                               ElementSet elements)
        {
            try
            {
                //Retrieves the currently active project.
                UIDocument doc = commandData.Application.ActiveUIDocument;

                // must select a element first
                ElementSet elementSet = new ElementSet();
                foreach (ElementId elementId in doc.Selection.GetElementIds())
                {
                   elementSet.Insert(doc.Document.GetElement(elementId));
                }
                if (1 != elementSet.Size)
                {
                    message = "Please select one structural element which is listed as follows: \r\n" +
                              "Columns/braces/Beams/Walls/Wall Foundations/Slabs/Foundation Slabs";
                    return Autodesk.Revit.UI.Result.Cancelled;
                }


                Transaction tran = new Transaction(doc.Document, "BoundaryConditions");
                tran.Start();

                // deal with the selected element
                foreach (Element element in elementSet)
                {
                    // the selected element must be a structural element
                    if (!IsExpectedElement(element))
                    {
                        message = "Please select one structural element which is listed as follows: \r\n" +
                                  "Columns/braces/Beams/Walls/Wall Foundations/ \r\n" +
                                  "Slabs/Foundation Slabs";
                        return Autodesk.Revit.UI.Result.Cancelled;
                    }

                    // prepare the relative data
                    BoundaryConditionsData dataBuffer = new BoundaryConditionsData(element);

                    // show UI
                    using (BoundaryConditionsForm displayForm = new BoundaryConditionsForm(dataBuffer))
                    {
                        DialogResult result = displayForm.ShowDialog();
                        if (DialogResult.OK == result)
                        {
                            tran.Commit();
                            return Autodesk.Revit.UI.Result.Succeeded;
                        }
                        else if (DialogResult.Retry == result)
                        {
                            message = "failed to create BoundaryConditions.";
                            tran.RollBack();
                            return Autodesk.Revit.UI.Result.Failed;
                        }
                    }    
                }

                tran.RollBack();
                // user cancel the operation
                return Autodesk.Revit.UI.Result.Cancelled;                
            }
            catch (Exception e)
            {
                message = e.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }

      /// <summary>
      /// the selected element must be a structural Column/brace/Beam/Wall/Wall Foundation/Slab/Foundation Slab.
      /// </summary>
      /// <returns></returns>
      private bool IsExpectedElement(Element element)
      {
         // judge the element's type. If it is any type of FamilyInstance, Wall, Floor or 
         // WallFoundation, then get judge if it has a AnalyticalModel.
         AnalyticalToPhysicalAssociationManager assocManager = AnalyticalToPhysicalAssociationManager.GetAnalyticalToPhysicalAssociationManager(element.Document);
         AnalyticalElement elemAnalytical = null;
         if (assocManager != null)
         {
            ElementId associatedElementId = assocManager.GetAssociatedElementId(element.Id);
            if (associatedElementId != ElementId.InvalidElementId)
            {
               Element associatedElement = element.Document.GetElement(associatedElementId);
               if (associatedElement != null && associatedElement is AnalyticalElement)
               {
                  elemAnalytical = associatedElement as AnalyticalElement;
               }
            }
         }
         if (null == elemAnalytical)
         {
            return false;
         }
         FamilyInstance familyInstance = element as FamilyInstance;
         if ((null != familyInstance) && (StructuralType.Footing == familyInstance.StructuralType))
         {
            return false; // if selected a isolated foundation not create BC
         }

         if (element is FamilyInstance || element is Wall || element is Floor || element is WallFoundation)
         {
            return true;
         }

         return false;
      }
   }
}

=== CODE_BLOCK_0019 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData revit, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            m_revit = revit.Application;
            Transaction tran = new Transaction(m_revit.ActiveUIDocument.Document, "CreateBeamsColumnsBraces");
            tran.Start();

            try
            {
                //if initialize failed return Result.Failed
                bool initializeOK = Initialize();
                if (!initializeOK)
                {
                    tran.RollBack();
                    return Autodesk.Revit.UI.Result.Failed;
                }

                using (CreateBeamsColumnsBracesForm displayForm = new CreateBeamsColumnsBracesForm(this))
                {
                    if (displayForm.ShowDialog() != DialogResult.OK)
                    {
                        tran.RollBack();
                        return Autodesk.Revit.UI.Result.Cancelled;
                    }
                }

                tran.Commit();
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception ex)
            {
                message = ex.Message;
                tran.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }
        }

        /// <summary>
        /// check the number of floors is less than the number of levels
        /// create beams, columns and braces according to selected types
        /// </summary>
        /// <param name="columnObject">type of column</param>
        /// <param name="beamObject">type of beam</param>
        /// <param name="braceObject">type of brace</param>
        /// <param name="floorNumber">number of floor</param>
        /// <returns>number of floors is less than the number of levels and create successfully then return true</returns>
        public bool AddInstance(object columnObject, object beamObject, object braceObject, int floorNumber)
        {
            //whether floor number less than levels number
            if (floorNumber >= levels.Count)
            {
                TaskDialog.Show("Revit", "The number of levels must be added.");
                return false;
            }

            FamilySymbol columnSymbol = columnObject as FamilySymbol;
            FamilySymbol beamSymbol = beamObject as FamilySymbol;
            FamilySymbol braceSymbol = braceObject as FamilySymbol;

            //any symbol is null then the command failed
            if (null == columnSymbol || null == beamSymbol || null == braceSymbol)
            {
                return false;
            }

            try
            {
                for (int k = 0; k < floorNumber; k++)    //iterate levels from lower one to higher
                {
                    Level baseLevel = levels.GetByIndex(k) as Level;
                    Level topLevel = levels.GetByIndex(k + 1) as Level;

                    int matrixXSize = m_matrixUV.GetLength(0);    //length of matrix's x range
                    int matrixYSize = m_matrixUV.GetLength(1);    //length of matrix's y range

                    //iterate coordinate both in x direction and y direction and create beams and braces
                    for (int j = 0; j < matrixYSize; j++)
                    {
                        for (int i = 0; i < matrixXSize; i++)
                        {
                            //create beams and braces in x direction
                            if (i != (matrixXSize - 1))
                            {
                                PlaceBrace(m_matrixUV[i, j], m_matrixUV[i + 1, j], baseLevel, topLevel, braceSymbol, true);
                            }
                            //create beams and braces in y direction
                            if (j != (matrixYSize - 1))
                            {
                                PlaceBrace(m_matrixUV[i, j], m_matrixUV[i, j + 1], baseLevel, topLevel, braceSymbol, false);
                            }
                        }
                    }
                    for (int j = 0; j < matrixYSize; j++)
                    {
                        for (int i = 0; i < matrixXSize; i++)
                        {
                            //create beams and braces in x direction
                            if (i != (matrixXSize - 1))
                            {
                                PlaceBeam(m_matrixUV[i, j], m_matrixUV[i + 1, j], baseLevel, topLevel, beamSymbol);
                            }
                            //create beams and braces in y direction
                            if (j != (matrixYSize - 1))
                            {
                                PlaceBeam(m_matrixUV[i, j], m_matrixUV[i, j + 1], baseLevel, topLevel, beamSymbol);
                            }
                        }
                    }
                    //place column of this level
                    foreach (Autodesk.Revit.DB.UV point2D in m_matrixUV)
                    {
                        PlaceColumn(point2D, columnSymbol, baseLevel, topLevel);
                    }
                }
            }
            catch
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// generate 2D coordinates of matrix according to parameters
        /// </summary>
        /// <param name="xNumber">Number of Columns in the X direction</param>
        /// <param name="yNumber">Number of Columns in the Y direction</param>
        /// <param name="distance">Distance between columns</param>
        public void CreateMatrix(int xNumber, int yNumber, double distance)
        {
            m_matrixUV = new Autodesk.Revit.DB.UV[xNumber, yNumber];

            for (int i = 0; i < xNumber; i++)
            {
                for (int j = 0; j < yNumber; j++)
                {
                    m_matrixUV[i, j] = new Autodesk.Revit.DB.UV(i * distance, j * distance);
                }
            }
        }

        /// <summary>
        /// iterate all the symbols of levels, columns, beams and braces
        /// </summary>
        /// <returns>A value that signifies if the initialization was successful for true or failed for false</returns>
        private bool Initialize()
        {
            try
            {

                FilteredElementIterator i = new FilteredElementCollector(m_revit.ActiveUIDocument.Document).OfClass(typeof(Level)).GetElementIterator();
                i.Reset();
                while (i.MoveNext())
                {
                    //add level to list
                    Level level = i.Current as Level;
                    if (null != level)
                    {
                        levels.Add(level.Elevation, level);

                    }
                }

                i = new FilteredElementCollector(m_revit.ActiveUIDocument.Document).OfClass(typeof(Family)).GetElementIterator();
                while (i.MoveNext())
                {
                    Family f = i.Current as Family;
                    if (f != null)
                    {
                        foreach (ElementId elementId in f.GetFamilySymbolIds())
                        {
                           object symbol = m_revit.ActiveUIDocument.Document.GetElement(elementId);
                            FamilySymbol familyType = symbol as FamilySymbol;
                            if (null == familyType)
                            {
                                continue;
                            }
                            if (null == familyType.Category)
                            {
                                continue;
                            }

                            //add symbols of beams and braces to lists 
                            string categoryName = familyType.Category.Name;
                            if ("Structural Framing" == categoryName)
                            {
                                m_beamMaps.Add(new SymbolMap(familyType));
                                m_braceMaps.Add(new SymbolMap(familyType));
                            }
                            else if ("Structural Columns" == categoryName)
                            {
                                m_columnMaps.Add(new SymbolMap(familyType));
                            }
                        }
                    }
                }




            }
            catch
            {
                return false;
            }
            return true;
        }

        /// <summary>
        /// create column of certain type in certain position
        /// </summary>
        /// <param name="point2D">2D coordinate of the column</param>
        /// <param name="columnType">type of column</param>
        /// <param name="baseLevel">the base level of the column</param>
        /// <param name="topLevel">the top level of the column</param>
        private void PlaceColumn(Autodesk.Revit.DB.UV point2D, FamilySymbol columnType, Level baseLevel, Level topLevel)
        {
            //create column of certain type in certain level and start point 
            Autodesk.Revit.DB.XYZ point = new Autodesk.Revit.DB.XYZ(point2D.U, point2D.V, 0);
            STRUCTURALTYPE structuralType;
            structuralType = Autodesk.Revit.DB.Structure.StructuralType.Column;
            if (!columnType.IsActive)
               columnType.Activate();
            FamilyInstance column = m_revit.ActiveUIDocument.Document.Create.NewFamilyInstance(point, columnType, topLevel, structuralType);

            //set base level & top level of the column
            if (null != column)
            {
                Parameter baseLevelParameter = column.get_Parameter(Autodesk.Revit.DB.BuiltInParameter.FAMILY_BASE_LEVEL_PARAM);
                Parameter topLevelParameter = column.get_Parameter(Autodesk.Revit.DB.BuiltInParameter.FAMILY_TOP_LEVEL_PARAM);
                Parameter topOffsetParameter = column.get_Parameter(BuiltInParameter.FAMILY_TOP_LEVEL_OFFSET_PARAM);
                Parameter baseOffsetParameter = column.get_Parameter(BuiltInParameter.FAMILY_BASE_LEVEL_OFFSET_PARAM);

                if (null != baseLevelParameter)
                {
                    Autodesk.Revit.DB.ElementId baseLevelId;
                    baseLevelId = baseLevel.Id;
                    baseLevelParameter.Set(baseLevelId);
                }

                if (null != topLevelParameter)
                {
                    Autodesk.Revit.DB.ElementId topLevelId;
                    topLevelId = topLevel.Id;
                    topLevelParameter.Set(topLevelId);
                }

                if (null != topOffsetParameter)
                {
                    topOffsetParameter.Set(0.0);
                }

                if (null != baseOffsetParameter)
                {
                    baseOffsetParameter.Set(0.0);
                }
            }
        }

        /// <summary>
        /// create beam of certain type in certain position
        /// </summary>
        /// <param name="point2D1">one point of the location line in 2D</param>
        /// <param name="point2D2">another point of the location line in 2D</param>
        /// <param name="baseLevel">the base level of the beam</param>
        /// <param name="topLevel">the top level of the beam</param>
        /// <param name="beamType">type of beam</param>
        /// <returns>nothing</returns>
        private void PlaceBeam(Autodesk.Revit.DB.UV point2D1, Autodesk.Revit.DB.UV point2D2, Level baseLevel, Level topLevel, FamilySymbol beamType)
        {
            double height = topLevel.Elevation;
            Autodesk.Revit.DB.XYZ startPoint = new Autodesk.Revit.DB.XYZ(point2D1.U, point2D1.V, height);
            Autodesk.Revit.DB.XYZ endPoint = new Autodesk.Revit.DB.XYZ(point2D2.U, point2D2.V, height);
            Autodesk.Revit.DB.ElementId topLevelId = topLevel.Id;

            Line line = Line.CreateBound(startPoint, endPoint);
            STRUCTURALTYPE structuralType = Autodesk.Revit.DB.Structure.StructuralType.Beam;
            if (!beamType.IsActive)
               beamType.Activate();
            m_revit.ActiveUIDocument.Document.Create.NewFamilyInstance(line, beamType, topLevel, structuralType);
        }

        /// <summary>
        /// create brace of certain type in certain position between two adjacent columns
        /// </summary>
        /// <param name="point2D1">one point of the location line in 2D</param>
        /// <param name="point2D2">another point of the location line in 2D</param>
        /// <param name="baseLevel">the base level of the brace</param>
        /// <param name="topLevel">the top level of the brace</param>
        /// <param name="braceType">type of beam</param>
        /// <param name="isXDirection">whether the location line is in x direction</param>
        private void PlaceBrace(Autodesk.Revit.DB.UV point2D1, Autodesk.Revit.DB.UV point2D2, Level baseLevel, Level topLevel, FamilySymbol braceType, bool isXDirection)
        {
            //get the start points and end points of location lines of two braces
            double topHeight = topLevel.Elevation;
            double baseHeight = baseLevel.Elevation;
            double middleElevation = (topHeight + baseHeight) / 2;
            double middleHeight = (topHeight - baseHeight) / 2;
            Autodesk.Revit.DB.XYZ startPoint = new Autodesk.Revit.DB.XYZ(point2D1.U, point2D1.V, middleElevation);
            Autodesk.Revit.DB.XYZ endPoint = new Autodesk.Revit.DB.XYZ(point2D2.U, point2D2.V, middleElevation);
            Autodesk.Revit.DB.XYZ middlePoint;

            if (isXDirection)
            {
                middlePoint = new Autodesk.Revit.DB.XYZ((point2D1.U + point2D2.U) / 2, point2D2.V, topHeight);
            }
            else
            {
                middlePoint = new Autodesk.Revit.DB.XYZ(point2D2.U, (point2D1.V + point2D2.V) / 2, topHeight);
            }

            //create two brace and set their location line
            STRUCTURALTYPE structuralType = Autodesk.Revit.DB.Structure.StructuralType.Brace;
            Autodesk.Revit.DB.ElementId levelId = topLevel.Id;
            Autodesk.Revit.DB.ElementId startLevelId = baseLevel.Id;
            Autodesk.Revit.DB.ElementId endLevelId = topLevel.Id;

            Line line1 = Line.CreateBound(startPoint, middlePoint);
            if (!braceType.IsActive)
               braceType.Activate();
            FamilyInstance firstBrace = m_revit.ActiveUIDocument.Document.Create.NewFamilyInstance(line1, braceType, baseLevel, structuralType);

            Parameter referenceLevel1 = firstBrace.get_Parameter(BuiltInParameter.INSTANCE_REFERENCE_LEVEL_PARAM);
            if (null != referenceLevel1)
            {
                referenceLevel1.Set(levelId);
            }

            Line line2 = Line.CreateBound(endPoint, middlePoint);
            FamilyInstance secondBrace = m_revit.ActiveUIDocument.Document.Create.NewFamilyInstance(line2, braceType, baseLevel, structuralType);

            Parameter referenceLevel2 = secondBrace.get_Parameter(BuiltInParameter.INSTANCE_REFERENCE_LEVEL_PARAM);
            if (null != referenceLevel2)
            {
                referenceLevel2.Set(levelId);
            }
        }
    }

    /// <summary>
    /// assistant class contains the symbol and its name.
    /// </summary>
    public class SymbolMap
    {
        string m_symbolName = "";
        FamilySymbol m_symbol = null;

        /// <summary>
        /// constructor without parameter is forbidden
        /// </summary>
        private SymbolMap()
        {
        }

        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="symbol">family symbol</param>
        public SymbolMap(FamilySymbol symbol)
        {
            m_symbol = symbol;
            string familyName = "";
            if (null != symbol.Family)
            {
                familyName = symbol.Family.Name;
            }
            m_symbolName = familyName + " : " + symbol.Name;
        }

        /// <summary>
        /// SymbolName property
        /// </summary>
        public string SymbolName
        {
            get
            {
                return m_symbolName;
            }
        }
        /// <summary>
        /// ElementType property
        /// </summary>
        public FamilySymbol ElementType
        {
            get
            {
                return m_symbol;
            }
        }
    }
}

=== CODE_BLOCK_0021 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {

            Transaction tran = new Transaction(commandData.Application.ActiveUIDocument.Document, "CreateBeamSystem");
            tran.Start();

            try
            {
                GeometryUtil.CreApp = commandData.Application.Application.Create;

                // initialize precondition data of the program
                BeamSystemData data = new BeamSystemData(commandData);
                // display form to collect user's setting for beam system
                using (BeamSystemForm form = new BeamSystemForm(data))
                {
                    if (form.ShowDialog() != DialogResult.OK)
                    {
                        tran.RollBack();
                        return Autodesk.Revit.UI.Result.Cancelled;
                    }
                }

                // create beam system using the parameters saved in BeamSystemData
                BeamSystemBuilder builder = new BeamSystemBuilder(data);
                builder.CreateBeamSystem();
            }
            catch (ErrorMessageException errorEx)
            {
                // checked exception need to show in error messagebox
                message = errorEx.Message;
                tran.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }
            catch(Exception ex)
            {
                // unchecked exception cause command failed
                message = "Command is failed for unexpected reason.";
                Trace.WriteLine(ex.ToString());
                tran.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }

            tran.Commit();
            return Autodesk.Revit.UI.Result.Succeeded;
        }
    }
}

=== CODE_BLOCK_0023 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, "Revit.SDK.Samples.CreateComplexAreaRein");
            trans.Start();
            //initialize members
            m_revit = revit;
            m_currentDoc = revit.Application.ActiveUIDocument;
            m_data = new AreaReinData(revit.Application.ActiveUIDocument.Document);

            try
            {
                //check precondition and prepare necessary data to create AreaReinforcement.
                Reference refer = null;
                IList<Curve> curves = new List<Curve>();
                Floor floor = InitFloor(ref refer, ref curves);

                //ask for user's input
                AreaReinData dataOnFloor = new AreaReinData(revit.Application.ActiveUIDocument.Document);
                CreateComplexAreaReinForm createForm = new
                    CreateComplexAreaReinForm(dataOnFloor);
                if (createForm.ShowDialog() == DialogResult.OK)
                {
                    //define the Major Direction of AreaReinforcement,
                    //we get direction of first Line on the Floor as the Major Direction
                    Line firstLine = (Line)(curves[0]);
                    Autodesk.Revit.DB.XYZ majorDirection = new Autodesk.Revit.DB.XYZ(
                        firstLine.GetEndPoint(1).X - firstLine.GetEndPoint(0).X,
                        firstLine.GetEndPoint(1).Y - firstLine.GetEndPoint(0).Y,
                        firstLine.GetEndPoint(1).Z - firstLine.GetEndPoint(0).Z);

                    //create AreaReinforcement by AreaReinforcement.Create() function
                    DocCreator creator = m_revit.Application.ActiveUIDocument.Document.Create;
                    ElementId areaReinforcementTypeId = AreaReinforcementType.CreateDefaultAreaReinforcementType(revit.Application.ActiveUIDocument.Document);
                    ElementId rebarBarTypeId = RebarBarType.CreateDefaultRebarBarType(revit.Application.ActiveUIDocument.Document);
                    ElementId rebarHookTypeId = RebarHookType.CreateDefaultRebarHookType(revit.Application.ActiveUIDocument.Document);
                    AreaReinforcement areaRein = AreaReinforcement.Create(revit.Application.ActiveUIDocument.Document, floor, curves, majorDirection, areaReinforcementTypeId, rebarBarTypeId, rebarHookTypeId);

                    //set AreaReinforcement and it's AreaReinforcementCurves parameters
                    dataOnFloor.FillIn(areaRein);
                    trans.Commit();
                    return Autodesk.Revit.UI.Result.Succeeded;
                }
            }
            catch (ApplicationException appEx)
            {
                message = appEx.Message;
                trans.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }
            catch
            {
                message = "Unknow Errors.";
                trans.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }
            trans.RollBack();
            return Autodesk.Revit.UI.Result.Cancelled;
        }

        /// <summary>
        /// ExternalCommandData
        /// </summary>
        public static ExternalCommandData CommandData
        {
            get
            {
                return m_revit;
            }
        }

        /// <summary>
        /// initialize member data, judge simple precondition
        /// </summary>
        private Floor InitFloor(ref Reference refer, ref IList<Curve> curves)
        {
           ElementSet elems = new ElementSet();
            foreach (ElementId elementId in m_currentDoc.Selection.GetElementIds())
            {
               elems.Insert(m_currentDoc.Document.GetElement(elementId));
            }
            //selected 0 or more than 1 element
            if (elems.Size != 1)
            {
                string msg = "Please select exactly one slab.";
                ApplicationException appEx = new ApplicationException(msg);
                throw appEx;
            }
            Floor floor = null;
            foreach (object o in elems)
            {
                //selected one floor
                floor = o as Floor;
                if (null == floor)
                {
                    string msg = "Please select exactly one slab.";
                    ApplicationException appEx = new ApplicationException(msg);
                    throw appEx;
                }
            }
            //check the shape is rectangular and get its edges
            GeomHelper helper = new GeomHelper();
            if (!helper.GetFloorGeom(floor, ref refer, ref curves))
            {
                ApplicationException appEx = new
                    ApplicationException(
                    "Your selection is not a structural rectangular horizontal slab.");
                throw appEx;
            }

            return floor;
        }
    }
}

=== CODE_BLOCK_0025 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            try
            {
                m_revit = revit;
                Autodesk.Revit.DB.View view = m_revit.Application.ActiveUIDocument.Document.ActiveView;
                View3D view3D = view as View3D;
                if (null != view3D)
                {
                    message += "Only create dimensions in 2D";
                    return Autodesk.Revit.UI.Result.Failed;
                }

                ViewSheet viewSheet = view as ViewSheet;
                if (null != viewSheet)
                {
                    message += "Only create dimensions in 2D";
                    return Autodesk.Revit.UI.Result.Failed;
                }

                //try too adds a dimension from the start of the wall to the end of the wall into the project
                if (!AddDimension())
                {
                    message = m_errorMessage;
                    return Autodesk.Revit.UI.Result.Failed;
                }
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception e)
            {
                message = e.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }

        /// <summary>
        /// find out the wall, insert it into a array list
        /// </summary>
        bool initialize()
        {
           ElementSet selections = new ElementSet();
            foreach (ElementId elementId in m_revit.Application.ActiveUIDocument.Selection.GetElementIds())
            {
               selections.Insert(m_revit.Application.ActiveUIDocument.Document.GetElement(elementId));
            }
            //nothing was selected
            if (0 == selections.Size)
            {
                m_errorMessage += "Please select Basic walls";
                return false;
            }

            //find out wall
            foreach (Autodesk.Revit.DB.Element e in selections)
            {
                Wall wall = e as Wall;
                if (null != wall)
                {
                    if ("Basic" != wall.WallType.Kind.ToString())
                    {
                        continue;
                    }
                    m_walls.Add(wall);
                }
            }

            //no wall was selected
            if (0 == m_walls.Count)
            {
                m_errorMessage += "Please select Basic walls";
                return false;
            }
            return true;
        }

      /// <summary>
      /// find out every wall in the selection and add a dimension from the start of the wall to its end
      /// </summary>
      /// <returns>if add successfully, true will be returned, else false will be returned</returns>
      public bool AddDimension()
      {
         if (!initialize())
         {
            return false;
         }

         Transaction transaction = new Transaction(m_revit.Application.ActiveUIDocument.Document, "Add Dimensions");
         transaction.Start();
         //get out all the walls in this array, and create a dimension from its start to its end
         for (int i = 0; i < m_walls.Count; i++)
         {
            Wall wallTemp = m_walls[i] as Wall;
            if (null == wallTemp)
            {
               continue;
            }

            //get location curve
            Location location = wallTemp.Location;
            LocationCurve locationline = location as LocationCurve;
            if (null == locationline)
            {
               continue;
            }

            //New Line

            Line newLine = null;

            //get reference
            ReferenceArray referenceArray = new ReferenceArray();

            AnalyticalPanel analyticalModel = null;
            Document document = wallTemp.Document;
            AnalyticalToPhysicalAssociationManager assocManager = AnalyticalToPhysicalAssociationManager.GetAnalyticalToPhysicalAssociationManager(document);
            if (assocManager != null)
            {
               ElementId associatedElementId = assocManager.GetAssociatedElementId(wallTemp.Id);
               if (associatedElementId != ElementId.InvalidElementId)
               {
                  Element associatedElement = document.GetElement(associatedElementId);
                  if (associatedElement != null && associatedElement is AnalyticalPanel)
                  {
                     analyticalModel = associatedElement as AnalyticalPanel;
                  }
               }
            }
            IList<Curve> activeCurveList = analyticalModel.GetOuterContour().ToList();
            foreach (Curve aCurve in activeCurveList)
            {
               // find non-vertical curve from analytical model
               if (aCurve.GetEndPoint(0).Z == aCurve.GetEndPoint(1).Z)
                  newLine = aCurve as Line;
               if (aCurve.GetEndPoint(0).Z != aCurve.GetEndPoint(1).Z)
               {
                  AnalyticalModelSelector amSelector = new AnalyticalModelSelector(aCurve);
                  amSelector.CurveSelector = AnalyticalCurveSelector.StartPoint;

                  referenceArray.Append(analyticalModel.GetReference(amSelector));
               }
               if (2 == referenceArray.Size)
                  break;
            }
            if (referenceArray.Size != 2)
            {
               m_errorMessage += "Did not find two references";
               return false;
            }
            try
            {
               //try to add new a dimension
               Autodesk.Revit.UI.UIApplication app = m_revit.Application;
               Document doc = app.ActiveUIDocument.Document;

               Autodesk.Revit.DB.XYZ p1 = new XYZ(
                   newLine.GetEndPoint(0).X + 5,
                   newLine.GetEndPoint(0).Y + 5,
                   newLine.GetEndPoint(0).Z);
               Autodesk.Revit.DB.XYZ p2 = new XYZ(
                   newLine.GetEndPoint(1).X + 5,
                   newLine.GetEndPoint(1).Y + 5,
                   newLine.GetEndPoint(1).Z);

               Line newLine2 = Line.CreateBound(p1, p2);
               Dimension newDimension = doc.Create.NewDimension(
                 doc.ActiveView, newLine2, referenceArray);
            }
            // catch the exceptions
            catch (Exception ex)
            {
               m_errorMessage += ex.ToString();
               return false;
            }
         }
         transaction.Commit();
         return true;
      }

   }
}

=== CODE_BLOCK_0027 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message,
            ElementSet elements)
      {
         m_document = commandData.Application.ActiveUIDocument.Document;
         if (m_document.IsFamilyDocument)
         {
            message = "Cannot create ductwork stiffener in family document";
            return Result.Failed;
         }

         //Get the ductwork in current project
         FilteredElementCollector ductCollector = new FilteredElementCollector(m_document);
         ductCollector.OfCategory(BuiltInCategory.OST_FabricationDuctwork).OfClass(typeof(FabricationPart));
         if (ductCollector.GetElementCount() == 0)
         {
            message = "The document does not contain fabrication ductwork";
            return Result.Failed;
         }
         m_ductwork = ductCollector.FirstElement() as FabricationPart;

         //Get the ductwork stiffener type
         FilteredElementCollector stiffenerTypeCollector = new FilteredElementCollector(m_document);
         stiffenerTypeCollector.OfCategory(BuiltInCategory.OST_FabricationDuctworkStiffeners).OfClass(typeof(FamilySymbol));
         if (stiffenerTypeCollector.GetElementCount() == 0)
         {
            message = "The document does not contain stiffener family symbol";
            return Result.Failed;
         }
         IList<Element> allStiffenerTypes = stiffenerTypeCollector.ToElements();
         String stiffenerTypeName = "Duct Stiffener - External Rectangular Angle Iron: L Angle";
         foreach (Element element in allStiffenerTypes)
         {
            FamilySymbol f = element as FamilySymbol;
            String name = f.Family.Name + ": " + f.Name;
            if (name == stiffenerTypeName)
            {
               m_stiffenerType = f;
               break;
            }
         }
         if (m_stiffenerType == null)
         {
            message = "The stiffener type cannot be found in this document";
            return Result.Failed;
         }

         //Place the stiffener at ductwork middle point
         m_distanceToHostEnd = 0.5 * m_ductwork.CenterlineLength;

         try
         {
            using (Transaction transaction = new Transaction(m_document, "Sample_CreateDuctworkStiffener"))
            {
               transaction.Start();
               if (!m_stiffenerType.IsActive)
               {
                  m_stiffenerType.Activate();
                  m_document.Regenerate();
               }
               FamilyInstance stiffener = MEPSupportUtils.CreateDuctworkStiffener(m_document, m_stiffenerType.Id, m_ductwork.Id, m_distanceToHostEnd);
               transaction.Commit();
            }
            return Result.Succeeded;
         }
         catch (Exception ex)
         {
            message = ex.Message;
            return Result.Failed;
         }
      }

      #endregion
   }
}

=== CODE_BLOCK_0029 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, "Revit.SDK.Samples.CreateSimpleAreaRein");
            trans.Start();
            //initialize necessary data
            m_revit = revit;
            m_currentDoc = revit.Application.ActiveUIDocument;

            //create AreaReinforcement
            try
            {
                if (Create())
                {
                    trans.Start();
                    return Autodesk.Revit.UI.Result.Succeeded;
                }
            }
            catch (ApplicationException appEx)
            {
                TaskDialog.Show("Revit", appEx.Message);
                trans.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }
            catch
            {
                TaskDialog.Show("Revit", "Unknow Errors.");
                trans.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }
            trans.RollBack();
            return Autodesk.Revit.UI.Result.Cancelled;
        }

        /// <summary>
        /// ExternalCommandData
        /// </summary>
        public static ExternalCommandData CommandData
        {
            get
            {
                return m_revit;
            }
        }

        /// <summary>
        /// create simple AreaReinforcement on selected wall or floor
        /// </summary>
        /// <returns></returns>
        private bool Create()
        {
           ElementSet elems = new ElementSet();
            foreach (ElementId elementId in m_currentDoc.Selection.GetElementIds())
            {
               elems.Insert(m_currentDoc.Document.GetElement(elementId));
            }

            //selected 0 or more than 1 element
            if (elems.Size != 1)
            {
                TaskDialog.Show("Error", "Please select exactly one wall or floor.");
                return false;
            }
            foreach (object o in elems)
            {
                //create on floor
                Floor floor = o as Floor;
                if (null != floor)
                {
                    bool flag = CreateAreaReinOnFloor(floor);
                    return flag;
                }

                //create on wall
                Wall wall = o as Wall;
                if (null != wall)
                {
                    bool flag = CreateAreaReinOnWall(wall);
                    return flag;
                }

                //selected element is neither wall nor floor
                TaskDialog.Show("Error", "Please select exactly one wall or floor.");
            }
            return false;
        }

        /// <summary>
        /// create simple AreaReinforcement on horizontal floor
        /// </summary>
        /// <param name="floor"></param>
        /// <returns>is successful</returns>
        private bool CreateAreaReinOnFloor(Floor floor)
        {
            GeomHelper helper = new GeomHelper();
            Reference refer = null;
            IList<Curve> curves = new List<Curve>();

            //check whether floor is horizontal rectangular 
            //and prepare necessary to create AreaReinforcement
            if (!helper.GetFloorGeom(floor, ref refer, ref curves))
            {
                ApplicationException appEx = new ApplicationException(
                    "Your selection is not a horizontal rectangular slab.");
                throw appEx;
            }

            AreaReinDataOnFloor dataOnFloor = new AreaReinDataOnFloor();
            CreateSimpleAreaReinForm createForm =
                new CreateSimpleAreaReinForm(dataOnFloor);

            //allow use select parameters to create
            if (createForm.ShowDialog() == DialogResult.OK)
            {
                //define the Major Direction of AreaReinforcement,
                //we get direction of first Line on the Floor as the Major Direction
                Line firstLine = (Line)(curves[0]);
                Autodesk.Revit.DB.XYZ majorDirection = new Autodesk.Revit.DB.XYZ(
                    firstLine.GetEndPoint(1).X - firstLine.GetEndPoint(0).X,
                    firstLine.GetEndPoint(1).Y - firstLine.GetEndPoint(0).Y,
                    firstLine.GetEndPoint(1).Z - firstLine.GetEndPoint(0).Z);

                //Create AreaReinforcement
                ElementId areaReinforcementTypeId = AreaReinforcementType.CreateDefaultAreaReinforcementType(m_revit.Application.ActiveUIDocument.Document);
                ElementId rebarBarTypeId = RebarBarType.CreateDefaultRebarBarType(m_revit.Application.ActiveUIDocument.Document);
                ElementId rebarHookTypeId = RebarHookType.CreateDefaultRebarHookType(m_revit.Application.ActiveUIDocument.Document);
                AreaReinforcement areaRein = AreaReinforcement.Create(m_revit.Application.ActiveUIDocument.Document, floor, curves, majorDirection, areaReinforcementTypeId, rebarBarTypeId, rebarHookTypeId);

                //set AreaReinforcement and it's AreaReinforcementCurves parameters
                dataOnFloor.FillIn(areaRein);
                return true;
            }
            return false;
        }

        /// <summary>
        /// create simple AreaReinforcement on vertical straight rectangular wall
        /// </summary>
        /// <param name="wall"></param>
        /// <returns>is successful</returns>
        private bool CreateAreaReinOnWall(Wall wall)
        {
            //make sure selected is basic wall
            if (wall.WallType.Kind != WallKind.Basic)
            {
                TaskDialog.Show("Revit", "Selected wall is not a basic wall.");
                return false;
            }

            GeomHelper helper = new GeomHelper();
            Reference refer = null;
            IList<Curve> curves = new List<Curve>();
            //check whether wall is vertical rectangular and analytical model shape is line
            if (!helper.GetWallGeom(wall, ref refer, ref curves))
            {
                ApplicationException appEx = new ApplicationException(
                    "Your selection is not a structural straight rectangular wall.");
                throw appEx;
            }

            AreaReinDataOnWall dataOnWall = new AreaReinDataOnWall();
            CreateSimpleAreaReinForm createForm = new
                CreateSimpleAreaReinForm(dataOnWall);

            //allow use select parameters to create
            if (createForm.ShowDialog() == DialogResult.OK)
            {
                DocCreator creator = m_revit.Application.ActiveUIDocument.Document.Create;

                //define the Major Direction of AreaReinforcement,
                //we get direction of first Line on the Floor as the Major Direction
                Line firstLine = (Line)(curves[0]);
                Autodesk.Revit.DB.XYZ majorDirection = new Autodesk.Revit.DB.XYZ(
                    firstLine.GetEndPoint(1).X - firstLine.GetEndPoint(0).X,
                    firstLine.GetEndPoint(1).Y - firstLine.GetEndPoint(0).Y,
                    firstLine.GetEndPoint(1).Z - firstLine.GetEndPoint(0).Z);

                //create AreaReinforcement
                IList<Curve> curveList = new List<Curve>();
                foreach (Curve curve in curves)
                {
                    curveList.Add(curve);
                }
                ElementId areaReinforcementTypeId = AreaReinforcementType.CreateDefaultAreaReinforcementType(m_revit.Application.ActiveUIDocument.Document);
                ElementId rebarBarTypeId = RebarBarType.CreateDefaultRebarBarType(m_revit.Application.ActiveUIDocument.Document);
                ElementId rebarHookTypeId = RebarHookType.CreateDefaultRebarHookType(m_revit.Application.ActiveUIDocument.Document);
                AreaReinforcement areaRein = AreaReinforcement.Create(m_revit.Application.ActiveUIDocument.Document, wall, curveList, majorDirection, areaReinforcementTypeId, rebarBarTypeId, rebarHookTypeId);
                dataOnWall.FillIn(areaRein);
                return true;
            }
            return false;
        }
    }
}

=== CODE_BLOCK_0031 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                                    ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            try
            {
                m_project = commandData.Application.ActiveUIDocument;

                // Get the selected element and store it to data member.
                if (!GetSelectedElement())
                {
                    message = m_errorInformation;
                    return Autodesk.Revit.UI.Result.Failed;
                }

                // Create a BoundingBoxXYZ instance which used in NewViewSection() method
                if (!GenerateBoundingBoxXYZ())
                {
                    message = m_errorInformation;
                    return Autodesk.Revit.UI.Result.Failed;
                }

                // Create a section view. 
                Transaction transaction = new Transaction(m_project.Document, "CreateSectionView");
                transaction.Start();
                //ViewSection section = m_project.Document.Create.NewViewSection(m_box);
                ElementId DetailViewId = ElementId.InvalidElementId;
                IList<Element> elems = new FilteredElementCollector(m_project.Document).OfClass(typeof(ViewFamilyType)).ToElements();
                foreach (Element e in elems)
                {
                    ViewFamilyType v = e as ViewFamilyType;

                    if (v != null && v.ViewFamily == ViewFamily.Detail)
                    {
                        DetailViewId = e.Id;
                        break;
                    }
                }
                ViewSection section = ViewSection.CreateDetail(m_project.Document, DetailViewId, m_box);
                if (null == section)
                {
                    message = "Can't create the ViewSection.";
                    return Autodesk.Revit.UI.Result.Failed;
                }

                // Modify some parameters to make it look better.
                section.get_Parameter(BuiltInParameter.VIEW_DETAIL_LEVEL).Set(2);
                transaction.Commit();

                // If everything goes right, give successful information and return succeeded.
                TaskDialog.Show("Revit", "Create view section succeeded.");
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception e)
            {
                message = e.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }


        /// <summary>
        /// Get the selected element, and check whether it is a wall, a floor or a beam.
        /// </summary>
        /// <returns>true if the process succeed; otherwise, false.</returns>
        Boolean GetSelectedElement()
        {
            // First get the selection, and make sure only one element in it.
           ElementSet collection = new ElementSet();
            foreach (ElementId elementId in m_project.Selection.GetElementIds())
            {
               collection.Insert(m_project.Document.GetElement(elementId));
            }
            if (1 != collection.Size)
            {
                m_errorInformation =
                    "Please select only one element, such as a wall, a beam or a floor.";
                return false;
            }

            // Get the selected element.
            foreach (Autodesk.Revit.DB.Element e in collection)
            {
                m_currentComponent = e;
            }

            // Make sure the element to be a wall, beam or a floor.
            if (m_currentComponent is Wall)
            {
                // Check whether the wall is a linear wall
                LocationCurve location = m_currentComponent.Location as LocationCurve;
                if (null == location)
                {
                    m_errorInformation = "The selected wall should be linear.";
                    return false;
                }
                if (location.Curve is Line)
                {
                    m_type = SelectType.WALL;   // when the element is a linear wall
                    return true;
                }
                else
                {
                    m_errorInformation = "The selected wall should be linear.";
                    return false;
                }
            }

            FamilyInstance beam = m_currentComponent as FamilyInstance;
            if (null != beam && StructuralType.Beam == beam.StructuralType)
            {
                m_type = SelectType.BEAM;       // when the element is a beam
                return true;
            }

            if (m_currentComponent is Floor)
            {
                m_type = SelectType.FLOOR;      // when the element is a floor.
                return true;
            }

            // If it is not a wall, a beam or a floor, give error information.
            m_errorInformation = "Please select an element, such as a wall, a beam or a floor.";
            return false;
        }


        /// <summary>
        /// Generate a BoundingBoxXYZ instance which used in NewViewSection() method
        /// </summary>
        /// <returns>true if the instance can be created; otherwise, false.</returns>
        Boolean GenerateBoundingBoxXYZ()
        {
            Transaction transaction = new Transaction(m_project.Document, "GenerateBoundingBox");
            transaction.Start();
            // First new a BoundingBoxXYZ, and set the MAX and Min property.
            m_box = new BoundingBoxXYZ();
            m_box.Enabled = true;
            Autodesk.Revit.DB.XYZ maxPoint = new Autodesk.Revit.DB.XYZ(LENGTH, LENGTH, 0);
            Autodesk.Revit.DB.XYZ minPoint = new Autodesk.Revit.DB.XYZ(-LENGTH, -LENGTH, -HEIGHT);
            m_box.Max = maxPoint;
            m_box.Min = minPoint;

            // Set Transform property is the most important thing.
            // It define the Orgin and the directions(include RightDirection, 
            // UpDirection and ViewDirection) of the created view.
            Transform transform = GenerateTransform();
            if (null == transform)
            {
                return false;
            }
            m_box.Transform = transform;
            transaction.Commit();

            // If all went well, return true.
            return true;
        }


        /// <summary>
        /// Generate a Transform instance which as Transform property of BoundingBoxXYZ
        /// </summary>
        /// <returns>the reference of Transform, return null if it can't be generated</returns>
        Transform GenerateTransform()
        {
            // Because different element have different ways to create Transform.
            // So, this method just call corresponding method.
            if (SelectType.WALL == m_type)
            {
                return GenerateWallTransform();
            }
            else if (SelectType.BEAM == m_type)
            {
                return GenerateBeamTransform();
            }
            else if (SelectType.FLOOR == m_type)
            {
                return GenerateFloorTransform();
            }
            else
            {
                m_errorInformation = "The program should never go here.";
                return null;
            }
        }


        /// <summary>
        /// Generate a Transform instance which as Transform property of BoundingBoxXYZ, 
        /// when the user select a wall, this method will be called
        /// </summary>
        /// <returns>the reference of Transform, return null if it can't be generated</returns>
        Transform GenerateWallTransform()
        {
            Transform transform = null;
            Wall wall = m_currentComponent as Wall;

            // Because the architecture wall and curtain wall don't have analytical Model lines.
            // So Use Location property of wall object is better choice.
            // First get the location line of the wall
            LocationCurve location = wall.Location as LocationCurve;
            Line locationLine = location.Curve as Line;
            transform = Transform.Identity;

            // Second find the middle point of the wall and set it as Origin property.
            XYZ mPoint = XYZMath.FindMidPoint(locationLine.GetEndPoint(0), locationLine.GetEndPoint(1));
            // midPoint is mid point of the wall location, but not the wall's.
            // The different is the elevation of the point. Then change it.

            Autodesk.Revit.DB.XYZ midPoint = new XYZ(mPoint.X, mPoint.Y, mPoint.Z + GetWallMidOffsetFromLocation(wall));

            transform.Origin = midPoint;

            // At last find out the directions of the created view, and set it as Basis property.
            Autodesk.Revit.DB.XYZ basisZ = XYZMath.FindDirection(locationLine.GetEndPoint(0), locationLine.GetEndPoint(1));
            Autodesk.Revit.DB.XYZ basisX = XYZMath.FindRightDirection(basisZ);
            Autodesk.Revit.DB.XYZ basisY = XYZMath.FindUpDirection(basisZ);

            transform.set_Basis(0, basisX);
            transform.set_Basis(1, basisY);
            transform.set_Basis(2, basisZ);
            return transform;
        }


      /// <summary>
      /// Generate a Transform instance which as Transform property of BoundingBoxXYZ, 
      /// when the user select a beam, this method will be called
      /// </summary>
      /// <returns>the reference of Transform, return null if it can't be generated</returns>
      Transform GenerateBeamTransform()
      {
         Transform transform = null;
         FamilyInstance instance = m_currentComponent as FamilyInstance;

         // First check whether the beam is horizontal.
         // In order to predigest the calculation, only allow it to be horizontal
         double startOffset = instance.get_Parameter(BuiltInParameter.STRUCTURAL_BEAM_END0_ELEVATION).AsDouble();
         double endOffset = instance.get_Parameter(BuiltInParameter.STRUCTURAL_BEAM_END1_ELEVATION).AsDouble();
         if (-PRECISION > startOffset - endOffset || PRECISION < startOffset - endOffset)
         {
            m_errorInformation = "Please select a horizontal beam.";
            return transform;
         }

         if (!(instance.Location is LocationCurve))
         {
            m_errorInformation = "The program should never go here.";
            return transform;
         }
         Curve curve = (instance.Location as LocationCurve).Curve;
         if (null == curve)
         {
            m_errorInformation = "The program should never go here.";
            return transform;
         }

         // Now I am sure I can create a transform instance.
         transform = Transform.Identity;

         // Third find the middle point of the line and set it as Origin property.
         Autodesk.Revit.DB.XYZ startPoint = curve.GetEndPoint(0);
         Autodesk.Revit.DB.XYZ endPoint = curve.GetEndPoint(1);
         Autodesk.Revit.DB.XYZ midPoint = XYZMath.FindMidPoint(startPoint, endPoint);
         transform.Origin = midPoint;

         // At last find out the directions of the created view, and set it as Basis property.   
         Autodesk.Revit.DB.XYZ basisZ = XYZMath.FindDirection(startPoint, endPoint);
         Autodesk.Revit.DB.XYZ basisX = XYZMath.FindRightDirection(basisZ);
         Autodesk.Revit.DB.XYZ basisY = XYZMath.FindUpDirection(basisZ);

         transform.set_Basis(0, basisX);
         transform.set_Basis(1, basisY);
         transform.set_Basis(2, basisZ);
         return transform;
      }


      /// <summary>
      /// Generate a Transform instance which as Transform property of BoundingBoxXYZ, 
      /// when the user select a floor, this method will be called
      /// </summary>
      /// <returns>the reference of Transform, return null if it can't be generated</returns>
      Transform GenerateFloorTransform()
      {
         Transform transform = null;
         Floor floor = m_currentComponent as Floor;

         // First get the Analytical Model lines
         AnalyticalPanel model = null;
         Document document = floor.Document;
         AnalyticalToPhysicalAssociationManager assocManager = AnalyticalToPhysicalAssociationManager.GetAnalyticalToPhysicalAssociationManager(document);
         if (assocManager != null)
         {
            ElementId associatedElementId = assocManager.GetAssociatedElementId(floor.Id);
            if (associatedElementId != ElementId.InvalidElementId)
            {
               Element associatedElement = document.GetElement(associatedElementId);
               if (associatedElement != null && associatedElement is AnalyticalPanel)
               {
                  model = associatedElement as AnalyticalPanel;
               }
            }
         }
         if (null == model)
         {
            m_errorInformation = "Please select a structural floor.";
            return transform;
         }

         CurveArray curves = m_project.Document.Application.Create.NewCurveArray();
         IList<Curve> curveList = model.GetOuterContour().ToList();
         foreach (Curve curve in curveList)
         {
            curves.Append(curve);
         }

         if (null == curves || true == curves.IsEmpty)
         {
            m_errorInformation = "The program should never go here.";
            return transform;
         }

         // Now I am sure I can create a transform instance.
         transform = Transform.Identity;

         // Third find the middle point of the floor and set it as Origin property.
         Autodesk.Revit.DB.XYZ midPoint = XYZMath.FindMiddlePoint(curves);
         transform.Origin = midPoint;

         // At last find out the directions of the created view, and set it as Basis property.
         Autodesk.Revit.DB.XYZ basisZ = XYZMath.FindFloorViewDirection(curves);
         Autodesk.Revit.DB.XYZ basisX = XYZMath.FindRightDirection(basisZ);
         Autodesk.Revit.DB.XYZ basisY = XYZMath.FindUpDirection(basisZ);

         transform.set_Basis(0, basisX);
         transform.set_Basis(1, basisY);
         transform.set_Basis(2, basisZ);
         return transform;
      }

      Double GetWallMidOffsetFromLocation(Wall wall)
        {
            // First get the "Base Offset" property.
            Double baseOffset = wall.get_Parameter(BuiltInParameter.WALL_BASE_OFFSET).AsDouble();

            // Second get the "Unconnected Height" property. 
            Double height = wall.get_Parameter(BuiltInParameter.WALL_USER_HEIGHT_PARAM).AsDouble();

            // Get the middle of of wall elevation from the wall location.
            // The elevation of wall location equals the elevation of "Base Constraint" level
            Double midOffset = baseOffset + height / 2;
            return midOffset;
        }

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
               (m_box as IDisposable)?.Dispose();
            }
        }
        
        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }

    /// <summary>
    /// Create a drafting view. 
    /// </summary>
    [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
    [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
    public class CreateDraftingView : IExternalCommand
    {
        public Autodesk.Revit.UI.Result Execute(
          ExternalCommandData commandData,
          ref string message,
          ElementSet elements)
        {
            try
            {
                Autodesk.Revit.DB.Document doc = commandData.Application.ActiveUIDocument.Document;
                Transaction transaction = new Transaction(doc, "CreateDraftingView");
                transaction.Start();

                ViewFamilyType viewFamilyType = null;
                FilteredElementCollector collector = new FilteredElementCollector(doc);
                var viewFamilyTypes = collector.OfClass(typeof(ViewFamilyType)).ToElements();
                foreach (Element e in viewFamilyTypes)
                {
                   ViewFamilyType v = e as ViewFamilyType;
                   if (v.ViewFamily == ViewFamily.Drafting)
                   {
                      viewFamilyType = v;
                      break;
                   }
                }
                ViewDrafting drafting = ViewDrafting.Create(doc, viewFamilyType.Id);
                if (null == drafting)
                {
                    message = "Can't create the ViewDrafting.";
                    return Autodesk.Revit.UI.Result.Failed;
                }
                transaction.Commit();
                TaskDialog.Show("Revit", "Create view drafting succeeded.");
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception e)
            {
                message = e.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
    }
}

=== CODE_BLOCK_0033 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                                    ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Autodesk.Revit.UI.UIApplication revit = commandData.Application;
            UIDocument project = revit.ActiveUIDocument;

            // Get necessary data from revit.such as selected beams and level information
            if (!PrepareData(project))
            {
                message = m_errorInformation;
                return Autodesk.Revit.UI.Result.Failed;
            }

            // Check whether the selected beams can make a a vertical profile
            if (!IsVerticalProfile())
            {
                message = m_errorInformation;
                return Autodesk.Revit.UI.Result.Failed;
            }

            // Show the dialog for the user select the wall style
            using (CreateWallinBeamProfileForm displayForm = new CreateWallinBeamProfileForm(this))
            {
                if (DialogResult.OK != displayForm.ShowDialog())
                {
                    return Autodesk.Revit.UI.Result.Failed;
                }
            }

            // Create the walls using the outline generated by the beams.
            if (!BeginCreate(project.Document))
            {
                message = m_errorInformation;
                return Autodesk.Revit.UI.Result.Failed;
            }

            // If everything goes right, return succeeded.
            return Autodesk.Revit.UI.Result.Succeeded;
        }
        #endregion IExternalCommand Members Implementation

        /// <summary>
        /// Create the walls using the outline generated by the beams
        /// </summary>
        /// <param name="project"> A reference of current document</param>
        /// <returns>true if no error happens; otherwise, false.</returns>
        Boolean BeginCreate(Autodesk.Revit.DB.Document project)
        {
            //CurveArray curveArray = new CurveArray();   // store the curves used to create wall
            List<Curve> curveArray = new List<Curve>();
            Autodesk.Revit.DB.XYZ point;      // used to store the end point of the curve temporarily
            Curve curve = m_lineCollection[0] as Curve;
            curveArray.Add(curve);
            point = curve.GetEndPoint(1);

            // Sort the curves of analytical model and then add to curveArray.
            // API asks for the curves should be in a sequence, deasil or anticlockwise
            for (int i = 1; i < m_lineCollection.Count; i++)
            {
                foreach (Object o in m_lineCollection)
                {
                    Boolean isInclude = false;
                    foreach (Curve j in curveArray)
                    {
                        if (o.Equals(j))
                        {
                            isInclude = true;
                            break;
                        }
                    }
                    if (true == isInclude)
                    {
                        continue;
                    }

                    curve = o as Curve;
                    if (!EqualPoint(curve.GetEndPoint(0), point)
                        && !EqualPoint(curve.GetEndPoint(1), point))
                    {
                        continue;
                    }
                    else if (EqualPoint(curve.GetEndPoint(0), point))
                    {
                        curveArray.Add(curve);
                        point = curve.GetEndPoint(1);
                        break;
                    }
                    else if (EqualPoint(curve.GetEndPoint(1), point))
                    {
                        curveArray.Add(curve);
                        point = curve.GetEndPoint(0);
                        break;
                    }
                    else
                    {
                        m_errorInformation = "The program should never go here.";
                        return false;
                    }
                }
            }

            // If the program goes here, it means the beams can't form a profile.
            if (curveArray.Count != m_lineCollection.Count)
            {
                m_errorInformation = "There are more than one closed profile.";
                return false;
            }

            // Begin to create the wall.
            Transaction t = new Transaction(project, Guid.NewGuid().GetHashCode().ToString());
            t.Start();
            Wall createdWall = Wall.Create(project, curveArray,
                                            m_selectedWallType.Id, m_level.Id, m_isStructural);

            if (null == createdWall)
            {
                m_errorInformation = "Can not create the wall";
                return false;
            }

            // Modify some parameters of the created wall to make it look better.
            Double baseOffset = FindBaseOffset();   // get the base offset from m_level
            Double topOffset = FindTopOffset();     // get the top offset from m_level
            Autodesk.Revit.DB.ElementId levelId = m_level.Id;
            // Modify the "Base Constraint", "Base Offset", "Top Constraint" and "Top Offset"
            //properties of the created wall.
            createdWall.get_Parameter(BuiltInParameter.WALL_BASE_CONSTRAINT).Set(levelId);
            createdWall.get_Parameter(BuiltInParameter.WALL_BASE_OFFSET).Set(baseOffset);
            createdWall.get_Parameter(BuiltInParameter.WALL_HEIGHT_TYPE).Set(levelId);
            createdWall.get_Parameter(BuiltInParameter.WALL_TOP_OFFSET).Set(topOffset);
            t.Commit();
            return true;
        }

      /// <summary>
      /// Get necessary data from revit.such as selected beams, wall types and level information
      /// </summary>
      /// <param name="project">A reference of current document</param>
      /// <returns>true if no error happens; otherwise, false.</returns>
      Boolean PrepareData(Autodesk.Revit.UI.UIDocument project)
      {
         // Search all the wall types in the Revit
         FilteredElementCollector filteredElementCollector = new FilteredElementCollector(project.Document);
         filteredElementCollector.OfClass(typeof(WallType));
         m_wallTypeCollection = filteredElementCollector.Cast<WallType>().ToList<WallType>();

         // Find the selection of beams in Revit
         ElementSet selection = new ElementSet();
         foreach (ElementId elementId in project.Selection.GetElementIds())
         {
            selection.Insert(project.Document.GetElement(elementId));
         }

         foreach (Autodesk.Revit.DB.Element e in selection)
         {
            FamilyInstance m = e as FamilyInstance;

            // Use StructuralType property can judge whether it is a beam.
            if (null != m && StructuralType.Beam == m.StructuralType)
            {
               m_beamCollection.Add(e);    // store the beams

               if (!(m.Location is LocationCurve))
               {
                  m_errorInformation = "The beam should have location curve.";
                  return false;
               }
               m_lineCollection.Add((m.Location as LocationCurve).Curve);
            }
         }
         if (0 == m_beamCollection.Count)
         {
            m_errorInformation = "Can not find any beams.";
            return false;
         }

         // Get the level which will be used in create method
         FilteredElementCollector collector = new FilteredElementCollector(project.Document);
         m_level = collector.OfClass(typeof(Level)).FirstElement() as Level;
         return true;
      }

      /// <summary>
      /// Check whether the selected beams can make a a vertical profile.
      /// </summary>
      /// <returns>true if selected beams create a vertical profile; otherwise, false.</returns>
      Boolean IsVerticalProfile()
        {
            // First check whether all the beams are in a same vertical plane
            if (!IsInVerticalPlane())
            {
                m_errorInformation = "Not all the beam in a vertical plane.";
                return false;
            }

            // Second check whether a closed profile can be created by all the beams
            if (!CanCreateProfile())
            {
                m_errorInformation = "All the beams should create only one profile.";
                return false;
            }

            return true;
        }

        /// <summary>
        /// Check whether the input two points are the same
        /// </summary>
        /// <param name="first"> The first point</param>
        /// <param name="second"> The second point</param>
        /// <returns>true if two points are the same; otherwise, false</returns>
        Boolean EqualPoint(Autodesk.Revit.DB.XYZ first, Autodesk.Revit.DB.XYZ second)
        {
            if ((-PRECISION <= first.X - second.X && PRECISION >= first.X - second.X)
                && (-PRECISION <= first.Y - second.Y && PRECISION >= first.Y - second.Y)
                && (-PRECISION <= first.Z - second.Z && PRECISION >= first.Z - second.Z))
            {
                return true;
            }
            return false;
        }

        /// <summary>
        /// Check whether the two double data are the same
        /// </summary>
        /// <param name="first">The first double data</param>
        /// <param name="second">The second double data</param>
        /// <returns>true if two double data are the same; otherwise, false</returns>
        Boolean EqualDouble(Double first, Double second)
        {
            if (-PRECISION <= first - second && PRECISION >= first - second)
            {
                return true;
            }
            return false;
        }

        /// <summary>
        /// Check whether all the beams are in a same vertical plane
        /// </summary>
        /// <returns>true if they are in same vertical plane; otherwise, false</returns>
        Boolean IsInVerticalPlane()
        {
            Autodesk.Revit.DB.XYZ startPoint = new Autodesk.Revit.DB.XYZ();
            Autodesk.Revit.DB.XYZ endPoint = new Autodesk.Revit.DB.XYZ();
            int sign = 0;               // used as a symbol,
            Double slope = 0;           // record slope of the lines' projection on X-Y plane

            // When all the beams in the X-Z plane or Y-Z plane, the deal is especial
            // So I use 3 ways to judge whether all the beams are in same vertical plane
            Curve curve = m_lineCollection[0] as Curve;
            startPoint = curve.GetEndPoint(0);
            endPoint = curve.GetEndPoint(1);
            if (EqualDouble(startPoint.X, endPoint.X))
            {
                sign = 1;           // All the beams may be in Y-Z plane
            }
            else if (EqualDouble(startPoint.Y, endPoint.Y))
            {
                sign = 2;           // All the beams may be in X-Z plane
            }
            else
            {
                slope = (startPoint.Y - endPoint.Y) / (startPoint.X - endPoint.X);
            }

            // Begin to compare each analytical line and judge whether they are in same vertical plane
            for (int i = 1; i < m_lineCollection.Count; i++)
            {
                curve = m_lineCollection[i] as Curve;
                startPoint = curve.GetEndPoint(0);
                endPoint = curve.GetEndPoint(1);

                switch (sign)
                {
                    case 0:     // Judge whether the slope of beam's projection on X-Y plane are same.
                        Double anotherSlope = (startPoint.Y - endPoint.Y) / (startPoint.X - endPoint.X);
                        if (!EqualDouble(slope, anotherSlope))
                        {
                            return false;
                        }
                        break;
                    case 1:     // Judge whether the beams are in Y-Z plane
                        if (!EqualDouble(startPoint.X, endPoint.X))
                        {
                            return false;
                        }
                        break;
                    case 2:     // Judge whether the beams are in X-Z plane
                        if (!EqualDouble(startPoint.Y, endPoint.Y))
                        {
                            return false;
                        }
                        break;
                    default:    // If it go here, there must be something error.
                        TaskDialog.Show("Revit", "Should not come here.");
                        break;
                }
            }
            return true;
        }

        /// <summary>
        /// Check whether a closed profile can be created by all the beams
        /// </summary>
        /// <returns>true if one profile found; otherwise, false</returns>
        Boolean CanCreateProfile()
        {
            // Only allow all the beams compose a close profile.
            // As we all know, a close profile is composed by borders and points,
            // and the number of borders should be equal to points'.
            // So, the judgement use this way. 
            Autodesk.Revit.DB.XYZ startPoint = new Autodesk.Revit.DB.XYZ();
            Autodesk.Revit.DB.XYZ endPoint = new Autodesk.Revit.DB.XYZ();
            Curve curve = null;
            ArrayList pointArray = new ArrayList();
            bool hasStartpoint;      // indicate whether start point is in the array
            bool hasEndPoint;        // indicate whether end point is in the array

            // Find out all the points in the curves, the same point only count once.
            for (int i = 0; i < m_lineCollection.Count; i++)
            {
                curve = m_lineCollection[i] as Curve;
                startPoint = curve.GetEndPoint(0);
                endPoint = curve.GetEndPoint(1);
                hasStartpoint = false;  // Judge whether start point has been counted.
                hasEndPoint = false;    // Judge whether end point has been counted.

                if (0 == pointArray.Count)
                {
                    pointArray.Add(startPoint);
                    pointArray.Add(endPoint);
                    continue;
                }

                // Judge whether the points of this curve have been counted.
                foreach (Object o in pointArray)
                {
                    Autodesk.Revit.DB.XYZ point = (Autodesk.Revit.DB.XYZ)o;
                    if (EqualPoint(startPoint, point))
                    {
                        hasStartpoint = true;
                    }
                    if (EqualPoint(endPoint, point))
                    {
                        hasEndPoint = true;
                    }
                }

                // If not, add the points into the array.
                if (!hasStartpoint)
                {
                    pointArray.Add(startPoint);
                }
                if (!hasEndPoint)
                {
                    pointArray.Add(endPoint);
                }
            }

            if (pointArray.Count != m_lineCollection.Count)
            {
                return false;
            }

            return true;
        }

        /// <summary>
        /// Find the offset from the elevation of the lowest point to m_level's elevation 
        /// </summary>
        /// <returns> The length of the offset </returns>
        Double FindBaseOffset()
        {
            // Initialize the data.
            Double baseOffset = 0;  // the offset from the m_level's elevation
            Double lowestElevation = 0; // the elevation of the lowest point
            Curve curve = m_lineCollection[0] as Curve;
            lowestElevation = curve.GetEndPoint(0).Z;

            // Find out the elevation of the lowest point.
            foreach (Curve c in m_lineCollection)
            {
                if (c.GetEndPoint(0).Z < lowestElevation)
                {
                    lowestElevation = c.GetEndPoint(0).Z;
                }
                if (c.GetEndPoint(1).Z < lowestElevation)
                {
                    lowestElevation = c.GetEndPoint(1).Z;
                }
            }

            // Count the offset and return.
            baseOffset = lowestElevation - m_level.Elevation;
            return baseOffset;
        }

        /// <summary>
        /// Find the offset from the elevation of the highest point to m_level's elevation
        /// </summary>
        /// <returns>The length of the offset</returns>
        Double FindTopOffset()
        {
            // Initialize the data
            Double topOffset = 0;   // the offset from the m_level's elevation
            Double highestElevation = 0;    // the elevation of the highest point
            Curve curve = m_lineCollection[0] as Curve;
            highestElevation = curve.GetEndPoint(0).Z;

            // Find out the elevation of the highest point.
            foreach (Curve c in m_lineCollection)
            {
                if (c.GetEndPoint(0).Z > highestElevation)
                {
                    highestElevation = c.GetEndPoint(0).Z;
                }
                if (c.GetEndPoint(1).Z > highestElevation)
                {
                    highestElevation = c.GetEndPoint(1).Z;
                }
            }

            // Count the offset and return.
            topOffset = highestElevation - m_level.Elevation;
            return topOffset;
        }
    }
}

=== CODE_BLOCK_0035 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                                    ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Autodesk.Revit.UI.UIApplication revit = commandData.Application;
            UIDocument project = revit.ActiveUIDocument;

            // Find the selection of beams in Revit
            ElementSet selection = new ElementSet();
            foreach (ElementId elementId in project.Selection.GetElementIds())
            {
               selection.Insert(project.Document.GetElement(elementId));
            }
            foreach (Autodesk.Revit.DB.Element e in selection)
            {
                FamilyInstance m = e as FamilyInstance;
                if (null != m)
                {
                    if (StructuralType.Beam == m.StructuralType)
                    {
                        // Store all the beams the user selected in Revit
                        m_beamCollection.Add(e);
                    }
                }
            }
            if (0 == m_beamCollection.Count)
            {
                message = "Can not find any beams.";
                return Autodesk.Revit.UI.Result.Failed;
            }

            // Make sure all the beams have horizontal analytical line
            if (!CheckBeamHorizontal())
            {
                message = m_errorInformation;
                return Autodesk.Revit.UI.Result.Failed;
            }

            // Search all the wall types in the Revit
            FilteredElementCollector filteredElementCollector = new FilteredElementCollector(project.Document);
            filteredElementCollector.OfClass(typeof(WallType));
            m_wallTypeCollection = filteredElementCollector.Cast<WallType>().ToList<WallType>();

            // Show the dialog for the user select the wall style
            using (CreateWallsUnderBeamsForm displayForm = new CreateWallsUnderBeamsForm(this))
            {
                if (DialogResult.OK != displayForm.ShowDialog())
                {
                    return Autodesk.Revit.UI.Result.Failed;
                }
            }

            // Create the walls which along and under the path of the beams.
            if (!BeginCreate(project.Document))
            {
                message = m_errorInformation;
                return Autodesk.Revit.UI.Result.Failed;
            }

            // If everything goes right, return succeeded.
            return Autodesk.Revit.UI.Result.Succeeded;
        }
      #endregion IExternalCommand Members Implementation

      /// <summary>
      /// Create the walls which along and under the path of the selected beams
      /// </summary>
      /// <param name="project"> A reference of current document</param>
      /// <returns>true if there is no error in process; otherwise, false.</returns>
      Boolean BeginCreate(Autodesk.Revit.DB.Document project)
      {
         // Begin to create walls along and under each beam
         for (int i = 0; i < m_beamCollection.Count; i++)
         {
            // Get each selected beam.
            FamilyInstance m = m_beamCollection[i] as FamilyInstance;
            if (null == m)
            {
               m_errorInformation = "The program should not go here.";
               return false;
            }

            // the wall will be created using beam's model line as path.   
            if (!(m.Location is LocationCurve))
            {
               m_errorInformation = "The beam should have location curve.";
               return false;
            }
            Curve beamCurve = (m.Location as LocationCurve).Curve;

            // Get the level using the beam's reference level
            Autodesk.Revit.DB.ElementId levelId = m.get_Parameter(BuiltInParameter.INSTANCE_REFERENCE_LEVEL_PARAM).AsElementId();
            m_level = project.GetElement(levelId) as Level;
            if (null == m_level)
            {
               m_errorInformation = "The program should not go here.";
               return false;
            }

            Transaction t = new Transaction(project, Guid.NewGuid().GetHashCode().ToString());
            t.Start();
            Wall createdWall = Wall.Create(project, beamCurve, m_selectedWallType.Id,
                                            m_level.Id, 10, 0, true, m_isStructural);
            if (null == createdWall)
            {
               m_errorInformation = "Can not create the walls";
               return false;
            }

            // Modify some parameters of the created wall to make it look better.
            Double offset = beamCurve.GetEndPoint(0).Z - m_level.Elevation;
            createdWall.get_Parameter(BuiltInParameter.WALL_BASE_CONSTRAINT).Set(levelId);
            createdWall.get_Parameter(BuiltInParameter.WALL_BASE_OFFSET).Set(offset - 3000 / 304.8);
            createdWall.get_Parameter(BuiltInParameter.WALL_HEIGHT_TYPE).Set(levelId);
            t.Commit();
         }
         return true;
      }


      /// <summary>
      /// Check whether all the beams have horizontal analytical line 
      /// </summary>
      /// <returns>true if each beam has horizontal analytical line; otherwise, false.</returns>
      Boolean CheckBeamHorizontal()
      {
         for (int i = 0; i < m_beamCollection.Count; i++)
         {
            // Get the analytical curve of each selected beam.
            // And check if Z coordinate of start point and end point of the curve are same.
            FamilyInstance m = m_beamCollection[i] as FamilyInstance;
            Curve beamCurve = m.Location is LocationCurve ? (m.Location as LocationCurve).Curve : null;
            if (null == beamCurve)
            {
               m_errorInformation = "The beam should have location curve.";
               return false;
            }
            else if ((PRECISION <= beamCurve.GetEndPoint(0).Z - beamCurve.GetEndPoint(1).Z)
                || (-PRECISION >= beamCurve.GetEndPoint(0).Z - beamCurve.GetEndPoint(1).Z))
            {
               m_errorInformation = "Please only select horizontal beams.";
               return false;
            }
         }
         return true;
      }
   }
}

=== CODE_BLOCK_0037 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            m_revit = commandData.Application;
            Transaction tran = new Transaction(m_revit.ActiveUIDocument.Document, "CurvedBeam");
            tran.Start();

            // if initialize failed return Result.Failed
            bool initializeOK = Initialize();
            if (!initializeOK)
            {
                return Autodesk.Revit.UI.Result.Failed;
            }

            // pop up new beam form
            CurvedBeamForm displayForm = new CurvedBeamForm(this);
            displayForm.ShowDialog();
            tran.Commit();

            return Autodesk.Revit.UI.Result.Succeeded;
        }
        #endregion


        /// <summary>
        /// iterate all the symbols of levels and beams
        /// </summary>
        /// <returns>A value that signifies if the initialization was successful for true or failed for false</returns>
        private bool Initialize()
        {
            try
            {
                ElementClassFilter levelFilter = new ElementClassFilter(typeof(Level));
                ElementClassFilter famFilter = new ElementClassFilter(typeof(Family));
                LogicalOrFilter orFilter = new LogicalOrFilter(levelFilter, famFilter);
                FilteredElementCollector collector = new FilteredElementCollector(m_revit.ActiveUIDocument.Document);
                FilteredElementIterator i = collector.WherePasses(orFilter).GetElementIterator();
                i.Reset();
                bool moreElement = i.MoveNext();
                while (moreElement)
                {
                    object o = i.Current;

                    // add level to list
                    Level level = o as Level;
                    if (null != level)
                    {
                        m_levels.Add(new LevelMap(level));
                        goto nextLoop;
                    }

                    // get
                    Family f = o as Family;
                    if (null == f)
                    {
                        goto nextLoop;
                    }

                    foreach (ElementId elementId in f.GetFamilySymbolIds())
                    {
                       object symbol = m_revit.ActiveUIDocument.Document.GetElement(elementId);
                        FamilySymbol familyType = symbol as FamilySymbol;
                        if (null == familyType)
                        {
                            goto nextLoop;
                        }
                        if (null == familyType.Category)
                        {
                            goto nextLoop;
                        }

                        // add symbols of beams and braces to lists 
                        string categoryName = familyType.Category.Name;
                        if ("Structural Framing" == categoryName)
                        {
                            m_beamMaps.Add(new SymbolMap(familyType));
                        }
                    }
                nextLoop:
                    moreElement = i.MoveNext();
                }
            }
            catch (Exception ex)
            {
                throw new Exception(ex.ToString());
            }
            return true;
        }

        /// <summary>
        /// create an horizontal arc instance with specified z coordinate value
        /// </summary>
        public Arc CreateArc(double z)
        {
            Autodesk.Revit.DB.XYZ center = new Autodesk.Revit.DB.XYZ(0, 0, z);
            double radius = 20.0;
            double startAngle = 0.0;
            double endAngle = 5.0;
            Autodesk.Revit.DB.XYZ xAxis = new Autodesk.Revit.DB.XYZ(1, 0, 0);
            Autodesk.Revit.DB.XYZ yAxis = new Autodesk.Revit.DB.XYZ(0, 1, 0);
            return Arc.Create(center, radius, startAngle, endAngle, xAxis, yAxis);
        }


        /// <summary>
        /// create a horizontal partial ellipse instance with specified z coordinate value
        /// </summary>
        public Curve CreateEllipse(double z)
        {
            Autodesk.Revit.DB.XYZ center = new Autodesk.Revit.DB.XYZ(0, 0, z);
            double radX = 30;
            double radY = 50;
            Autodesk.Revit.DB.XYZ xVec = new Autodesk.Revit.DB.XYZ(1, 0, 0);
            Autodesk.Revit.DB.XYZ yVec = new Autodesk.Revit.DB.XYZ(0, 1, 0);
            double param0 = 0.0;
            double param1 = 3.1415;
            Curve ellpise = Ellipse.CreateCurve(center, radX, radY, xVec, yVec, param0, param1);
            m_revit.ActiveUIDocument.Document.Regenerate();
            return ellpise;
        }


        /// <summary>
        /// create a horizontal nurbspline instance with specified z coordinate value
        /// </summary>
        public Curve CreateNurbSpline(double z)
        {
            // create control points with same z value
            List<XYZ> ctrPoints = new List<XYZ>();
            Autodesk.Revit.DB.XYZ xyz1 = new Autodesk.Revit.DB.XYZ(-41.887503610431267, -9.0290629129782189, z);
            Autodesk.Revit.DB.XYZ xyz2 = new Autodesk.Revit.DB.XYZ(-9.27600019217055, 0.32213521486563046, z);
            Autodesk.Revit.DB.XYZ xyz3 = new Autodesk.Revit.DB.XYZ(9.27600019217055, 0.32213521486563046, z);
            Autodesk.Revit.DB.XYZ xyz4 = new Autodesk.Revit.DB.XYZ(41.887503610431267, 9.0290629129782189, z);

            ctrPoints.Add(xyz1); ctrPoints.Add(xyz2); ctrPoints.Add(xyz3);
            ctrPoints.Add(xyz4);

            IList<double> weights = new List<double>();
            double w1 = 1, w2 = 1, w3 = 1, w4 = 1;
            weights.Add(w1); weights.Add(w2); weights.Add(w3);
            weights.Add(w4);

            IList<double> knots = new List<double>();
            double k0 = 0, k1 = 0, k2 = 0, k3 = 0, k4 = 34.425128, k5 = 34.425128, k6 = 34.425128, k7 = 34.425128;

            knots.Add(k0); knots.Add(k1); knots.Add(k2); knots.Add(k3);
            knots.Add(k4); knots.Add(k5); knots.Add(k6);
            knots.Add(k7);

            Curve detailNurbSpline = NurbSpline.CreateCurve(3, knots,ctrPoints, weights);
            m_revit.ActiveUIDocument.Document.Regenerate();

            return detailNurbSpline;
        }


        /// <summary>
        /// create a curved beam
        /// </summary>
        /// <param name="fsBeam">beam type</param>
        /// <param name="curve">Curve of this beam.</param>
        /// <param name="level">beam's reference level</param>
        /// <returns></returns>
        public bool CreateCurvedBeam(FamilySymbol fsBeam, Curve curve, Level level)
        {
            FamilyInstance beam;
            try
            {
               if (!fsBeam.IsActive)
                  fsBeam.Activate();
                beam = m_revit.ActiveUIDocument.Document.Create.NewFamilyInstance(curve, fsBeam, level, StructuralType.Beam);
                if (null == beam)
                {
                    return false;
                }

                // get beam location curve
                LocationCurve beamCurve = beam.Location as LocationCurve;
                if (null == beamCurve)
                {
                    return false;
                }
            }
            catch (Exception ex)
            {
                TaskDialog.Show("Revit", ex.ToString());
                return false;
            }

            // regenerate document
            m_revit.ActiveUIDocument.Document.Regenerate();
            return true;
        }
    }


    /// <summary>
    /// assistant class contains symbol and it's name
    /// </summary>
    public class SymbolMap
    {
        #region SymbolMap class member variables
        string m_symbolName = "";
        FamilySymbol m_symbol = null;
        #endregion


        /// <summary>
        /// constructor without parameter is forbidden
        /// </summary>
        private SymbolMap()
        {
            // no operation 
        }


        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="symbol">family symbol</param>
        public SymbolMap(FamilySymbol symbol)
        {
            m_symbol = symbol;
            string familyName = "";
            if (null != symbol.Family)
            {
                familyName = symbol.Family.Name;
            }
            m_symbolName = familyName + " : " + symbol.Name;
        }


        /// <summary>
        /// SymbolName property
        /// </summary>
        public string SymbolName
        {
            get
            {
                return m_symbolName;
            }
        }


        /// <summary>
        /// ElementType property
        /// </summary>
        public FamilySymbol ElementType
        {
            get
            {
                return m_symbol;
            }
        }
    }


    /// <summary>
    /// assistant class contains level and it's name
    /// </summary>
    public class LevelMap
    {
        #region LevelMap class member variable
        string m_levelName = "";
        Level m_level = null;
        #endregion


        #region LevelMap Constructors
        /// <summary>
        /// constructor without parameter is forbidden
        /// </summary>
        private LevelMap()
        {
            // no operation
        }


        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="level">level</param>
        public LevelMap(Level level)
        {
            m_level = level;
            m_levelName = level.Name;
        }
        #endregion


        #region LevelMap properties
        /// <summary>
        /// LevelName property
        /// </summary>
        public string LevelName
        {
            get
            {
                return m_levelName;
            }
        }

        /// <summary>
        /// Level property
        /// </summary>
        public Level Level
        {
            get
            {
                return m_level;
            }
        }
        #endregion
    }
}

=== CODE_BLOCK_0039 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
                                               ref string message,
                                               ElementSet elements)
        {
            // Get the application of revit
            Autodesk.Revit.UI.UIApplication revit = commandData.Application;
            m_document = revit.ActiveUIDocument.Document;

            try
            {
               ElementSet elementSet = new ElementSet();
               foreach (ElementId elementId in revit.ActiveUIDocument.Selection.GetElementIds())
               {
                  elementSet.Insert(revit.ActiveUIDocument.Document.GetElement(elementId));
               }
                if (elementSet.IsEmpty)
                {
                    TaskDialog.Show("Select", "Please select one floor or slab at least.");
                    return Autodesk.Revit.UI.Result.Cancelled;
                }
                using (m_displayForm = new DeckPropertyForm())
                {
                    List<Floor> floorList = new List<Floor>();
                    foreach (ElementId elementId in revit.ActiveUIDocument.Selection.GetElementIds())
                    {
                       Element element = revit.ActiveUIDocument.Document.GetElement(elementId);
                        Floor floor = element as Floor;
                        if (floor != null)
                        {
                            floorList.Add(floor);
                        }
                    }

                    if (floorList.Count <= 0)
                    {
                        TaskDialog.Show("Select", "Please select one floor or slab at least.");
                        return Autodesk.Revit.UI.Result.Cancelled;
                    }

                    foreach (Floor floor in floorList)
                    {
                        DumpSlab(floor);
                    }
                    m_displayForm.ShowDialog();
                }
            }
            catch (Exception ex)
            {
                // If any error, store error information in message and return failed
                message = ex.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
            // If everything goes well, return succeeded.
            return Autodesk.Revit.UI.Result.Succeeded;
        }

        /// <summary>
        /// Dump the properties of interest for the slab passed as a parameter
        /// </summary>
        /// <param name="slab"></param>
        private void DumpSlab(Floor slab)
        {
            m_displayForm.WriteLine("Dumping Slab" + slab.Id.ToString());

            Autodesk.Revit.DB.FloorType slabType = slab.FloorType;

            if (slabType != null)
            {
                foreach (CompoundStructureLayer layer in slabType.GetCompoundStructure().GetLayers())
                {
                    if (layer.Function == MaterialFunctionAssignment.StructuralDeck)
                    {
                        DumbDeck(layer);
                    }
                    else
                    {
                        DumpLayer(layer);
                    }
                }
            }

            m_displayForm.WriteLine(" ");
        }

        /// <summary>
        /// Dump properties specific to a decking layer
        /// </summary>
        /// <param name="deck"></param>
        private void DumbDeck(CompoundStructureLayer deck)
        {
            m_displayForm.WriteLine("Dumping Deck");

            if (deck.MaterialId != ElementId.InvalidElementId)
            {
                // get the deck material object. In this sample all we need to display is the
                // name, but other properties are readily available from the material object.
                Autodesk.Revit.DB.Material deckMaterial = m_document.GetElement(deck.MaterialId) as Material;
                m_displayForm.WriteLine("Deck Material = " + deckMaterial.Name);
            }

            if (deck.DeckProfileId != ElementId.InvalidElementId)
            {
                // the deck profile is actually a family symbol from a family of profiles
                Autodesk.Revit.DB.FamilySymbol deckProfile = m_document.GetElement(deck.DeckProfileId) as FamilySymbol;

                // firstly display the full name as the user would see it in the user interface
                // this is done in the format Family.Name and then Symbol.Name
                m_displayForm.WriteLine("Deck Profile = "
                    + deckProfile.Family.Name + " : " + deckProfile.Name);

                // the symbol object also contains parameters that describe how the deck is
                // specified. From these parameters an external application can generate
                // identical decking for analysis purposes
                DumpParameters(deckProfile);
            }
        }

        /// <summary>
        /// A generic parameter display method that displays all the parameters of an element
        /// </summary>
        /// <param name="element"></param>
        private void DumpParameters(Element element)
        {
            foreach (Parameter parameter in element.Parameters)
            {
                string value = "";
                switch (parameter.StorageType)
                {
                    case Autodesk.Revit.DB.StorageType.Double:
                        value = parameter.AsDouble().ToString();
                        break;
                    case Autodesk.Revit.DB.StorageType.ElementId:
                        value = parameter.AsElementId().ToString();
                        break;
                    case Autodesk.Revit.DB.StorageType.String:
                        value = parameter.AsString();
                        break;
                    case Autodesk.Revit.DB.StorageType.Integer:
                        value = parameter.AsInteger().ToString();
                        break;
                }

                m_displayForm.WriteLine(parameter.Definition.Name + " = " + value);
            }
        }

        /// <summary>
        /// for non deck layers this method is called and it displays minimal information
        /// about the layer
        /// </summary>
        /// <param name="layer"></param>
        private void DumpLayer(CompoundStructureLayer layer)
        {
            // Display the name of the material. More detailed material properties can
            // be found form the material object
            m_displayForm.WriteLine("Dumping Layer");
            Autodesk.Revit.DB.Material material = m_document.GetElement(layer.MaterialId) as Material;
            if (material != null)
            {
                m_displayForm.WriteLine("Layer material = " + material.Name);
            }

            // display the thickness of the layer in inches.
            m_displayForm.WriteLine("Layer Thickness = " + layer.Width.ToString());
        }
    }
}

=== CODE_BLOCK_0041 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
          ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         ElementSet selections = new ElementSet();
         foreach (ElementId elementId in commandData.Application.ActiveUIDocument.Selection.GetElementIds())
         {
            selections.Insert(commandData.Application.ActiveUIDocument.Document.GetElement(elementId));
         }
         ElementSet dimsToDelete = new Autodesk.Revit.DB.ElementSet();

         //warning if nothing selected
         if (0 == selections.Size)
         {
            message = "Please select dimensions";
            return Autodesk.Revit.UI.Result.Failed;
         }

         //find all unpinned dimensions in the current selection 
         foreach (Element e in selections)
         {
            Dimension dimesionTemp = e as Dimension;
            if (null != dimesionTemp && !dimesionTemp.Pinned)
            {
               dimsToDelete.Insert(dimesionTemp);
            }
         }

         //warning if could not find any unpinned dimension
         if (0 == dimsToDelete.Size)
         {
            message = "There are no unpinned dimensions currently selected";
            return Autodesk.Revit.UI.Result.Failed;
         }

         Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "External Tool");

         transaction.Start();
         //delete all the unpinned dimensions
         foreach (Element e in dimsToDelete)
         {
             commandData.Application.ActiveUIDocument.Document.Delete(e.Id);
         }

         transaction.Commit();
         return Autodesk.Revit.UI.Result.Succeeded;
      }
   }
}

=== CODE_BLOCK_0043 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, 
                                             ref string message, 
                                             ElementSet elements)
      {
         Autodesk.Revit.UI.Result returnCode = Autodesk.Revit.UI.Result.Cancelled;  

         Transaction tran = new Transaction(commandData.Application.ActiveUIDocument.Document, "Initialize Command");
         tran.Start();

         try
         {
            // one instance of DoorSwingData class.
            DoorSwingData databuffer = new DoorSwingData(commandData.Application);
   
            using (InitializeForm initForm = new InitializeForm(databuffer))
            {
               // Show UI
               DialogResult dialogResult = initForm.ShowDialog();

               if (DialogResult.OK == dialogResult)
               {
                  databuffer.DeleteTempDoorInstances();

                  // update door type's opening feature based on family's actual geometry and 
                  // country's standard.
                  databuffer.UpdateDoorFamiliesOpeningFeature();

                  // update each door instance's Opening feature and internal door flag
                  returnCode = DoorSwingData.UpdateDoorsInfo(commandData.Application.ActiveUIDocument.Document, false, true, ref message);
               }
            }
         }
         catch (Exception ex)
         {
            // if there is anything wrong, give error information and return failed.
            message    = ex.Message;
            returnCode = Autodesk.Revit.UI.Result.Failed;
         }

         if (Autodesk.Revit.UI.Result.Succeeded == returnCode)
         {
            tran.Commit();
         }
         else
         {
            tran.RollBack();
         }
         return returnCode;
      }

      #endregion
   }

   /// <summary>
   /// A ExternalCommand class inherited IExternalCommand interface.
   /// This command will update each door instance's opening, ToRoom, FromRoom and 
   /// internal door flag values according to door's current geometry.
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class UpdateParamsCommand : IExternalCommand
   {
      #region IExternalCommand Members

      /// <summary>
      /// Implement this method as an external command for Revit.
      /// </summary>
      /// <param name="commandData">An object that is passed to the external application 
      /// which contains data related to the command, 
      /// such as the application object and active view.</param>
      /// <param name="message">A message that can be set by the external application 
      /// which will be displayed if a failure or cancellation is returned by 
      /// the external command.</param>
      /// <param name="elements">A set of elements to which the external application 
      /// can add elements that are to be highlighted in case of failure or cancellation.</param>
      /// <returns>Return the status of the external command. 
      /// A result of Succeeded means that the API external method functioned as expected. 
      /// Cancelled can be used to signify that the user cancelled the external operation 
      /// at some point. Failure should be returned if the application is unable to proceed with 
      /// the operation.</returns>
      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         Autodesk.Revit.UI.Result returnCode = Autodesk.Revit.UI.Result.Succeeded;
         Autodesk.Revit.UI.UIApplication app = commandData.Application;
         UIDocument doc = app.ActiveUIDocument;
         Transaction tran = new Transaction(doc.Document, "Update Parameters Command");
         tran.Start();

         try
         {
            ElementSet elementSet = new ElementSet();
            foreach (ElementId elementId in doc.Selection.GetElementIds())
            {
               elementSet.Insert(doc.Document.GetElement(elementId));
            }
            if (elementSet.IsEmpty)
            {
               returnCode = DoorSwingData.UpdateDoorsInfo(doc.Document, false, true, ref message);
            }
            else
            {
               returnCode = DoorSwingData.UpdateDoorsInfo(doc.Document, true, true, ref message);
            }
         }
         catch (Exception ex)
         {
            // if there is anything wrong, give error information and return failed.
            message = ex.Message;
            returnCode = Autodesk.Revit.UI.Result.Failed;
         }

         if (Autodesk.Revit.UI.Result.Succeeded == returnCode)
         {
            tran.Commit();
         }
         else
         {
            tran.RollBack();
         }
         return returnCode;
      }

      #endregion
   }

   /// <summary>
   /// A ExternalCommand class inherited IExternalCommand interface.
   /// This command will update door instance's geometry according to door's 
   /// current To/From Room value.
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class UpdateGeometryCommand : IExternalCommand
   {
      #region IExternalCommand Members

      /// <summary>
      /// Implement this method as an external command for Revit.
      /// </summary>
      /// <param name="commandData">An object that is passed to the external application 
      /// which contains data related to the command, 
      /// such as the application object and active view.</param>
      /// <param name="message">A message that can be set by the external application 
      /// which will be displayed if a failure or cancellation is returned by 
      /// the external command.</param>
      /// <param name="elements">A set of elements to which the external application 
      /// can add elements that are to be highlighted in case of failure or cancellation.</param>
      /// <returns>Return the status of the external command. 
      /// A result of Succeeded means that the API external method functioned as expected. 
      /// Cancelled can be used to signify that the user cancelled the external operation 
      /// at some point. Failure should be returned if the application is unable to proceed with 
      /// the operation.</returns>
      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         Autodesk.Revit.UI.Result returnCode = Autodesk.Revit.UI.Result.Succeeded;
         Autodesk.Revit.UI.UIApplication app = commandData.Application;
         UIDocument doc = app.ActiveUIDocument;
         Transaction tran = new Transaction(doc.Document, "Update Geometry Command");
         tran.Start();

         try
         {
            ElementSet elementSet = new ElementSet();
            foreach (ElementId elementId in doc.Selection.GetElementIds())
            {
               elementSet.Insert(doc.Document.GetElement(elementId));
            }
            if (elementSet.IsEmpty)
            {
               DoorSwingData.UpdateDoorsGeometry(doc.Document, false);
            }
            else
            {
               DoorSwingData.UpdateDoorsGeometry(doc.Document, true);
            }

            returnCode =  Autodesk.Revit.UI.Result.Succeeded;
         }
         catch (Exception ex)
         {
            // if there is anything wrong, give error information and return failed.
            message = ex.Message;
            returnCode = Autodesk.Revit.UI.Result.Failed;
         }

         if (Autodesk.Revit.UI.Result.Succeeded == returnCode)
         {
            tran.Commit();
         }
         else
         {
            tran.RollBack();
         }

         return returnCode;
      }

      #endregion
   }
}

=== CODE_BLOCK_0045 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
                                               ref string message, ElementSet elements)
        {
            try
            {
                // create a form to display the information of view filters
                using (ViewFiltersForm infoForm = new ViewFiltersForm(commandData))
                {
                    infoForm.ShowDialog();
                }
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception ex)
            {
                // If there is something wrong, give error information and return failed
                message = ex.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
    }
}

=== CODE_BLOCK_0047 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
      ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         m_revitApp = commandData.Application.Application;
         m_doc = commandData.Application.ActiveUIDocument.Document;

         Level level1 = GetLevel();
         if (level1 == null)
         {
            throw new Exception("[ERROR] Failed to get level 1");
         }

         try
         {
            //
            // Post a warning and resolve it in FailurePreproccessor
            try
            {
               Transaction transaction = new Transaction(m_doc, "Warning_FailurePreproccessor");
               FailureHandlingOptions options = transaction.GetFailureHandlingOptions();
               FailurePreproccessor preproccessor = new FailurePreproccessor();
               options.SetFailuresPreprocessor(preproccessor);
               transaction.SetFailureHandlingOptions(options);
               transaction.Start();
               FailureMessage fm = new FailureMessage(m_idWarning);
               m_doc.PostFailure(fm);
               transaction.Commit();
            }
            catch (System.Exception)
            {
               message = "Failed to commit transaction Warning_FailurePreproccessor";
               return Result.Failed;
            }

            //
            // Dismiss the overlapped wall warning in FailurePreproccessor
            try
            {
               Transaction transaction = new Transaction(m_doc, "Warning_FailurePreproccessor_OverlappedWall");
               FailureHandlingOptions options = transaction.GetFailureHandlingOptions();
               FailurePreproccessor preproccessor = new FailurePreproccessor();
               options.SetFailuresPreprocessor(preproccessor);
               transaction.SetFailureHandlingOptions(options);
               transaction.Start();

               Line line = Line.CreateBound(new XYZ(-10, 0, 0), new XYZ(-20, 0, 0));
               Wall wall1 = Wall.Create(m_doc, line, level1.Id, false);
               Wall wall2 = Wall.Create(m_doc, line, level1.Id, false);
               m_doc.Regenerate();

               transaction.Commit();
            }
            catch (System.Exception)
            {
               message = "Failed to commit transaction Warning_FailurePreproccessor_OverlappedWall";
               return Result.Failed;
            }

            //
            // Post an error and resolve it in FailuresProcessingEvent
            try
            {
               m_revitApp.FailuresProcessing += new EventHandler<Autodesk.Revit.DB.Events.FailuresProcessingEventArgs>(FailuresProcessing);
               Transaction transaction = new Transaction(m_doc, "Error_FailuresProcessingEvent");
               transaction.Start();

               Line line = Line.CreateBound(new XYZ(0, 10, 0), new XYZ(20, 10, 0));
               Wall wall = Wall.Create(m_doc, line, level1.Id, false);
               m_doc.Regenerate();

               FailureMessage fm = new FailureMessage(m_idError);
               FailureResolution fr = DeleteElements.Create(m_doc, wall.Id);
               fm.AddResolution(FailureResolutionType.DeleteElements, fr);
               m_doc.PostFailure(fm);
               transaction.Commit();
            }
            catch (System.Exception)
            {
               message = "Failed to commit transaction Error_FailuresProcessingEvent";
               return Result.Failed;
            }

            //
            // Post an error and resolve it in FailuresProcessor
            try
            {
               FailuresProcessor processor = new FailuresProcessor();
               Application.RegisterFailuresProcessor(processor);
               Transaction transaction = new Transaction(m_doc, "Error_FailuresProcessor");
               transaction.Start();

               Line line = Line.CreateBound(new XYZ(0, 20, 0), new XYZ(20, 20, 0));
               Wall wall = Wall.Create(m_doc, line, level1.Id, false);
               m_doc.Regenerate();

               FailureMessage fm = new FailureMessage(m_idError);
               FailureResolution fr = DeleteElements.Create(m_doc, wall.Id);
               fm.AddResolution(FailureResolutionType.DeleteElements, fr);
               m_doc.PostFailure(fm);
               transaction.Commit();
            }
            catch (System.Exception)
            {
               message = "Failed to commit transaction Error_FailuresProcessor";
               return Result.Failed;
            }
         }
         catch (Exception ex)
         {
            message = ex.Message;
            return Result.Failed;
         }

         return Result.Succeeded;
      }

      /// <summary>
      /// Implements the FailuresProcessing event
      /// </summary>
      /// <param name="sender"></param>
      /// <param name="e"></param>
      private void FailuresProcessing(object sender, Autodesk.Revit.DB.Events.FailuresProcessingEventArgs e)
      {
         FailuresAccessor failuresAccessor = e.GetFailuresAccessor();
         //failuresAccessor
         String transactionName = failuresAccessor.GetTransactionName();

         IList<FailureMessageAccessor> fmas = failuresAccessor.GetFailureMessages();
         if (fmas.Count == 0)
         {
            e.SetProcessingResult(FailureProcessingResult.Continue);
            return;
         }

         if (transactionName.Equals("Error_FailuresProcessingEvent"))
         {
            foreach (FailureMessageAccessor fma in fmas)
            {
               FailureDefinitionId id = fma.GetFailureDefinitionId();
               if (id == Command.m_idError)
               {
                  failuresAccessor.ResolveFailure(fma);
               }
            }

            e.SetProcessingResult(FailureProcessingResult.ProceedWithCommit);
            return;
         }

         e.SetProcessingResult(FailureProcessingResult.Continue);
      }

      /// <summary>
      /// Gets the level named "Level 1"
      /// </summary>
      /// <returns></returns>
      private Level GetLevel()
      {
         Level level1 = null;

         FilteredElementCollector collector = new FilteredElementCollector(m_doc);
         ElementClassFilter filter = new ElementClassFilter(typeof(Level));
         IList<Element> levels = collector.WherePasses(filter).ToElements();

         foreach (Level level in levels)
         {
            if (level.Name.Equals("Level 1"))
            {
               level1 = level;
               break;
            }
         }

         return level1;
      }
      #endregion
   }

   /// <summary>
   /// Implements the interface IFailuresPreprocessor
   /// </summary>
   public class FailurePreproccessor : IFailuresPreprocessor
   {
      /// <summary>
      /// This method is called when there have been failures found at the end of a transaction and Revit is about to start processing them. 
      /// </summary>
      /// <param name="failuresAccessor">The Interface class that provides access to the failure information. </param>
      /// <returns></returns>
      public FailureProcessingResult PreprocessFailures(FailuresAccessor failuresAccessor)
      {
         IList<FailureMessageAccessor> fmas = failuresAccessor.GetFailureMessages();
         if (fmas.Count == 0)
         {
            return FailureProcessingResult.Continue;
         }

         String transactionName = failuresAccessor.GetTransactionName();
         if (transactionName.Equals("Warning_FailurePreproccessor"))
         {
            foreach (FailureMessageAccessor fma in fmas)
            {
               FailureDefinitionId id = fma.GetFailureDefinitionId();
               if (id == Command.m_idWarning)
               {
                  failuresAccessor.DeleteWarning(fma);
               }
            }

            return FailureProcessingResult.ProceedWithCommit;
         }
         else if (transactionName.Equals("Warning_FailurePreproccessor_OverlappedWall"))
         {
            foreach (FailureMessageAccessor fma in fmas)
            {
               FailureDefinitionId id = fma.GetFailureDefinitionId();
               if (id == BuiltInFailures.OverlapFailures.WallsOverlap)
               {
                  failuresAccessor.DeleteWarning(fma);
               }
            }

            return FailureProcessingResult.ProceedWithCommit;
         }
         else
         {
            return FailureProcessingResult.Continue;
         }
      }
   }

   /// <summary>
   /// Implements the interface IFailuresProcessor
   /// </summary>
   public class FailuresProcessor : IFailuresProcessor
   {
      /// <summary>
      /// This method is being called in case of exception or document destruction to dismiss any possible pending failure UI that may have left on the screen 
      /// </summary>
      /// <param name="document">Document for which pending failures processing UI should be dismissed </param>
      public void Dismiss(Document document)
      {
      }

      /// <summary>
      /// Method that Revit will invoke to process failures at the end of transaction. 
      /// </summary>
      /// <param name="failuresAccessor">Provides all necessary data to perform the resolution of failures.</param>
      /// <returns></returns>
      public FailureProcessingResult ProcessFailures(FailuresAccessor failuresAccessor)
      {
         IList<FailureMessageAccessor> fmas = failuresAccessor.GetFailureMessages();
         if (fmas.Count == 0)
         {
            return FailureProcessingResult.Continue;
         }

         String transactionName = failuresAccessor.GetTransactionName();
         if (transactionName.Equals("Error_FailuresProcessor"))
         {
            foreach (FailureMessageAccessor fma in fmas)
            {
               FailureDefinitionId id = fma.GetFailureDefinitionId();
               if (id == Command.m_idError)
               {
                  failuresAccessor.ResolveFailure(fma);
               }
            }
            return FailureProcessingResult.ProceedWithCommit;
         }
         else
         {
            return FailureProcessingResult.Continue;
         }
      }
   }

}

=== CODE_BLOCK_0049 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                       ref string message,
                                       ElementSet elements)
        {

            IDictionary<string, string> journaldata = commandData.JournalData;

        // These #if directives within file are used to compile project in different purpose:
        // . Build project with Release mode for regression test,
        // . Build project with Debug mode for manual run
#if !(Debug || DEBUG)
            // playing journal.
            if (ExternalApplication.JnlProcessor.IsReplay)
            {
                ExternalApplication.ApplicationEvents = ExternalApplication.JnlProcessor.GetEventsListFromJournalData(journaldata);

            }

            // running the sample form UI.
            else
            {
#endif

            ExternalApplication.SettingDialog.ShowDialog();
                if (DialogResult.OK == ExternalApplication.SettingDialog.DialogResult)
                {
                    // get what user select.
                    ExternalApplication.ApplicationEvents = ExternalApplication.SettingDialog.AppSelectionList;
                                        
#if !(Debug || DEBUG)
                    // dump what user select to a file in order to autotesting.
                    ExternalApplication.JnlProcessor.DumpEventListToJournalData(ExternalApplication.ApplicationEvents, ref journaldata);
#endif
                }
#if !(Debug || DEBUG)
            }
#endif
                // update the events according to the selection.
                ExternalApplication.AppEventMgr.Update(ExternalApplication.ApplicationEvents);

                // track the selected events by showing the information in the information windows.
                ExternalApplication.InfoWindows.Show();


                return Autodesk.Revit.UI.Result.Succeeded;
        }
        #endregion
    }
}

=== CODE_BLOCK_0051 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                     ref string message,
                                     ElementSet elements)
      {
         // track the selected events by showing the information in the information windows.
         if(SelectionChanged.InfoWindow == null)
         {
            SelectionChanged.InfoWindow = new InfoWindow();
            SelectionChanged.InfoWindow.Show();
         }
         else
         {
            SelectionChanged.InfoWindow.Focus();
         }
         


         return Autodesk.Revit.UI.Result.Succeeded;
      }
      #endregion
   }
}

=== CODE_BLOCK_0053 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                             ref string message,
                                             ElementSet elements)
      {
         m_app = commandData.Application;
         MessageManager.MessageBuff = new StringBuilder();

         try
         {
            bool succeeded = AddParameters();

            if (succeeded)
            {
               return Autodesk.Revit.UI.Result.Succeeded;
            }
            else
            {
               message = MessageManager.MessageBuff.ToString();
               return Autodesk.Revit.UI.Result.Failed;
            }
         }
         catch (Exception e)
         {
            message = e.Message;
            return Autodesk.Revit.UI.Result.Failed;
         }
      }

      /// <summary>
      /// add parameters to the active document
      /// </summary>
      /// <returns>
      /// if succeeded, return true; otherwise false
      /// </returns>
      private bool AddParameters()
      {
         Document doc = m_app.ActiveUIDocument.Document;
         if (null == doc)
         {
            MessageManager.MessageBuff.Append("There's no available document. \n");
            return false;
         }

         if (!doc.IsFamilyDocument)
         {
            MessageManager.MessageBuff.Append("The active document is not a family document. \n");
            return false;
         }

         FamilyParameterAssigner assigner = new FamilyParameterAssigner(m_app.Application, doc);
         // the parameters to be added are defined and recorded in a text file, read them from that file and load to memory
         bool succeeded = assigner.LoadParametersFromFile();
         if (!succeeded)
         {
            return false;
         }

         Transaction t = new Transaction(doc, Guid.NewGuid().GetHashCode().ToString());
         t.Start();
         succeeded = assigner.AddParameters();
         if (succeeded)
         {
            t.Commit();
            return true;
         }
         else
         {
            t.RollBack();
            return false;
         }
      }
   } // end of class "AddParameterToFamily"

   /// <summary>
   /// A class inherits IExternalCommand interface.
   /// this class read parameter data from txt files and add them to the family files in a folder.
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   [Autodesk.Revit.Attributes.Journaling(Autodesk.Revit.Attributes.JournalingMode.NoCommandData)]
   public class AddParameterToFamilies : IExternalCommand
   {
      // the active Revit application
      private Autodesk.Revit.ApplicationServices.Application m_app;

      /// <summary>
      /// Implement this method as an external command for Revit.
      /// </summary>
      /// <param name="commandData">An object that is passed to the external application 
      /// which contains data related to the command, 
      /// such as the application object and active view.</param>
      /// <param name="message">A message that can be set by the external application 
      /// which will be displayed if a failure or cancellation is returned by 
      /// the external command.</param>
      /// <param name="elements">A set of elements to which the external application 
      /// can add elements that are to be highlighted in case of failure or cancellation.</param>
      /// <returns>Return the status of the external command. 
      /// A result of Succeeded means that the API external method functioned as expected. 
      /// Cancelled can be used to signify that the user cancelled the external operation 
      /// at some point. Failure should be returned if the application is unable to proceed with 
      /// the operation.</returns>
      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                             ref string message,
                                             ElementSet elements)
      {
         m_app = commandData.Application.Application;
         MessageManager.MessageBuff = new StringBuilder();

         try
         {
            bool succeeded = LoadFamiliesAndAddParameters();

            if (succeeded)
            {
               return Autodesk.Revit.UI.Result.Succeeded;
            }
            else
            {
               message = MessageManager.MessageBuff.ToString();
               return Autodesk.Revit.UI.Result.Failed;
            }
         }
         catch (Exception e)
         {
            message = e.Message;
            return Autodesk.Revit.UI.Result.Failed;
         }
      }

      /// <summary>
      /// search for the family files and the corresponding parameter records
      /// load each family file, add parameters and then save and close.
      /// </summary>
      /// <returns>
      /// if succeeded, return true; otherwise false
      /// </returns>
      private bool LoadFamiliesAndAddParameters()
      {
         bool succeeded = true;

         List<string> famFilePaths = new List<string>();

         Environment.SpecialFolder myDocumentsFolder = Environment.SpecialFolder.MyDocuments;
         string myDocs = Environment.GetFolderPath(myDocumentsFolder);
         string families = myDocs + "\\AutoParameter_Families";
         if (!Directory.Exists(families))
         {
            MessageManager.MessageBuff.Append("The folder [AutoParameter_Families] doesn't exist in [MyDocuments] folder.\n");
         }
         DirectoryInfo familiesDir = new DirectoryInfo(families);
         FileInfo[] files = familiesDir.GetFiles("*.rfa");
         if (0 == files.Length)
         {
            MessageManager.MessageBuff.Append("No family file exists in [AutoParameter_Families] folder.\n");
         }
         foreach (FileInfo info in files)
         {
            if (info.IsReadOnly)
            {
               MessageManager.MessageBuff.Append("Family file: \"" + info.FullName + "\" is read only. Can not add parameters to it.\n");
               continue;
            }

            string famFilePath = info.FullName;
            Document doc = m_app.OpenDocumentFile(famFilePath);

            if (!doc.IsFamilyDocument)
            {
               succeeded = false;
               MessageManager.MessageBuff.Append("Document: \"" + famFilePath + "\" is not a family document.\n");
               continue;
            }
            
            // return and report the errors
            if (!succeeded)
            {
               return false;
            }

            FamilyParameterAssigner assigner = new FamilyParameterAssigner(m_app, doc);
            // the parameters to be added are defined and recorded in a text file, read them from that file and load to memory
            succeeded = assigner.LoadParametersFromFile();
            if (!succeeded)
            {
               MessageManager.MessageBuff.Append("Failed to load parameters from parameter files.\n");
               return false;
            }
            Transaction t = new Transaction(doc, Guid.NewGuid().GetHashCode().ToString());
            t.Start();
            succeeded = assigner.AddParameters();
            if (succeeded)
            {
               t.Commit();
               doc.Save();
               doc.Close();
            }
            else
            {
               t.RollBack();
               doc.Close();
               MessageManager.MessageBuff.Append("Failed to add parameters to " + famFilePath + ".\n");
               return false;
            }
         }
         return true;
      }
   } // end of class "AddParameterToFamilies"

   /// <summary>
   /// store the warning/error messeges when executing the sample
   /// </summary>
   static class MessageManager
   {
      static StringBuilder m_messageBuff = new StringBuilder();
      /// <summary>
      /// store the warning/error messages
      /// </summary>
      public static StringBuilder MessageBuff
      {
         get 
         { 
            return m_messageBuff; 
         }
         set 
         { 
            m_messageBuff = value; 
         }
      }
   }
}

=== CODE_BLOCK_0055 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message,
          ElementSet elements)
      {
         // set out default result to failure.
         Autodesk.Revit.UI.Result retRes = Autodesk.Revit.UI.Result.Failed;
         m_application = commandData.Application.Application;
         m_document = commandData.Application.ActiveUIDocument.Document;
         f = m_document.FamilyCreate;
         extrusions = new Extrusion[5];
         m_combineElements = new CombinableElementArray();

         m_transaction = new Transaction(m_document, "External Tool");
         m_transaction.Start();

         if (m_document.OwnerFamily.FamilyCategory.Name !=
             m_document.Settings.Categories.get_Item(BuiltInCategory.OST_MechanicalEquipment).Name) // FamilyCategory.Name is not "Mechanical Equipment".
         {
            message = "Please make sure you opened a template of Mechanical Equipment.";
            return retRes;
         }

         try
         {
            CreateExtrusions();
            m_document.Regenerate();
            CreateConnectors();
            m_document.Regenerate();
            m_document.CombineElements(m_combineElements);
            m_document.Regenerate();
         }
         catch (Exception x)
         {
            m_transaction.RollBack();
            message = x.Message;
            return retRes;
         }

         m_transaction.Commit();

         retRes = Autodesk.Revit.UI.Result.Succeeded;
         return retRes;
      }
      #endregion

      /// <summary>
      /// get all planar faces of an extrusion
      /// </summary>
      /// <param name="extrusion">the extrusion to read</param>
      /// <returns>a list of all planar faces of the extrusion</returns>
      public List<PlanarFace> GetPlanarFaces(Extrusion extrusion)
      {
         // the option to get geometry elements
         Options m_geoOptions = m_application.Create.NewGeometryOptions();
         m_geoOptions.View = m_document.ActiveView;
         m_geoOptions.ComputeReferences = true;

         // get the planar faces
         List<PlanarFace> m_planarFaces = new List<PlanarFace>();
         Autodesk.Revit.DB.GeometryElement geoElement = extrusion.get_Geometry(m_geoOptions);
         //foreach (GeometryObject geoObject in geoElement.Objects)
         IEnumerator<GeometryObject> Objects = geoElement.GetEnumerator();
         while (Objects.MoveNext())
         {
            GeometryObject geoObject = Objects.Current;

            Solid geoSolid = geoObject as Solid;
            if (null == geoSolid)
            {
               continue;
            }
            foreach (Face geoFace in geoSolid.Faces)
            {
               if (geoFace is PlanarFace)
               {
                  m_planarFaces.Add(geoFace as PlanarFace);
               }
            }
         }
         return m_planarFaces;
      }

      /// <summary>
      /// create the extrusions of the air handler system
      /// </summary>
      private void CreateExtrusions()
      {
         Autodesk.Revit.Creation.Application app = m_application.Create;
         CurveArray curves = null;
         CurveArrArray profile = null;
         Plane plane = null;
         SketchPlane sketchPlane = null;

         #region Create the cuboid extrusions

         for (int i = 0; i <= 2; ++i)
         {
            // create the profile
            curves = app.NewCurveArray();
            curves.Append(Line.CreateBound(profileData[i, 0], profileData[i, 1]));
            curves.Append(Line.CreateBound(profileData[i, 1], profileData[i, 2]));
            curves.Append(Line.CreateBound(profileData[i, 2], profileData[i, 3]));
            curves.Append(Line.CreateBound(profileData[i, 3], profileData[i, 0]));
            profile = app.NewCurveArrArray();
            profile.Append(curves);

            // create the sketch plane
            plane = Plane.CreateByNormalAndOrigin(sketchPlaneData[i, 0], sketchPlaneData[i, 1]);
            sketchPlane = SketchPlane.Create(m_document, plane);

            // create the extrusion
            extrusions[i] = f.NewExtrusion(isSolid[i], profile, sketchPlane,
                extrusionOffsets[i, 1]);
            extrusions[i].StartOffset = extrusionOffsets[i, 0];
            m_combineElements.Append(extrusions[i]);
         }

         #endregion

         #region Create the round extrusions

         for (int i = 3; i <= 4; ++i)
         {
            // create the profile
            profile = app.NewCurveArrArray();

            curves = app.NewCurveArray();
            plane = Plane.CreateByNormalAndOrigin(profileData[i, 0], profileData[i, 1]);
            curves.Append(Arc.Create(plane, arcRadius, 0, Math.PI * 2));
            profile.Append(curves);

                // create the sketch plane
            plane = Plane.CreateByNormalAndOrigin(sketchPlaneData[i, 0], sketchPlaneData[i, 1]);
            sketchPlane = SketchPlane.Create(m_document, plane);

            // create the extrusion
            extrusions[i] = f.NewExtrusion(isSolid[i], profile, sketchPlane,
                extrusionOffsets[i, 1]);
            extrusions[i].StartOffset = extrusionOffsets[i, 0];
            m_combineElements.Append(extrusions[i]);
         }

         #endregion
      }

      /// <summary>
      /// create the connectors on the extrusions
      /// </summary>
      private void CreateConnectors()
      {
         List<PlanarFace> m_planarFaces = null;
         Parameter param = null;

         #region Create the Supply Air duct connector

         // get the planar faces of extrusion1
         m_planarFaces = GetPlanarFaces(extrusions[1]);

         // create the Supply Air duct connector
         //DuctConnector connSupplyAir = f.NewDuctConnector(m_planarFaces[0].Reference,
         //    DuctSystemType.SupplyAir);
         ConnectorElement connSupplyAir = ConnectorElement.CreateDuctConnector(m_document, DuctSystemType.SupplyAir, ConnectorProfileType.Rectangular, m_planarFaces[0].Reference);
         param = connSupplyAir.get_Parameter(BuiltInParameter.CONNECTOR_HEIGHT);
         param.Set(connectorDimensions[0, 0]);
         param = connSupplyAir.get_Parameter(BuiltInParameter.CONNECTOR_WIDTH);
         param.Set(connectorDimensions[0, 1]);
         param = connSupplyAir.get_Parameter(BuiltInParameter.RBS_DUCT_FLOW_DIRECTION_PARAM);
         param.Set(2);
         param = connSupplyAir.get_Parameter(BuiltInParameter.RBS_DUCT_FLOW_CONFIGURATION_PARAM);
         param.Set(1);
         param = connSupplyAir.get_Parameter(BuiltInParameter.RBS_DUCT_FLOW_PARAM);
         param.Set(flow);

         #endregion

         #region Create the Return Air duct connector

         // get the planar faces of extrusion2
         m_planarFaces = GetPlanarFaces(extrusions[2]);

         // create the Return Air duct connector
         //DuctConnector connReturnAir = f.NewDuctConnector(m_planarFaces[0].Reference,
         //    DuctSystemType.ReturnAir);
         ConnectorElement connReturnAir = ConnectorElement.CreateDuctConnector(m_document, DuctSystemType.ReturnAir, ConnectorProfileType.Rectangular, m_planarFaces[0].Reference);
         param = connReturnAir.get_Parameter(BuiltInParameter.CONNECTOR_HEIGHT);
         param.Set(connectorDimensions[1, 0]);
         param = connReturnAir.get_Parameter(BuiltInParameter.CONNECTOR_WIDTH);
         param.Set(connectorDimensions[1, 1]);
         param = connReturnAir.get_Parameter(BuiltInParameter.RBS_DUCT_FLOW_DIRECTION_PARAM);
         param.Set(1);
         param =
             connReturnAir.get_Parameter(BuiltInParameter.RBS_DUCT_FLOW_CONFIGURATION_PARAM);
         param.Set(1);
         param = connReturnAir.get_Parameter(BuiltInParameter.RBS_DUCT_FLOW_PARAM);
         param.Set(flow);

         #endregion

         #region Create the Supply Hydronic pipe connector

         // get the planar faces of extrusion3
         m_planarFaces = GetPlanarFaces(extrusions[3]);

         // create the Hydronic Supply pipe connector
         //PipeConnector connSupplyHydronic = f.NewPipeConnector(m_planarFaces[0].Reference,
         //    PipeSystemType.SupplyHydronic);
         ConnectorElement connSupplyHydronic = ConnectorElement.CreatePipeConnector(m_document, PipeSystemType.SupplyHydronic, m_planarFaces[0].Reference);
         param = connSupplyHydronic.get_Parameter(BuiltInParameter.CONNECTOR_RADIUS);
         param.Set(arcRadius);
         param =
             connSupplyHydronic.get_Parameter(BuiltInParameter.RBS_PIPE_FLOW_DIRECTION_PARAM);
         param.Set(2);

         #endregion

         #region Create the Return Hydronic pipe connector

         // get the planar faces of extrusion4
         m_planarFaces = GetPlanarFaces(extrusions[4]);

         // create the Hydronic Return pipe connector
         //PipeConnector connReturnHydronic = f.NewPipeConnector(m_planarFaces[0].Reference,
         //    PipeSystemType.ReturnHydronic);
         ConnectorElement connReturnHydronic = ConnectorElement.CreatePipeConnector(m_document, PipeSystemType.ReturnHydronic, m_planarFaces[0].Reference);
         param = connReturnHydronic.get_Parameter(BuiltInParameter.CONNECTOR_RADIUS);
         param.Set(arcRadius);
         param =
             connReturnHydronic.get_Parameter(BuiltInParameter.RBS_PIPE_FLOW_DIRECTION_PARAM);
         param.Set(1);

         #endregion

      }
   }
}

=== CODE_BLOCK_0057 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData revit,
                                                            ref string message,
                                                            ElementSet elements)
      {
         try
         {
            m_application = revit.Application.Application;
            m_document = revit.Application.ActiveUIDocument.Document;

            // it can support in truss family document only
            if (!m_document.IsFamilyDocument
                || m_document.OwnerFamily.FamilyCategory.BuiltInCategory != BuiltInCategory.OST_Truss)
            {
               message = "Cannot execute truss creation in non-truss family document";
               return Autodesk.Revit.UI.Result.Failed;
            }

            m_appCreator = m_application.Create;
            m_familyCreator = m_document.FamilyCreate;

            Transaction newTran = new Transaction(m_document);
            newTran.Start("NewTrussCurve");

            // Start the truss creation
            MakeNewTruss();

            newTran.Commit();
         }
         catch (Exception ex)
         {
            message = ex.ToString();
            return Autodesk.Revit.UI.Result.Failed;
         }
         return Autodesk.Revit.UI.Result.Succeeded;
      }

      /// <summary>
      /// Example demonstrating truss creation in the Autodesk Revit API. This example constructs
      /// a "mono" truss aligned with the reference planes in the (already loaded) truss family
      /// document.
      /// </summary>
      private void MakeNewTruss()
      {
         // Constants for arranging the angular truss members
         double webAngle = 35.0;
         double webAngleRadians = (180 - webAngle) * Math.PI / 180.0;
         Autodesk.Revit.DB.XYZ angleDirection = new Autodesk.Revit.DB.XYZ(Math.Cos(webAngleRadians), Math.Sin(webAngleRadians), 0);

         // Look up the reference planes and view in which to sketch 
         ReferencePlane top = null, bottom = null, left = null, right = null, center = null;
         View level1 = null;
         List<Autodesk.Revit.DB.Element> elements = new List<Autodesk.Revit.DB.Element>();
         ElementClassFilter refPlaneFilter = new ElementClassFilter(typeof(ReferencePlane));
         ElementClassFilter viewFilter = new ElementClassFilter(typeof(View));
         LogicalOrFilter filter = new LogicalOrFilter(refPlaneFilter, viewFilter);
         FilteredElementCollector collector = new FilteredElementCollector(m_document);
         elements.AddRange(collector.WherePasses(filter).ToElements());
         foreach (Element e in elements)
         {
            // skip view templates because they're invisible invalid for truss creation
            View view = e as View;
            if (null != view && view.IsTemplate)
               continue;
            //
            switch (e.Name)
            {
               case "Top": top = e as ReferencePlane; break;
               case "Bottom": bottom = e as ReferencePlane; break;
               case "Right": right = e as ReferencePlane; break;
               case "Left": left = e as ReferencePlane; break;
               case "Center": center = e as ReferencePlane; break;
               case "Level 1": level1 = e as View; break;
            }
         }
         if (top == null || bottom == null || left == null
             || right == null || center == null || level1 == null)
            throw new InvalidOperationException("Could not find prerequisite named reference plane or named view.");

         SketchPlane sPlane = level1.SketchPlane;

         // Extract the geometry of each reference plane
         Line bottomLine = GetReferencePlaneLine(bottom);
         Line leftLine = GetReferencePlaneLine(left);
         Line rightLine = GetReferencePlaneLine(right);
         Line topLine = GetReferencePlaneLine(top);
         Line centerLine = GetReferencePlaneLine(center);

         // Create bottom chord along "bottom" from "left" to "right"
         Autodesk.Revit.DB.XYZ bottomLeft = GetIntersection(bottomLine, leftLine);
         Autodesk.Revit.DB.XYZ bottomRight = GetIntersection(bottomLine, rightLine);
         ModelCurve bottomChord = MakeTrussCurve(bottomLeft, bottomRight, sPlane, TrussCurveType.BottomChord);
         if (null != bottomChord)
         {
            // Add the alignment constraint to the bottom chord.
            Curve geometryCurve = bottomChord.GeometryCurve;
            // Lock the bottom chord to bottom reference plan
            m_familyCreator.NewAlignment(level1, bottom.GetReference(), geometryCurve.Reference);
         }

         // Create web connecting top and bottom chords on the right side
         Autodesk.Revit.DB.XYZ topRight = GetIntersection(topLine, rightLine);
         ModelCurve rightWeb = MakeTrussCurve(bottomRight, topRight, sPlane, TrussCurveType.Web);
         if (null != rightWeb)
         {
            // Add the alignment constraint to the right web chord.
            Curve geometryCurve = rightWeb.GeometryCurve;
            // Lock the right web chord to right reference plan
            m_familyCreator.NewAlignment(level1, right.GetReference(), geometryCurve.Reference);
         }

         // Create top chord diagonally from bottom-left to top-right
         ModelCurve topChord = MakeTrussCurve(bottomLeft, topRight, sPlane, TrussCurveType.TopChord);
         if (null != topChord)
         {
            // Add the alignment constraint to the top chord.
            Curve geometryCurve = topChord.GeometryCurve;
            // Lock the start point of top chord to the Intersection of left and bottom reference plan
            m_familyCreator.NewAlignment(level1, geometryCurve.GetEndPointReference(0), left.GetReference());
            m_familyCreator.NewAlignment(level1, geometryCurve.GetEndPointReference(0), bottom.GetReference());
            // Lock the end point of top chord to the Intersection of right and top reference plan
            m_familyCreator.NewAlignment(level1, geometryCurve.GetEndPointReference(1), top.GetReference());
            m_familyCreator.NewAlignment(level1, geometryCurve.GetEndPointReference(1), right.GetReference());
         }

         // Create angled web from midpoint to the narrow end of the truss
         Autodesk.Revit.DB.XYZ bottomMidPoint = GetIntersection(bottomLine, centerLine);
         Line webDirection = Line.CreateUnbound(bottomMidPoint, angleDirection);
         Autodesk.Revit.DB.XYZ endOfWeb = GetIntersection(topChord.GeometryCurve as Line, webDirection);
         ModelCurve angledWeb = MakeTrussCurve(bottomMidPoint, endOfWeb, sPlane, TrussCurveType.Web);

         // Add a dimension to force the angle to be stable even when truss length and height are modified
         Arc dimensionArc = Arc.Create(
             bottomMidPoint, angledWeb.GeometryCurve.Length / 2, webAngleRadians, Math.PI, Autodesk.Revit.DB.XYZ.BasisX, Autodesk.Revit.DB.XYZ.BasisY);
         Dimension createdDim = m_familyCreator.NewAngularDimension(
             level1, dimensionArc, angledWeb.GeometryCurve.Reference, bottomChord.GeometryCurve.Reference);
         if (null != createdDim)
            createdDim.IsLocked = true;

         // Create angled web from corner to top of truss
         Autodesk.Revit.DB.XYZ bottomRight2 = GetIntersection(bottomLine, rightLine);
         webDirection = Line.CreateUnbound(bottomRight2, angleDirection);
         endOfWeb = GetIntersection(topChord.GeometryCurve as Line, webDirection);
         ModelCurve angledWeb2 = MakeTrussCurve(bottomRight, endOfWeb, sPlane, TrussCurveType.Web);

         // Add a dimension to force the angle to be stable even when truss length and height are modified
         dimensionArc = Arc.Create(
             bottomRight, angledWeb2.GeometryCurve.Length / 2, webAngleRadians, Math.PI, Autodesk.Revit.DB.XYZ.BasisX, Autodesk.Revit.DB.XYZ.BasisY);
         createdDim = m_familyCreator.NewAngularDimension(
             level1, dimensionArc, angledWeb2.GeometryCurve.Reference, bottomChord.GeometryCurve.Reference);
         if (null != createdDim)
            createdDim.IsLocked = true;

         //Connect bottom midpoint to end of the angled web
         ModelCurve braceWeb = MakeTrussCurve(bottomMidPoint, endOfWeb, sPlane, TrussCurveType.Web);
      }

      /// <summary>
      /// Utility method to create a truss model curve.
      /// </summary>
      /// <param name="start">The start point.</param>
      /// <param name="end">The end point.</param>
      /// <param name="sketchPlane">The sketch plane for the new curve.</param>
      /// <param name="type">The type of truss curve.</param>
      /// <returns>the created truss model curve.</returns>
      private ModelCurve MakeTrussCurve(Autodesk.Revit.DB.XYZ start, Autodesk.Revit.DB.XYZ end, SketchPlane sketchPlane, TrussCurveType type)
      {
         Line line = Line.CreateBound(start, end);
         ModelCurve trussCurve = m_familyCreator.NewModelCurve(line, sketchPlane);
         trussCurve.TrussCurveType = type;
         m_document.Regenerate();

         return trussCurve;
      }

      /// <summary>
      /// Utility method for to extract the geometry of a reference plane in a family.
      /// </summary>
      /// <param name="plane">The reference plane.</param>
      /// <returns>An unbounded line representing the location of the plane.</returns>
      private Line GetReferencePlaneLine(ReferencePlane plane)
      {
         // Reset the "elevation" of the plane's line to Z=0, since that's where the lines will be placed.  
         // Otherwise, some intersection calculation may fail
         Autodesk.Revit.DB.XYZ origin = new XYZ(
             plane.BubbleEnd.X,
             plane.BubbleEnd.Y,
             0.0);

         Line line = Line.CreateUnbound(origin, plane.Direction);

         return line;
      }

      /// <summary>
      /// Utility method for getting the intersection between two lines.
      /// </summary>
      /// <param name="line1">The first line.</param>
      /// <param name="line2">The second line.</param>
      /// <returns>The intersection point.</returns>
      /// <exception cref="InvalidOperationException">Thrown when an intersection can't be found.</exception>
      private Autodesk.Revit.DB.XYZ GetIntersection(Line line1, Line line2)
      {
         Autodesk.Revit.DB.CurveIntersectResult intersectResult = line1.Intersect(line2, CurveIntersectResultOption.Detailed);

         if (intersectResult?.Result != Autodesk.Revit.DB.SetComparisonResult.Overlap)
            throw new InvalidOperationException("Input lines did not intersect.");

         if (intersectResult.GetOverlaps()?.Count != 1)
            throw new InvalidOperationException("Could not extract intersection point for lines.");

         Autodesk.Revit.DB.XYZ intersectionPoint = intersectResult.GetOverlaps()[0]?.Point;
         if (intersectionPoint == null)
         {
            throw new ArgumentException("Bad Input.");
         }

         return intersectionPoint;
      }
   }
}

=== CODE_BLOCK_0059 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
        ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            try
            {
                m_app = commandData.Application;
                m_doc = commandData.Application.ActiveUIDocument.Document;
                if (null == m_doc)
                {
                    message = "There is no active document.";
                    return Autodesk.Revit.UI.Result.Failed;
                }

                if (!m_doc.IsFamilyDocument)
                {
                    message = "Current document is not a family document.";
                    return Autodesk.Revit.UI.Result.Failed;
                }

                // Get the view where the dwg file will be imported
                View view = GetView();
                if (null == view)
                {
                    message = "Opened wrong template file, please use the provided family template file.";
                    return Autodesk.Revit.UI.Result.Failed;
                }

                // The dwg file which will be imported
                string AssemblyDirectory = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);
                string DWGFile = "Desk.dwg";
                string DWGFullPath = Path.Combine(AssemblyDirectory, DWGFile);

                Transaction transaction = new Transaction(m_doc, "DWGFamilyCreation");
                transaction.Start();
                // Import the dwg file into current family document
                DWGImportOptions options = new DWGImportOptions();
                options.Placement = Autodesk.Revit.DB.ImportPlacement.Origin;
                options.OrientToView = true;
                ElementId elementId = null;
                m_doc.Import(DWGFullPath, options, view, out elementId);

                // Add type parameters to the family
                AddParameters(DWGFile);
                transaction.Commit();
            }
            catch (Exception ex)
            {
                message = ex.ToString();
                return Autodesk.Revit.UI.Result.Failed;
            }

            return Autodesk.Revit.UI.Result.Succeeded;
        }

        /// <summary>
        /// Add type parameters to the family
        /// </summary>
        /// <param name="DWGFileName">Name of imported dwg file</param>
        private void AddParameters(string DWGFileName)
        {
            // Get the family manager
            FamilyManager familyMgr = m_doc.FamilyManager;

            // Add parameter 1: DWGFileName
            familyMgr.NewType("DWGFamilyCreation");
            FamilyParameter paraFileName = familyMgr.AddParameter("DWGFileName", new ForgeTypeId(),
                SpecTypeId.String.Text, false);
            familyMgr.Set(paraFileName, DWGFileName);

            // Add parameter 2: ImportTime
            String time = DateTime.Now.ToString("yyyy-MM-dd");
            FamilyParameter paraImportTime = familyMgr.AddParameter("ImportTime", new ForgeTypeId(),
                SpecTypeId.String.Text, false);
            familyMgr.Set(paraImportTime, time);
        }

        /// <summary>
        /// Get the view where the dwg file will be imported
        /// </summary>
        /// <returns>The view where the dwg file will be imported</returns>
        private View GetView()
        {
            View view = null;
            List<Autodesk.Revit.DB.Element> views = new List<Autodesk.Revit.DB.Element>();
            FilteredElementCollector collector = new FilteredElementCollector(m_app.ActiveUIDocument.Document);
            views.AddRange(collector.OfClass(typeof(View)).ToElements());
            foreach (View v in views)
            {
                if (!v.IsTemplate && v.ViewType == Autodesk.Revit.DB.ViewType.FloorPlan && v.Name == "Ref. Level")
                {
                    view = v;
                    break;
                }
            }

            return view;
        }
    }
}

=== CODE_BLOCK_0061 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                             ref string message,
                                             ElementSet elements)
      {
         try
         {
            m_revit = commandData.Application.Application;
            m_familyDocument = commandData.Application.ActiveUIDocument.Document;
            // create new family document if active document is not a family document
            if (!m_familyDocument.IsFamilyDocument)
            {
               m_familyDocument = m_revit.NewFamilyDocument("Generic Model.rft");
               if (null == m_familyDocument)
               {
                  message = "Cannot open family document";
                  return Autodesk.Revit.UI.Result.Failed;
               }
            }
            m_creationFamily = m_familyDocument.FamilyCreate;
            // create generic model family in the document
            CreateGenericModel();
            if (0 == m_errCount)
            {
               return Autodesk.Revit.UI.Result.Succeeded;
            }
            else
            {
               message = m_errorInfo;
               return Autodesk.Revit.UI.Result.Failed;
            }
         }
         catch (Exception e)
         {
            message = e.ToString();
            return Autodesk.Revit.UI.Result.Failed;
         }

      }
      #endregion

      #region Class Implementation

      /// <summary>
      /// Examples for form creation in generic model families.
      /// Create extrusion, blend, revolution, sweep, swept blend
      /// </summary>
      public void CreateGenericModel()
      {
         // use transaction if the family document is not active document
         Transaction transaction = new Transaction(m_familyDocument, "CreateGenericModel");
         transaction.Start();
         CreateExtrusion();
         CreateBlend();
         CreateRevolution();
         CreateSweep();
         CreateSweptBlend();
         transaction.Commit();
         return;
      }

      /// <summary>
      /// Create one rectangular extrusion
      /// </summary>
      private void CreateExtrusion()
      {
         try
         {
            #region Create rectangle profile
            CurveArrArray curveArrArray = new CurveArrArray();
            CurveArray curveArray1 = new CurveArray();

            Autodesk.Revit.DB.XYZ normal = Autodesk.Revit.DB.XYZ.BasisZ;
            SketchPlane sketchPlane = CreateSketchPlane(normal, Autodesk.Revit.DB.XYZ.Zero);

            // create one rectangular extrusion
            Autodesk.Revit.DB.XYZ p0 = Autodesk.Revit.DB.XYZ.Zero;
            Autodesk.Revit.DB.XYZ p1 = new Autodesk.Revit.DB.XYZ(10, 0, 0);
            Autodesk.Revit.DB.XYZ p2 = new Autodesk.Revit.DB.XYZ(10, 10, 0);
            Autodesk.Revit.DB.XYZ p3 = new Autodesk.Revit.DB.XYZ(0, 10, 0);
            Line line1 = Line.CreateBound(p0, p1);
            Line line2 = Line.CreateBound(p1, p2);
            Line line3 = Line.CreateBound(p2, p3);
            Line line4 = Line.CreateBound(p3, p0);
            curveArray1.Append(line1);
            curveArray1.Append(line2);
            curveArray1.Append(line3);
            curveArray1.Append(line4);

            curveArrArray.Append(curveArray1);
            #endregion
            // here create rectangular extrusion
            Extrusion rectExtrusion = m_creationFamily.NewExtrusion(true, curveArrArray, sketchPlane, 10);
            // move to proper place
            Autodesk.Revit.DB.XYZ transPoint1 = new Autodesk.Revit.DB.XYZ(-16, 0, 0);
            ElementTransformUtils.MoveElement(m_familyDocument, rectExtrusion.Id, transPoint1);
         }
         catch (Exception e)
         {
            m_errCount++;
            m_errorInfo += "Unexpected exceptions occur in CreateExtrusion: " + e.ToString() + "\r\n";
         }
      }

      /// <summary>
      /// Create one blend
      /// </summary>
      private void CreateBlend()
      {
         try
         {
            #region Create top and base profiles
            CurveArray topProfile = new CurveArray();
            CurveArray baseProfile = new CurveArray();

            Autodesk.Revit.DB.XYZ normal = Autodesk.Revit.DB.XYZ.BasisZ;
            SketchPlane sketchPlane = CreateSketchPlane(normal, Autodesk.Revit.DB.XYZ.Zero);

            // create one blend
            Autodesk.Revit.DB.XYZ p00 = Autodesk.Revit.DB.XYZ.Zero;
            Autodesk.Revit.DB.XYZ p01 = new Autodesk.Revit.DB.XYZ(10, 0, 0);
            Autodesk.Revit.DB.XYZ p02 = new Autodesk.Revit.DB.XYZ(10, 10, 0);
            Autodesk.Revit.DB.XYZ p03 = new Autodesk.Revit.DB.XYZ(0, 10, 0);
            Line line01 = Line.CreateBound(p00, p01);
            Line line02 = Line.CreateBound(p01, p02);
            Line line03 = Line.CreateBound(p02, p03);
            Line line04 = Line.CreateBound(p03, p00);

            baseProfile.Append(line01);
            baseProfile.Append(line02);
            baseProfile.Append(line03);
            baseProfile.Append(line04);

            Autodesk.Revit.DB.XYZ p10 = new Autodesk.Revit.DB.XYZ(5, 2, 10);
            Autodesk.Revit.DB.XYZ p11 = new Autodesk.Revit.DB.XYZ(8, 5, 10);
            Autodesk.Revit.DB.XYZ p12 = new Autodesk.Revit.DB.XYZ(5, 8, 10);
            Autodesk.Revit.DB.XYZ p13 = new Autodesk.Revit.DB.XYZ(2, 5, 10);
            Line line11 = Line.CreateBound(p10, p11);
            Line line12 = Line.CreateBound(p11, p12);
            Line line13 = Line.CreateBound(p12, p13);
            Line line14 = Line.CreateBound(p13, p10);

            topProfile.Append(line11);
            topProfile.Append(line12);
            topProfile.Append(line13);
            topProfile.Append(line14);
            #endregion
            // here create one blend
            Blend blend = m_creationFamily.NewBlend(true, topProfile, baseProfile, sketchPlane);
            // move to proper place
            Autodesk.Revit.DB.XYZ transPoint1 = new Autodesk.Revit.DB.XYZ(0, 11, 0);
            ElementTransformUtils.MoveElement(m_familyDocument, blend.Id, transPoint1);
         }
         catch (Exception e)
         {
            m_errCount++;
            m_errorInfo += "Unexpected exceptions occur in CreateBlend: " + e.ToString() + "\r\n";
         }
      }

      /// <summary>
      /// Create one rectangular profile revolution
      /// </summary>
      private void CreateRevolution()
      {
         try
         {
            #region Create rectangular profile
            CurveArrArray curveArrArray = new CurveArrArray();
            CurveArray curveArray = new CurveArray();

            Autodesk.Revit.DB.XYZ normal = Autodesk.Revit.DB.XYZ.BasisZ;
            SketchPlane sketchPlane = CreateSketchPlane(normal, Autodesk.Revit.DB.XYZ.Zero);

            // create one rectangular profile revolution
            Autodesk.Revit.DB.XYZ p0 = Autodesk.Revit.DB.XYZ.Zero;
            Autodesk.Revit.DB.XYZ p1 = new Autodesk.Revit.DB.XYZ(10, 0, 0);
            Autodesk.Revit.DB.XYZ p2 = new Autodesk.Revit.DB.XYZ(10, 10, 0);
            Autodesk.Revit.DB.XYZ p3 = new Autodesk.Revit.DB.XYZ(0, 10, 0);
            Line line1 = Line.CreateBound(p0, p1);
            Line line2 = Line.CreateBound(p1, p2);
            Line line3 = Line.CreateBound(p2, p3);
            Line line4 = Line.CreateBound(p3, p0);

            Autodesk.Revit.DB.XYZ pp = new Autodesk.Revit.DB.XYZ(1, -1, 0);
            Line axis1 = Line.CreateBound(Autodesk.Revit.DB.XYZ.Zero, pp);
            curveArray.Append(line1);
            curveArray.Append(line2);
            curveArray.Append(line3);
            curveArray.Append(line4);

            curveArrArray.Append(curveArray);
            #endregion
            // here create rectangular profile revolution
            Revolution revolution1 = m_creationFamily.NewRevolution(true, curveArrArray, sketchPlane, axis1, -Math.PI, 0);
            // move to proper place
            Autodesk.Revit.DB.XYZ transPoint1 = new Autodesk.Revit.DB.XYZ(0, 32, 0);
            ElementTransformUtils.MoveElement(m_familyDocument, revolution1.Id, transPoint1);
         }
         catch (Exception e)
         {
            m_errCount++;
            m_errorInfo += "Unexpected exceptions occur in CreateRevolution: " + e.ToString() + "\r\n";
         }
      }

      /// <summary>
      /// Create one sweep
      /// </summary>
      private void CreateSweep()
      {
         try
         {
            #region Create rectangular profile and path curve
            CurveArrArray arrarr = new CurveArrArray();
            CurveArray arr = new CurveArray();

            Autodesk.Revit.DB.XYZ normal = Autodesk.Revit.DB.XYZ.BasisZ;
            SketchPlane sketchPlane = CreateSketchPlane(normal, Autodesk.Revit.DB.XYZ.Zero);

            Autodesk.Revit.DB.XYZ pnt1 = new Autodesk.Revit.DB.XYZ(0, 0, 0);
            Autodesk.Revit.DB.XYZ pnt2 = new Autodesk.Revit.DB.XYZ(2, 0, 0);
            Autodesk.Revit.DB.XYZ pnt3 = new Autodesk.Revit.DB.XYZ(1, 1, 0);
            arr.Append(Arc.Create(pnt2, 1.0d, 0.0d, 180.0d, Autodesk.Revit.DB.XYZ.BasisX, Autodesk.Revit.DB.XYZ.BasisY));
            arr.Append(Arc.Create(pnt1, pnt3, pnt2));
            arrarr.Append(arr);
            SweepProfile profile = m_revit.Create.NewCurveLoopsProfile(arrarr);

            Autodesk.Revit.DB.XYZ pnt4 = new Autodesk.Revit.DB.XYZ(10, 0, 0);
            Autodesk.Revit.DB.XYZ pnt5 = new Autodesk.Revit.DB.XYZ(0, 10, 0);
            Curve curve = Line.CreateBound(pnt4, pnt5);

            CurveArray curves = new CurveArray();
            curves.Append(curve);
            #endregion
            // here create one sweep with two arcs formed the profile
            Sweep sweep1 = m_creationFamily.NewSweep(true, curves, sketchPlane, profile, 0, ProfilePlaneLocation.Start);
            // move to proper place
            Autodesk.Revit.DB.XYZ transPoint1 = new Autodesk.Revit.DB.XYZ(11, 0, 0);
            ElementTransformUtils.MoveElement(m_familyDocument, sweep1.Id, transPoint1);
         }
         catch (Exception e)
         {
            m_errCount++;
            m_errorInfo += "Unexpected exceptions occur in CreateSweep: " + e.ToString() + "\r\n";
         }
      }

      /// <summary>
      /// Create one SweptBlend
      /// </summary>
      private void CreateSweptBlend()
      {
         try
         {
            #region Create top and bottom profiles and path curve
            Autodesk.Revit.DB.XYZ pnt1 = new Autodesk.Revit.DB.XYZ(0, 0, 0);
            Autodesk.Revit.DB.XYZ pnt2 = new Autodesk.Revit.DB.XYZ(1, 0, 0);
            Autodesk.Revit.DB.XYZ pnt3 = new Autodesk.Revit.DB.XYZ(1, 1, 0);
            Autodesk.Revit.DB.XYZ pnt4 = new Autodesk.Revit.DB.XYZ(0, 1, 0);
            Autodesk.Revit.DB.XYZ pnt5 = new Autodesk.Revit.DB.XYZ(0, 0, 1);

            CurveArrArray arrarr1 = new CurveArrArray();
            CurveArray arr1 = new CurveArray();
            arr1.Append(Line.CreateBound(pnt1, pnt2));
            arr1.Append(Line.CreateBound(pnt2, pnt3));
            arr1.Append(Line.CreateBound(pnt3, pnt4));
            arr1.Append(Line.CreateBound(pnt4, pnt1));
            arrarr1.Append(arr1);

            Autodesk.Revit.DB.XYZ pnt6 = new Autodesk.Revit.DB.XYZ(0.5, 0, 0);
            Autodesk.Revit.DB.XYZ pnt7 = new Autodesk.Revit.DB.XYZ(1, 0.5, 0);
            Autodesk.Revit.DB.XYZ pnt8 = new Autodesk.Revit.DB.XYZ(0.5, 1, 0);
            Autodesk.Revit.DB.XYZ pnt9 = new Autodesk.Revit.DB.XYZ(0, 0.5, 0);
            CurveArrArray arrarr2 = new CurveArrArray();
            CurveArray arr2 = new CurveArray();
            arr2.Append(Line.CreateBound(pnt6, pnt7));
            arr2.Append(Line.CreateBound(pnt7, pnt8));
            arr2.Append(Line.CreateBound(pnt8, pnt9));
            arr2.Append(Line.CreateBound(pnt9, pnt6));
            arrarr2.Append(arr2);

            SweepProfile bottomProfile = m_revit.Create.NewCurveLoopsProfile(arrarr1);
            SweepProfile topProfile = m_revit.Create.NewCurveLoopsProfile(arrarr2);

            Autodesk.Revit.DB.XYZ pnt10 = new Autodesk.Revit.DB.XYZ(5, 0, 0);
            Autodesk.Revit.DB.XYZ pnt11 = new Autodesk.Revit.DB.XYZ(0, 20, 0);
            Curve curve = Line.CreateBound(pnt10, pnt11);

            Autodesk.Revit.DB.XYZ normal = Autodesk.Revit.DB.XYZ.BasisZ;
            SketchPlane sketchPlane = CreateSketchPlane(normal, Autodesk.Revit.DB.XYZ.Zero);
            #endregion
            // here create one swept blend
            SweptBlend newSweptBlend1 = m_creationFamily.NewSweptBlend(true, curve, sketchPlane, bottomProfile, topProfile);
            // move to proper place
            Autodesk.Revit.DB.XYZ transPoint1 = new Autodesk.Revit.DB.XYZ(11, 32, 0);
            ElementTransformUtils.MoveElement(m_familyDocument, newSweptBlend1.Id, transPoint1);
         }
         catch (Exception e)
         {
            m_errCount++;
            m_errorInfo += "Unexpected exceptions occur in CreateSweptBlend: " + e.ToString() + "\r\n";
         }
      }


      /// <summary>
      /// Get element by its id
      /// </summary>
      private T GetElement<T>(long eid) where T : Autodesk.Revit.DB.Element
      {
         Autodesk.Revit.DB.ElementId elementId = new ElementId(eid);
         return m_familyDocument.GetElement(elementId) as T;
      }

      /// <summary>
      /// Create sketch plane for generic model profile
      /// </summary>
      /// <param name="normal">plane normal</param>
      /// <param name="origin">origin point</param>
      /// <returns></returns>
      internal SketchPlane CreateSketchPlane(Autodesk.Revit.DB.XYZ normal, Autodesk.Revit.DB.XYZ origin)
      {
         // First create a Geometry.Plane which need in NewSketchPlane() method
         Plane geometryPlane = Plane.CreateByNormalAndOrigin(normal, origin);
         if (null == geometryPlane)  // assert the creation is successful
         {
            throw new Exception("Create the geometry plane failed.");
         }
         // Then create a sketch plane using the Geometry.Plane
         SketchPlane plane = SketchPlane.Create(m_familyDocument, geometryPlane);
         // throw exception if creation failed
         if (null == plane)
         {
            throw new Exception("Create the sketch plane failed.");
         }
         return plane;
      }

      #endregion

   }
}

=== CODE_BLOCK_0063 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                             ref string message,
                                             ElementSet elements)
        {
            Document document;
            string assemblyPath;
            document = commandData.Application.ActiveUIDocument.Document;
            assemblyPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
            m_logFileName = assemblyPath + "\\RegenerationLog.txt";   
            //only a family document  can retrieve family manager
            if (document.IsFamilyDocument)
            {
                m_familyManager = document.FamilyManager;
                //create regeneration log file
                StreamWriter writer = File.CreateText(m_logFileName);
                writer.WriteLine("Family Type     Result");
                writer.WriteLine("-------------------------");
                writer.Close();
                using(MessageForm msgForm=new MessageForm())
                {
                    msgForm.StartPosition = FormStartPosition.Manual;
                    CheckTypeRegeneration(msgForm);                    
                    return Autodesk.Revit.UI.Result.Succeeded;                   
               }
            }
            else
            {
                message = "please make sure you have opened a family document!";
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
        #endregion

        #region Class Implementation
       /// <summary>
        ///  After setting CurrentType property, the CurrentType has changed to the new one,the Revit model will change along with the current type
       /// </summary>
       /// <param name="msgForm">the form is used to show the regeneration result</param>        
        public void CheckTypeRegeneration(MessageForm msgForm)
        {
            //the list to record the error messages           
            List<string> errorInfo = new List<string>(); 
            try
            {
                foreach (FamilyType type in m_familyManager.Types)
                {
                    if (!(type.Name.ToString().Trim()==""))
                    {
                        try
                        {
                            m_familyManager.CurrentType = type;
                            msgForm.AddMessage(type.Name+" Successful\n",true);
                            WriteLog(type.Name + "      Successful");
                        }
                        catch
                        {
                            errorInfo.Add(type.Name);
                            msgForm.AddMessage(type.Name+" Failed \n",true);
                            WriteLog(type.Name + "      Failed");
                        }
                        msgForm.ShowDialog();
                    }                  
                }

                //add a conclusion regeneration result
                string resMsg;
                if (errorInfo.Count > 0)
                {
                    resMsg = "\nResult: " + errorInfo.Count + " family types regeneration failed!";
                    foreach (string error in errorInfo)
                    {
                        resMsg += "\n " + error;
                    }
                }
                else
                {
                    resMsg = "\nResult: All types in the family can regenerate successfully.";
                }
                WriteLog(resMsg.ToString());
                resMsg += "\nIf you want to know the detail regeneration result please get log file at "+m_logFileName;
                msgForm.AddMessage(resMsg,false);
                msgForm.ShowDialog();           
            }
            catch(Exception ex)
            {
                WriteLog("There is some problem when regeneration:" + ex.ToString());
                msgForm.AddMessage("There is some problem when regeneration:"+ex.ToString(),true);
                msgForm.ShowDialog();  
            }
        }

        /// <summary>
        /// The method to write line to log file
        /// </summary>
        /// <param name="logStr">the log string</param>
        private void WriteLog(string logStr)
        {
            StreamWriter writer = null;
            writer = File.AppendText(m_logFileName);
            writer.WriteLine(logStr);
            writer.Close();
        }       
        #endregion
    }
}

=== CODE_BLOCK_0065 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                             ref string message,
                                             ElementSet elements)
        {
            Document doc = commandData.Application.ActiveUIDocument.Document;
            //only a family document  can retrieve family manager
            if (doc.IsFamilyDocument)
            {
                if (null != doc.OwnerFamily && null != doc.OwnerFamily.FamilyCategory 
                    && doc.OwnerFamily.FamilyCategory.Name != doc.Settings.Categories.get_Item(BuiltInCategory.OST_Windows).Name)
                    // FamilyCategory.Name is not "Windows".
                {
                    message = "Please make sure you opened a template of Window.";
                    return Autodesk.Revit.UI.Result.Failed;                   
                }
                WindowWizard wizard = new WindowWizard(commandData);
                int result = wizard.RunWizard();
                if (1 == result)
                {
                    return Autodesk.Revit.UI.Result.Succeeded;
                }
                else if (0 == result)
                {
                    message = "Window Creation was cancelled.";
                    return Autodesk.Revit.UI.Result.Cancelled;
                }
                else
                {
                    message = "Window Creation failed, please check your template and inputs then try again.";
                    return Autodesk.Revit.UI.Result.Failed;
                }              
            }
            else
            {
                message = "please make sure you have opened a family document!";
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
        #endregion
    }
}

=== CODE_BLOCK_0067 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,
                                                             ref string message,
                                                             Autodesk.Revit.DB.ElementSet elements)
        {
            // Initialization 
            m_app = revit.Application;
            m_doc = revit.Application.ActiveUIDocument.Document;

            // Find a 3D view to use for the ray tracing operation
            Get3DView("{3D}");

            Selection selection = revit.Application.ActiveUIDocument.Selection;
            List<Wall> wallsToCheck = new List<Wall>();

            // If wall(s) are selected, process them.
            if (selection.GetElementIds().Count > 0)
            {
                foreach (Autodesk.Revit.DB.ElementId eId in selection.GetElementIds())
                {
                   Autodesk.Revit.DB.Element e = revit.Application.ActiveUIDocument.Document.GetElement(eId);
                    if (e is Wall)
                    {
                        wallsToCheck.Add((Wall)e);
                    }
                }

                if (wallsToCheck.Count <= 0)
                {
                    message = "No walls were found in the active document selection";
                    return Result.Cancelled;
                }
            }
            // Find all walls in the document and process them.
            else
            {
                FilteredElementCollector collector = new FilteredElementCollector(m_doc);
                FilteredElementIterator iter = collector.OfClass(typeof(Wall)).GetElementIterator();
                while (iter.MoveNext())
                {
                    wallsToCheck.Add((Wall)iter.Current);
                }
            }

            // Execute the check for embedded columns
            CheckWallsForEmbeddedColumns(wallsToCheck);

            // Process the results, in this case set the active selection to contain all embedded columns
            ICollection<ElementId> toSelected = new List<ElementId>(); 
            if (m_allColumnsOnWalls.Count > 0)
            {
                foreach (ElementId id in m_allColumnsOnWalls)
                {
                    ElementId familyInstanceId = id;
                    Autodesk.Revit.DB.Element familyInstance = m_doc.GetElement(familyInstanceId);
                    toSelected.Add(familyInstance.Id);
                }
                selection.SetElementIds(toSelected); 
            }
            return Result.Succeeded;
        }
        #endregion

        #region Class Implementation
        /// <summary>
        /// Check a list of walls for embedded columns.
        /// </summary>
        /// <param name="wallsToCheck">The list of walls to check.</param>
        private void CheckWallsForEmbeddedColumns(List<Wall> wallsToCheck)
        {
            foreach (Wall wall in wallsToCheck)
            {
                CheckWallForEmbeddedColumns(wall);
            }
        }

        /// <summary>
        /// Checks a single wall for embedded columns.
        /// </summary>
        /// <param name="wall">The wall to check.</param>
        private void CheckWallForEmbeddedColumns(Wall wall)
        {
            LocationCurve locationCurve = wall.Location as LocationCurve;
            Curve wallCurve = locationCurve.Curve;
            if (wallCurve is Line)
            {
                LogWallCurve((Line)wallCurve);
                CheckLinearWallForEmbeddedColumns(wall, locationCurve, (Line)wallCurve);
            }
            else
            {
                CheckProfiledWallForEmbeddedColumns(wall, locationCurve, wallCurve);
            }
        }

        /// <summary>
        /// Checks a single linear wall for embedded columns.
        /// </summary>
        /// <param name="wall">The wall to check.</param>
        /// <param name="locationCurve">The location curve extracted from this wall.</param>
        /// <param name="wallCurve">The profile of the wall.</param>
        private void CheckLinearWallForEmbeddedColumns(Wall wall, LocationCurve locationCurve, Curve wallCurve)
        {
            double bottomHeight = GetElevationForRay(wall);

            FindColumnsOnEitherSideOfWall(wall, locationCurve, wallCurve, 0, bottomHeight, wallCurve.Length);
        }

        /// <summary>
        /// Finds columns on either side of the given wall.
        /// </summary>
        /// <param name="wall">The wall.</param>
        /// <param name="locationCurve">The location curve of the wall.</param>
        /// <param name="wallCurve">The profile of the wall.</param>
        /// <param name="parameter">The normalized parameter along the wall profile which is being evaluated.</param>
        /// <param name="elevation">The elevation at which the rays are cast.</param>
        /// <param name="within">The maximum distance away that columns may be found.</param>
        private void FindColumnsOnEitherSideOfWall(Wall wall, LocationCurve locationCurve, Curve wallCurve, double parameter, double elevation, double within)
        {
            XYZ rayDirection = GetTangentAt(wallCurve, parameter);
            XYZ wallLocation = wallCurve.Evaluate(parameter, true);

            XYZ wallDelta = GetWallDeltaAt(wall, locationCurve, parameter);

            XYZ rayStart = new XYZ(wallLocation.X + wallDelta.X, wallLocation.Y + wallDelta.Y, elevation);
            FindColumnsByDirection(rayStart, rayDirection, within, wall);

            rayStart = new XYZ(wallLocation.X - wallDelta.X, wallLocation.Y - wallDelta.Y, elevation);
            FindColumnsByDirection(rayStart, rayDirection, within, wall);
        }

        /// <summary>
        /// Finds columns by projecting rays along a given direction.
        /// </summary>
        /// <param name="rayStart">The origin of the ray.</param>
        /// <param name="rayDirection">The direction of the ray.</param>
        /// <param name="within">The maximum distance away that columns may be found.</param>
        /// <param name="wall">The wall that this search is associated with.</param>
        private void FindColumnsByDirection(XYZ rayStart, XYZ rayDirection, double within, Wall wall)
        {
            ReferenceIntersector referenceIntersector = new ReferenceIntersector(m_view3D);
            IList<ReferenceWithContext> intersectedReferences = referenceIntersector.Find(rayStart, rayDirection);
            FindColumnsWithin(intersectedReferences, within, wall);
        }

        /// <summary>
        /// Checks a single curved/profiled wall for embedded columns.
        /// </summary>
        /// <param name="wall">The wall to check.</param>
        /// <param name="locationCurve">The location curve extracted from this wall.</param>
        /// <param name="wallCurve">The profile of the wall.</param>
        private void CheckProfiledWallForEmbeddedColumns(Wall wall, LocationCurve locationCurve, Curve wallCurve)
        {
            double bottomHeight = GetElevationForRay(wall);

            // Figure out the increment for the normalized parameter based on how long the wall is.  
            double parameterIncrement = WallIncrement / wallCurve.Length;

            // Find columns within 2' of the start of the ray.  Any smaller, and you run the risk of not finding a boundary
            // face of the column within the target range.
            double findColumnWithin = 2;

            // check for columns along every WallIncrement fraction of the wall
            for (double parameter = 0; parameter < 1.0; parameter += parameterIncrement)
            {
                FindColumnsOnEitherSideOfWall(wall, locationCurve, wallCurve, parameter, bottomHeight, findColumnWithin);
            }

        }

        /// <summary>
        /// Obtains the elevation for ray casting evaluation for a given wall.
        /// </summary>
        /// <param name="wall">The wall.</param>
        /// <returns>The elevation.</returns>
        private double GetElevationForRay(Wall wall)
        {
            Level level = m_doc.GetElement(wall.LevelId) as Level;

            // Start at 1 foot above the bottom level
            double bottomHeight = level.Elevation + 1.0;

            return bottomHeight;
        }

        /// <summary>
        /// Obtains the offset to the wall at a given location along the wall's profile.
        /// </summary>
        /// <param name="wall">The wall.</param>
        /// <param name="locationCurve">The location curve of the wall.</param>
        /// <param name="parameter">The normalized parameter along the location curve of the wall.</param>
        /// <returns>An XY vector representing the offset from the wall centerline.</returns>
        private XYZ GetWallDeltaAt(Wall wall, LocationCurve locationCurve, double parameter)
        {
            XYZ wallNormal = GetNormalToWallAt(wall, locationCurve, parameter);
            double wallWidth = wall.Width;

            // The LocationCurve is always the wall centerline, regardless of the setting for the wall Location Line.
            // So the delta to place the ray just outside the wall extents is always 1/2 the wall width + a little extra.
            XYZ wallDelta = new XYZ(wallNormal.X * wallWidth / 2 + WALL_EPSILON, wallNormal.Y * wallWidth / 2 + WALL_EPSILON, 0);

            return wallDelta;
        }

        /// <summary>
        /// Finds column elements which occur within a given set of references within the designated proximity, and stores them to the results. 
        /// </summary>
        /// <param name="references">The references obtained from FindReferencesByDirection()</param> 
        /// <param name="proximity">The maximum proximity.</param>
        /// <param name="wall">The wall from which these references were found.</param>
        private void FindColumnsWithin(IList<ReferenceWithContext> references, double proximity, Wall wall)
        {
            foreach (ReferenceWithContext reference in references)
            {
                // Exclude items too far from the start point.
                if (reference.Proximity < proximity)
                {
                    Autodesk.Revit.DB.Element referenceElement = wall.Document.GetElement(reference.GetReference());
                    if (referenceElement is FamilyInstance)
                    {
                        FamilyInstance familyInstance = (FamilyInstance)referenceElement;
                        ElementId familyInstanceId = familyInstance.Id;
                        ElementId wallId = wall.Id;
                        BuiltInCategory categoryValue = referenceElement.Category.BuiltInCategory;
                        if (categoryValue == BuiltInCategory.OST_Columns || categoryValue == BuiltInCategory.OST_StructuralColumns)
                        {
                            // Add the column to the map of wall->columns
                            if (m_columnsOnWall.ContainsKey(wallId))
                            {
                                List<ElementId> columnsOnWall = m_columnsOnWall[wallId];
                                if (!columnsOnWall.Contains(familyInstanceId))
                                    columnsOnWall.Add(familyInstanceId);
                            }
                            else
                            {
                                List<ElementId> columnsOnWall = new List<ElementId>();
                                columnsOnWall.Add(familyInstanceId);
                                m_columnsOnWall.Add(wallId, columnsOnWall);
                            }
                            // Add the column to the complete list of all embedded columns
                            if (!m_allColumnsOnWalls.Contains(familyInstanceId))
                                m_allColumnsOnWalls.Add(familyInstanceId);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Obtains the tangent of the given curve at the given parameter.
        /// </summary>
        /// <param name="curve">The curve.</param>
        /// <param name="parameter">The normalized parameter.</param>
        /// <returns>The normalized tangent vector.</returns>
        private XYZ GetTangentAt(Curve curve, double parameter)
        {
            Transform t = curve.ComputeDerivatives(parameter, true);
            // BasisX is the tangent vector of the curve.
            return t.BasisX.Normalize();
        }

        /// <summary>
        /// Finds the normal to the wall centerline at the given parameter.
        /// </summary>
        /// <param name="wall">The wall.</param>
        /// <param name="curve">The location curve of the wall.</param>
        /// <param name="parameter">The normalized parameter.</param>
        /// <returns>The normalized normal vector.</returns>
        private XYZ GetNormalToWallAt(Wall wall, LocationCurve curve, double parameter)
        {
            Curve wallCurve = curve.Curve;

            // There is no normal at a given point for a line.  We need to get the normal based on the tangent of the wall location curve.
            if (wallCurve is Line)
            {
                XYZ wallDirection = GetTangentAt(wallCurve, 0);
                XYZ wallNormal = new XYZ(wallDirection.Y, wallDirection.X, 0);
                return wallNormal;
            }
            else
            {
                Transform t = wallCurve.ComputeDerivatives(parameter, true);
                // For non-linear curves, BasisY is the normal vector to the curve.
                return t.BasisY.Normalize();
            }
        }

        /// <summary>
        /// Dump wall's curve(end points) to log
        /// </summary>
        /// <param name="wallCurve">Wall curve to be dumped.</param>
        private void LogWallCurve(Line wallCurve)
        {
            Debug.WriteLine("Wall curve is line: ");

            Debug.WriteLine("Start point: " + XYZToString(wallCurve.GetEndPoint(0)));
            Debug.WriteLine("End point: " + XYZToString(wallCurve.GetEndPoint(1)));
        }

        /// <summary>
        /// Format XYZ to string 
        /// </summary>
        /// <param name="point"></param>
        /// <returns></returns>
        private String XYZToString(XYZ point)
        {
            return "( " + point.X + ", " + point.Y + ", " + point.Z + ")";
        }

        /// <summary>
        /// Get a 3D view from active document
        /// </summary>
        private void Get3DView(string viewName)
        {
            FilteredElementCollector collector = new FilteredElementCollector(m_app.ActiveUIDocument.Document);
            foreach (Autodesk.Revit.DB.View3D v in collector.OfClass(typeof(View3D)).ToElements())
            {
                // skip view template here because view templates are invisible in project browsers
                if (v != null && !v.IsTemplate && v.Name == viewName)
                {
                    m_view3D = v as Autodesk.Revit.DB.View3D;
                    break;
                }
            }
        }
        #endregion
    }
}

=== CODE_BLOCK_0069 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         try
         {
            // should have a line style "bounce" created in the document before running this
            m_app = commandData.Application;
            Get3DView();
            if (m_view == null)
            {
               TaskDialog.Show("Revit", "A default 3D view (named {3D}) must exist before running this command");
               return Autodesk.Revit.UI.Result.Cancelled;
            }
            else
            {
               RayTraceBounceForm form = new RayTraceBounceForm(commandData, m_view);
               form.ShowDialog();
            }
            return Autodesk.Revit.UI.Result.Succeeded;
         }
         catch (Exception e)
         {
            message = e.ToString();
            return Autodesk.Revit.UI.Result.Failed;
         }
      }
      #endregion

      #region Class Implementation
      /// <summary>
      /// Get a 3D view from active document
      /// </summary>
      public void Get3DView()
      {
         List<Autodesk.Revit.DB.Element> list = new List<Autodesk.Revit.DB.Element>();
         FilteredElementCollector collector = new FilteredElementCollector(m_app.ActiveUIDocument.Document);
         list.AddRange(collector.OfClass(typeof(View3D)).ToElements());
         foreach (Autodesk.Revit.DB.View3D v in list)
         {
             // skip view template here because view templates are invisible in project browsers
             if (v != null && !v.IsTemplate && v.Name == "{3D}")
            {
               m_view = v as Autodesk.Revit.DB.View3D;
               break;
            }
         }
      }
      #endregion

   }
}

=== CODE_BLOCK_0071 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            try
            {
                // Check commandData parameter.
                if (null == commandData)
                {
                    return Autodesk.Revit.UI.Result.Failed;
                }

                SlabData revitDatas = null;
                try
                {
                    // The Datas for UI.
                    revitDatas = new SlabData(commandData.Application);
                }
                catch (NullReferenceException e)
                {
                    message = e.Message;
                    return Autodesk.Revit.UI.Result.Cancelled;  // Data error.
                }
                // Display form.
                using (FoundationSlabForm displayForm = new FoundationSlabForm(revitDatas))
                {
                    if (displayForm.ShowDialog() == System.Windows.Forms.DialogResult.OK)
                    {
                        return Autodesk.Revit.UI.Result.Succeeded; // Create foundation slabs successfully.
                    }
                }
                return Autodesk.Revit.UI.Result.Cancelled;  // Cancel creation.
            }
            catch (Exception e)
            {
                message = e.Message;
                return Autodesk.Revit.UI.Result.Failed; // Unknow error.
            }
        }
        #endregion IExternalCommand Members Implementation
    }
}

=== CODE_BLOCK_0073 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {

           // try to initialize necessary data to create framing
           FrameData data = FrameData.CreateInstance(commandData);
           // display UI for user's input
           using (CreateFrameForm framingForm = new CreateFrameForm(data))
           {
              if (framingForm.ShowDialog() == DialogResult.OK)
              {
                 // create framing
                 FrameBuilder builder = new FrameBuilder(data);
                 builder.CreateFraming();
              }
              else
              {
                 // cancel the command
                 return Autodesk.Revit.UI.Result.Cancelled;
              }
           }
            
            return Autodesk.Revit.UI.Result.Succeeded;
        }
        #endregion IExternalCommand Members Implementation
    }
}

=== CODE_BLOCK_0075 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
           Transaction tran = new Transaction(commandData.Application.ActiveUIDocument.Document, "Generate Floor");
           tran.Start();

            try
            {
                if (null == commandData)
                {
                    throw new ArgumentNullException("commandData");
                }

                Data data = new Data();
                data.ObtainData(commandData);

                GenerateFloorForm dlg = new GenerateFloorForm(data);

                if (dlg.ShowDialog() == System.Windows.Forms.DialogResult.OK)
                {
                    CreateFloor(data, commandData.Application.ActiveUIDocument.Document);

                    tran.Commit();
                    return Autodesk.Revit.UI.Result.Succeeded;
                }
                else
                {
                   tran.RollBack();
                    return Autodesk.Revit.UI.Result.Cancelled;
                }                
            }
            catch (Exception e)
            {
                message = e.Message;
                tran.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }
        }

        #endregion IExternalCommand Members Implementation

        /// <summary>
        /// create a floor by the data obtain from revit.
        /// </summary>
        /// <param name="data">Data including the profile, level etc, which is need for create a floor.</param>
        /// <param name="doc">Retrieves an object that represents the currently active project.</param>
        static public void CreateFloor(Data data, Document doc)
        {
            CurveLoop loop = new CurveLoop();
            foreach (Curve curve in data.Profile)
            {
                loop.Append(curve);
            }

            List<CurveLoop> floorLoops = new List<CurveLoop> { loop };

            Floor.Create(doc, floorLoops, data.FloorType.Id, data.Level.Id, data.Structural, null, 0.0);
        }
    }
}

=== CODE_BLOCK_0077 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            try
            {
                Transaction trans = new Transaction(commandData.Application.ActiveUIDocument.Document, "Revit.SDK.Samples.ComputedSymbolGeometry");
                trans.Start();
                // create a ComputedSymbolGeometry object 
                ComputedSymbolGeometry computedSymGeo = new ComputedSymbolGeometry(commandData.Application.ActiveUIDocument.Document);
                // execute method to get and show geometry of all instances
                computedSymGeo.GetInstanceGeometry();
                trans.Commit();
                return Result.Succeeded;
            }
            catch (Exception e)
            {
                message = e.Message;
                message += e.StackTrace;
                return Result.Failed;
            }
        }
    }
        #endregion
}

=== CODE_BLOCK_0079 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Transaction trans = new Transaction(commandData.Application.ActiveUIDocument.Document, "Revit.SDK.Samples.EnergyAnalysisModel");
            trans.Start();
            // Create an object that is responsible for collecting users inputs and getting analysis data of current model.
            using (EnergyAnalysisModel analysisModel = new EnergyAnalysisModel(commandData.Application.ActiveUIDocument.Document))
            {
               // Create the UI for users inputs options and view analysis models.
               using (OptionsAndAnalysisForm form = new OptionsAndAnalysisForm(analysisModel))
               {
                   // make analysis data ready
                   analysisModel.Initialize();
                   // show dialog to browser analysis model
                   if (DialogResult.OK != form.ShowDialog())
                   {
                       trans.RollBack();
                       return Result.Cancelled;
                   }
               }
               trans.Commit();
               return Result.Succeeded;
            }
         }

         #endregion
      }
}

=== CODE_BLOCK_0081 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            // NOTES: Anything can be done in this method, such as create a message box, 
            // a task dialog or fetch some information from revit and so on.
            // We mainly use the task dialog for example.

            // Get the application and document from external command data.
            Application app = commandData.Application.Application;
            Document activeDoc = commandData.Application.ActiveUIDocument.Document;

            #region Task Dialog Sample
            // Study how to create a revit style dialog using task dialog API by following
            // code snippet.  

            // Creates a Revit task dialog to communicate information to the interactive user.
            TaskDialog mainDialog = new TaskDialog("Hello, Revit!");
            mainDialog.MainInstruction = "Hello, Revit!";
            mainDialog.MainContent =
                "This sample shows how a basic ExternalCommand can be added to the Revit user interface."
                + " It uses a Revit task dialog to communicate information to the interactive user.\n"
                + "The command links below open additional task dialogs with more information.";

            // Add commmandLink to task dialog
            mainDialog.AddCommandLink(TaskDialogCommandLinkId.CommandLink1,
                                      "View information about the Revit installation");
            mainDialog.AddCommandLink(TaskDialogCommandLinkId.CommandLink2,
                                      "View information about the active document");
         
            // Set common buttons and default button. If no CommonButton or CommandLink is added,
            // task dialog will show a Close button by default.
            mainDialog.CommonButtons = TaskDialogCommonButtons.Close;
            mainDialog.DefaultButton = TaskDialogResult.Close;

            // Set footer text. Footer text is usually used to link to the help document.
            mainDialog.FooterText =
                "<a href=\"http://usa.autodesk.com/adsk/servlet/index?siteID=123112&id=2484975 \">"
                + "Click here for the Revit API Developer Center</a>";

            TaskDialogResult tResult = mainDialog.Show();

            // If the user clicks the first command link, a simple Task Dialog 
            // with only a Close button shows information about the Revit installation. 
            if (TaskDialogResult.CommandLink1 == tResult)
            {
                TaskDialog dialog_CommandLink1 = new TaskDialog("Revit Build Information");
                dialog_CommandLink1.MainInstruction =
                    "Revit Version Name is: " + app.VersionName + "\n"
                    + "Revit Version Number is: " + app.VersionNumber + "\n"
                    + "Revit Version Build is: " + app.VersionBuild;

                dialog_CommandLink1.Show();

            }

            // If the user clicks the second command link, a simple Task Dialog 
            // created by static method shows information about the active document.
            else if (TaskDialogResult.CommandLink2 == tResult)
            {
                TaskDialog.Show("Active Document Information",
                    "Active document: " + activeDoc.Title + "\n"
                    + "Active view name: " + activeDoc.ActiveView.Name);
            }
            #endregion

            return Autodesk.Revit.UI.Result.Succeeded;
        }

        #endregion
    }
}

=== CODE_BLOCK_0083 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
        ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            try
            {
                // Verify active document
                if (null == commandData.Application.ActiveUIDocument.Document)
                {
                    message = "Active view is null.";
                    return Autodesk.Revit.UI.Result.Failed;
                }
                
                MainData mainData = new MainData(commandData);
                // Show the dialog
                using (MainForm mainForm = new MainForm(mainData))
                {
                    if (mainForm.ShowDialog() == DialogResult.Cancel)
                    {
                        return Autodesk.Revit.UI.Result.Cancelled;
                    }
                }
            }
            catch (Exception ex)
            {
                message = ex.ToString();
                return Autodesk.Revit.UI.Result.Failed;
            }

            return Autodesk.Revit.UI.Result.Succeeded;
        }
    }
}

=== CODE_BLOCK_0085 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            m_commandData = commandData;
            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "External Tool");

            FamilyInstance inPlace = null;

            AnalyticalElement model = null;

            try
            {
                transaction.Start();
                if (!PrepareData(ref inPlace, ref model))
                {
                    message = "You should select only one in place member which have analytical model.";
                    return Autodesk.Revit.UI.Result.Failed;
                }

                GraphicsData graphicsData = GraphicsDataFactory.CreateGraphicsData(model);
                Properties instanceProperties = new Properties(inPlace);
                InPlaceMembersForm form = new InPlaceMembersForm(instanceProperties, graphicsData);
                if (form.ShowDialog() == System.Windows.Forms.DialogResult.Abort)
                {
                    return Autodesk.Revit.UI.Result.Failed;
                }

                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception e)
            {
                message = e.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
            finally
            {
                transaction.Commit();
            }
        }
      /// <summary>
      /// Search for the In-Place family instance's properties data to be listed
      /// and graphics data to be drawn.
      /// </summary>
      /// <param name="inPlaceMember">properties data to be listed</param>
      /// <param name="model">graphics data to be draw</param>
      /// <returns>Returns true if retrieved this data</returns>
      private bool PrepareData(ref FamilyInstance inPlaceMember, ref AnalyticalElement model)
      {
         ElementSet selected = new ElementSet();
         foreach (ElementId elementId in m_commandData.Application.ActiveUIDocument.Selection.GetElementIds())
         {
            selected.Insert(m_commandData.Application.ActiveUIDocument.Document.GetElement(elementId));
         }

         if (selected.Size != 1)
         {
            return false;
         }

         foreach (object o in selected)
         {
            inPlaceMember = o as FamilyInstance;
            if (null == inPlaceMember)
            {
               return false;
            }
         }
         Document document = inPlaceMember.Document;
         AnalyticalToPhysicalAssociationManager relManager = AnalyticalToPhysicalAssociationManager.GetAnalyticalToPhysicalAssociationManager(document);
         if (relManager != null)
         {
            ElementId associatedElementId = relManager.GetAssociatedElementId(inPlaceMember.Id);
            if (associatedElementId != ElementId.InvalidElementId)
            {
               Element associatedElement = document.GetElement(associatedElementId);
               if (associatedElement != null && associatedElement is AnalyticalElement)
               {
                  model = associatedElement as AnalyticalElement;
               }
            }
         }

         if (null == model)
         {
            return false;
         }

         return true;
      }
   }
}

=== CODE_BLOCK_0087 ===
public Autodesk.Revit.UI.Result Execute(
            ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "External Tool");
            try
            {
                transaction.Start();

                //Create a clear file as parameter file.
                String path = Assembly.GetExecutingAssembly().Location;
                int index = path.LastIndexOf("\\");
                String newPath = path.Substring(0,index);
                newPath += "\\RevitParameters.txt";
                if(File.Exists(newPath))
                {
                    File.Delete(newPath);
                }
                FileStream fs = File.Create(newPath);
                fs.Close();               

                //cache application handle
                Application revitApp = commandData.Application.Application;
                //prepare shared parameter file
                commandData.Application.Application.SharedParametersFilename = newPath;

                //Open shared parameter file
                DefinitionFile parafile = revitApp.OpenSharedParameterFile();

                //get walls category
                Category wallCat = commandData.Application.ActiveUIDocument.Document.Settings.Categories.get_Item(BuiltInCategory.OST_Walls);
                CategorySet categories = revitApp.Create.NewCategorySet();
                categories.Insert(wallCat);

                InstanceBinding binding = revitApp.Create.NewInstanceBinding(categories);

                //Create a group
                DefinitionGroup apiGroup = parafile.Groups.Create("APIGroup");

                //Create a visible "VisibleParam" of text type.
                ExternalDefinitionCreationOptions ExternalDefinitionCreationOptions1 = new ExternalDefinitionCreationOptions("VisibleParam", SpecTypeId.String.Text);
                Definition visibleParamDef = apiGroup.Definitions.Create
                    (ExternalDefinitionCreationOptions1);
                                        ;
                                        BindingMap bindingMap = commandData.Application.ActiveUIDocument.Document.ParameterBindings;
                bindingMap.Insert(visibleParamDef, binding);

                //Create a invisible "InvisibleParam" of text type.
                ExternalDefinitionCreationOptions ExternalDefinitionCreationOptions2 = new ExternalDefinitionCreationOptions("InvisibleParam", SpecTypeId.String.Text);
                Definition invisibleParamDef = apiGroup.Definitions.Create
                    (ExternalDefinitionCreationOptions2);
                bindingMap.Insert(invisibleParamDef, binding);
            }
            catch(Exception e)
            {
                transaction.RollBack();
                message = e.ToString();
                return Autodesk.Revit.UI.Result.Cancelled;
            }
            finally
            {
                transaction.Commit();
            }
            return Autodesk.Revit.UI.Result.Succeeded;
        }

        #endregion
    }
}

=== CODE_BLOCK_0089 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
                                               ref string message,
                                               ElementSet elements)
        {
            try
            {
                Transaction tran = new Transaction(commandData.Application.ActiveUIDocument.Document, "Journaling");
                tran.Start();
                // Create a real operate class
                Journaling deal = new Journaling(commandData);
                deal.Run();     // The main deal operation
                tran.Commit();

                // if everything goes well, return succeeded.
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception ex)
            {
                // If there is something wrong, give error information and return failed
                message = ex.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
        #endregion IExternalCommand Members Implementation
    }
}

=== CODE_BLOCK_0091 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit, ref String message, Autodesk.Revit.DB.ElementSet elements)
        {
            m_revit = revit;
            UnitTypeId = m_revit.Application.ActiveUIDocument.Document.GetUnits().GetFormatOptions(Autodesk.Revit.DB.SpecTypeId.Length).GetUnitTypeId();
            Transaction documentTransaction = new Transaction(revit.Application.ActiveUIDocument.Document, "Document");
            documentTransaction.Start();
            try
            {
                //Get every level by iterating through all elements
                systemLevelsDatum = new List<LevelsDataSource>();
                FilteredElementCollector collector = new FilteredElementCollector(m_revit.Application.ActiveUIDocument.Document);
                ICollection<Element> collection = collector.OfClass(typeof(Level)).ToElements();
                foreach (Element element in collection)
                {
                     Level systemLevel = element as Level;
                     LevelsDataSource levelsDataSourceRow = new LevelsDataSource();

                     levelsDataSourceRow.LevelIDValue = systemLevel.Id;
                     levelsDataSourceRow.Name = systemLevel.Name;

                     Parameter elevationPara = systemLevel.get_Parameter(BuiltInParameter.LEVEL_ELEV);
                     
                     double temValue = Unit.CovertFromAPI(UnitTypeId, elevationPara.AsDouble());
                     double temValue2 = double.Parse(temValue.ToString("#.0"));
                     
                     levelsDataSourceRow.Elevation = temValue2;

                     systemLevelsDatum.Add(levelsDataSourceRow);
                }

                using (LevelsForm displayForm = new LevelsForm(this))
                {
                    displayForm.ShowDialog();
                }
            }
            catch (Exception ex)
            {
                message = ex.Message;
                documentTransaction.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }
            documentTransaction.Commit();
            return Autodesk.Revit.UI.Result.Succeeded;
        }

        ExternalCommandData m_revit;
        public Autodesk.Revit.DB.ForgeTypeId UnitTypeId;
        System.Collections.Generic.List<LevelsDataSource> systemLevelsDatum;
        /// <summary>
        /// Store all levels' datum in system
        /// </summary>
        public System.Collections.Generic.List<LevelsDataSource> SystemLevelsDatum
        {
            get
            {
                return systemLevelsDatum;
            }
            set
            {
                systemLevelsDatum = value;
            }
        }
        #endregion

        #region SetData


        /// <summary>
        /// Set Level
        /// </summary>
        /// <param name="levelID">Pass a Level's ID value</param>
        /// <param name="levelName">Pass a Level's Name</param>
        /// <param name="levelElevation">Pass a Level's Elevation</param>
        /// <returns>True if succeed, else return false</returns>
        public bool SetLevel(Autodesk.Revit.DB.ElementId levelID, String levelName, double levelElevation)
        {
            try
            {
                Level systemLevel = m_revit.Application.ActiveUIDocument.Document.GetElement(levelID) as Level;

                Parameter elevationPara = systemLevel.get_Parameter(BuiltInParameter.LEVEL_ELEV);
                elevationPara.SetValueString(levelElevation.ToString());
                systemLevel.Name = levelName;

                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }
        #endregion

        #region CreateLevel
        /// <summary>
        /// Create a level
        /// </summary>
        /// <param name="levelName">Pass a Level's Name</param>
        /// <param name="levelElevation">Pass a Level's Elevation</param>
        public void CreateLevel(String levelName, double levelElevation)
        {
           Level newLevel = Level.Create(m_revit.Application.ActiveUIDocument.Document, levelElevation);
            Parameter elevationPara = newLevel.get_Parameter(BuiltInParameter.LEVEL_ELEV);
            elevationPara.SetValueString(levelElevation.ToString());

            newLevel.Name = levelName;
        }
        #endregion

        #region DeleteLevel
        /// <summary>
        /// Delete a Level.
        /// </summary>
        /// <param name="IDOfLevel">A Level's ID value</param>
        public void DeleteLevel(ElementId IDOfLevel)
        {

            m_revit.Application.ActiveUIDocument.Document.Delete(IDOfLevel);
        }
        #endregion
    }
}

=== CODE_BLOCK_0093 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                                    ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            m_revit = commandData.Application.Application;
            Transaction documentTransaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "Document");
            documentTransaction.Start();
            // Initialize the helper classes.
            m_combinationDeal = new LoadCombinationDeal(this);
            m_loadCaseDeal = new LoadCaseDeal(this);

            // Prepare some data for the form displaying
            PrepareData();


            // Display the form and wait for the user's operate.
            // This class give some public methods to add or delete LoadUsage and delete LoadCombination
            // The form will use these methods to add or delete dynamically.
            // If the user press cancel button, return Cancelled to roll back All the changes.
            using (LoadsForm displayForm = new LoadsForm(this))
            {
                if (DialogResult.OK != displayForm.ShowDialog())
                {
                    documentTransaction.RollBack();
                    return Autodesk.Revit.UI.Result.Cancelled;
                }
            }

            // If everything goes right, return succeeded.
            documentTransaction.Commit();
            return Autodesk.Revit.UI.Result.Succeeded;
        }

        /// <summary>
        /// Prepare the data for the form displaying.
        /// </summary>
        void PrepareData()
        {
            // Prepare the data of the LoadCase page on form
            m_loadCaseDeal.PrepareData();

            //Prepare the data of the LoadCombination page on form
            m_combinationDeal.PrepareData();
        }

        /// <summary>
        /// Create new Load Combination
        /// </summary>
        /// <param name="name">The new Load Combination name</param>
        /// <param name="typeId">The index of new Load Combination Type</param>
        /// <param name="stateId">The index of new Load Combination State</param>
        /// <returns>true if the creation was successful; otherwise, false</returns>
        public Boolean NewLoadCombination(String name, int typeId, int stateId)
        {
            // In order to refresh the combination DataGridView,
            // We should do like as follow
            m_LoadCombinationMap = new List<LoadCombinationMap>(m_LoadCombinationMap);

            // Just go to run NewLoadCombination method of LoadCombinationDeal class
            return m_combinationDeal.NewLoadCombination(name, typeId, stateId);
        }

        /// <summary>
        /// Delete the selected Load Combination
        /// </summary>
        /// <param name="index">The selected index in the DataGridView</param>
        /// <returns>true if the delete operation was successful; otherwise, false</returns>
        public Boolean DeleteCombination(int index)
        {
            // Just go to run DeleteCombination method of LoadCombinationDeal class
            return m_combinationDeal.DeleteCombination(index);
        }

        /// <summary>
        /// Create a new load combination usage
        /// </summary>
        /// <param name="usageName">The new Load Usage name</param>
        /// <returns>true if the process is successful; otherwise, false</returns> 
        public Boolean NewLoadUsage(String usageName)
        {
            // In order to refresh the usage DataGridView,
            // We should do like as follow
            m_usageMap = new List<UsageMap>(m_usageMap);

            // Just go to run NewLoadUsage method of LoadCombinationDeal class
            return m_combinationDeal.NewLoadUsage(usageName);
        }

        /// <summary>
        /// Delete the selected Load Usage
        /// </summary>
        /// <param name="index">The selected index in the DataGridView</param>
        /// <returns>true if the delete operation was successful; otherwise, false</returns>
        public Boolean DeleteUsage(int index)
        {
            // Just go to run DeleteUsage method of LoadCombinationDeal class
            if (false == m_combinationDeal.DeleteUsage(index))
            {
                return false;
            }

            // In order to refresh the usage DataGridView,
            // We should do like as follow
            if (0 == m_usageMap.Count)
            {
                m_usageMap = new List<UsageMap>();
            }
            return true;
        }

        /// <summary>
        /// Change usage name when the user modify it on the form
        /// </summary>
        /// <param name="oldName">The name before modification</param>
        /// <param name="newName">The name after modification</param>
        /// <returns>true if the modification was successful; otherwise, false</returns>
        public Boolean ModifyUsageName(String oldName, String newName)
        {
            // Just go to run ModifyUsageName method of LoadCombinationDeal class
            return m_combinationDeal.ModifyUsageName(oldName, newName);
        }

        /// <summary>
        /// Add a formula when the user click Add button to new a formula
        /// </summary>
        /// <returns>true if the creation is successful; otherwise, false</returns>
        public Boolean AddFormula()
        {
            // Get the first member in LoadCases as the Case
            LoadCase loadCase = m_loadCases[0];
            if (null == loadCase)
            {
                m_errorInformation = "Can't not find a LoadCase.";
                return false;
            }
            String caseName = loadCase.Name;

            // In order to refresh the formula DataGridView,
            // We should do like as follow
            m_formulaMap = new List<FormulaMap>(m_formulaMap);

            // Run AddFormula method of LoadCombinationDeal class
            return m_combinationDeal.AddFormula(caseName);
        }

        /// <summary>
        /// Delete the selected Load Formula
        /// </summary>
        /// <param name="index">The selected index in the DataGridView</param>
        /// <returns>true if the delete operation was successful; otherwise, false</returns>
        public Boolean DeleteFormula(int index)
        {
            // Just remove that data.
            try
            {
                m_formulaMap.RemoveAt(index);
            }
            catch (Exception e)
            {
                m_errorInformation = e.ToString();
                return false;
            }
            return true;
        }
        #endregion
    }
}

=== CODE_BLOCK_0095 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            m_uiApp = commandData.Application;
            m_uiDoc = m_uiApp.ActiveUIDocument;

            // get the target element to be used for the Distance computation
            ElementSet collection = new ElementSet();
            foreach (ElementId elementId in m_uiDoc.Selection.GetElementIds())
            {
               collection.Insert(m_uiDoc.Document.GetElement(elementId));
            }
            Parameter param = null;
            ElementSet es = new ElementSet();
            foreach (ElementId elementId in m_uiDoc.Selection.GetElementIds())
            {
               es.Insert(m_uiDoc.Document.GetElement(elementId));
            }
            Autodesk.Revit.DB.XYZ targetPoint = getTargetPoint(es);

            // get all the divided surfaces in the Revit document
            List<DividedSurface> dsList = GetElements<DividedSurface>();

            foreach (DividedSurface ds in dsList)
            {
                GridNode gn = new GridNode();
                int u = 0;
                while (u < ds.NumberOfUGridlines)
                {
                    gn.UIndex = u;
                    int v = 0;
                    while (v < ds.NumberOfVGridlines)
                    {
                        gn.VIndex = v;
                        if (ds.IsSeedNode(gn))
                        {
                            FamilyInstance familyinstance = ds.GetTileFamilyInstance(gn, 0);
                            if (familyinstance != null)
                            {
                               param = familyinstance.LookupParameter("Distance");
                                if (param == null) throw new Exception("Panel family must have a Distance instance parameter");
                                else
                                {
                                    LocationPoint loc = familyinstance.Location as LocationPoint;
                                    XYZ panelPoint = loc.Point;

                                    double d = Math.Sqrt(Math.Pow((targetPoint.X - panelPoint.X), 2) + Math.Pow((targetPoint.Y - panelPoint.Y), 2) + Math.Pow((targetPoint.Z - panelPoint.Z), 2));
                                    param.Set(d);

                                    // uncomment the following lines to create points and lines showing where the distance measurement is made
                                    //ReferencePoint rp = m_doc.FamilyCreate.NewReferencePoint(panelPoint);
                                    //Line line = m_app.Create.NewLine(targetPoint, panelPoint, true);
                                    //Plane plane = m_app.Create.NewPlane(targetPoint.Cross(panelPoint), panelPoint);
                                    //SketchPlane skplane = m_doc.FamilyCreate.NewSketchPlane(plane);
                                    //ModelCurve modelcurve = m_doc.FamilyCreate.NewModelCurve(line, skplane);
                                }
                            }
                        }
                        v = v + 1;
                    }
                    u = u + 1;
                }
            }
            return Autodesk.Revit.UI.Result.Succeeded;
        }

        /// <summary>
        /// Get the Autodesk.Revit.DB.XYZ point of the selected target element
        /// </summary>
        /// <param name="collection">Selected elements</param>
        /// <returns>the Autodesk.Revit.DB.XYZ point of the selected target element</returns>
        Autodesk.Revit.DB.XYZ getTargetPoint(ElementSet collection)
        {
            FamilyInstance targetElement = null;
            if (collection.Size != 1)
            {
                throw new Exception("You must select one component from which the distance to panels will be measured");
            }
            else
            {
                foreach (Autodesk.Revit.DB.Element e in collection)
                {
                    targetElement = e as FamilyInstance;
                }
            }

            if (null == targetElement)
            {
                throw new Exception("You must select one family instance from which the distance to panels will be measured");
            }
            LocationPoint targetLocation = targetElement.Location as LocationPoint;
            return targetLocation.Point;
        }

        protected List<T> GetElements<T>() where T : Element
        {
           List<T> returns = new List<T>();
           FilteredElementCollector collector = new FilteredElementCollector(m_uiDoc.Document);
           ICollection<Element> founds = collector.OfClass(typeof(T)).ToElements();
           foreach (Element elem in founds)
           {
              returns.Add(elem as T);
           }
           return returns;
        }


    }
}

=== CODE_BLOCK_0097 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         // store the active Revit document
         m_document = commandData.Application.ActiveUIDocument.Document;

         DividedSurface ds = GetDividedSurface();
         if (null == ds)
         {
            message = "Open the family file from the sample folder first.";
            return Result.Failed;
         }
         IEnumerable<ElementId> planes = GetPlanes();
         IEnumerable<ElementId> lines = GetLines();

         Transaction act = new Transaction(m_document);
         act.Start("AddRemoveIntersects");
         try
         {
            // step 1: divide the surface with reference planes and levels
            foreach (ElementId id in planes)
            {
               if (ds.CanBeIntersectionElement(id))
               {
                  ds.AddIntersectionElement(id);
               }
            }

            // step 2: remove all the reference planes and level intersection elements
            IEnumerable<ElementId> intersects = ds.GetAllIntersectionElements();

            foreach (ElementId id in intersects)
            {
               ds.RemoveIntersectionElement(id);
            }
            
            // step 3: divide the surface with model lines instead
            foreach (ElementId id in lines)
            {
               if (ds.CanBeIntersectionElement(id))
               {
                  ds.AddIntersectionElement(id);
               }
            }
         }
         catch (Exception)
         {
            act.RollBack();
         }
         finally
         {
            act.Commit();
         }

         return Autodesk.Revit.UI.Result.Succeeded;
      }

      private DividedSurface GetDividedSurface()
      {
         return m_document.GetElement(new ElementId(31519L)) as DividedSurface;
      }

      private IEnumerable<ElementId> GetPlanes()
      {
         // 1027, 1071 & 1072 are ids of the reference planes and levels drawn in the family file
         yield return new ElementId(1027L); 
         yield return new ElementId(1071L);
         yield return new ElementId(1072L);
      }

      private IEnumerable<ElementId> GetLines()
      {
         // the "31xxx" numberic values are ids of the model lines drawn in the family file
         yield return new ElementId(31170L);
         yield return new ElementId(31206L);
         yield return new ElementId(31321L);
         yield return new ElementId(31343L);
         yield return new ElementId(31377L);
         yield return new ElementId(31395L);
      }

      /// <summary>
      /// Get element by its Id
      /// </summary>
      /// <typeparam name="T"></typeparam>
      /// <param name="eid"></param>
      /// <returns></returns>
      public T GetElement<T>(long eid) where T : Element
      {
         return m_document.GetElement(new ElementId(eid)) as T;
      }
   }
}

=== CODE_BLOCK_0099 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         using (frmPanelArea form = new frmPanelArea(commandData))
         {
            // The form is created successfully
            if (null != form && !form.IsDisposed)
            {
               form.ShowDialog();
            }
         }

         return Autodesk.Revit.UI.Result.Succeeded;
      }
   }
}

=== CODE_BLOCK_0101 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         ExternalCommandData cdata = commandData;
         Autodesk.Revit.ApplicationServices.Application app = commandData.Application.Application;
         app = commandData.Application.Application;
         Document doc = commandData.Application.ActiveUIDocument.Document;

         Transaction transaction = new Transaction(doc, "MakeExtrusionForm");
         transaction.Start();

         // Create one profile
         ReferenceArray ref_ar = new ReferenceArray();

         Autodesk.Revit.DB.XYZ ptA = new Autodesk.Revit.DB.XYZ(10, 10, 0);
         Autodesk.Revit.DB.XYZ ptB = new Autodesk.Revit.DB.XYZ(90, 10, 0);
         ModelCurve modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);

         ptA = new Autodesk.Revit.DB.XYZ(90, 10, 0);
         ptB = new Autodesk.Revit.DB.XYZ(10, 90, 0);
         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);

         ptA = new Autodesk.Revit.DB.XYZ(10, 90, 0);
         ptB = new Autodesk.Revit.DB.XYZ(10, 10, 0);
         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);

         // The extrusion form direction
         Autodesk.Revit.DB.XYZ direction = new Autodesk.Revit.DB.XYZ(0, 0, 50);

         Autodesk.Revit.DB.Form form = doc.FamilyCreate.NewExtrusionForm(true, ref_ar, direction);

         transaction.Commit();

         return Autodesk.Revit.UI.Result.Succeeded;
      }
      #endregion
   }

   /// <summary>
   /// A class inherits IExternalCommand interface.
   /// This class show how to create cap form by Revit API.
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class MakeCapForm : IExternalCommand
   {
      #region Class Interface Implementation
      /// <summary>
      /// Implement this method as an external command for Revit.
      /// </summary>
      /// <param name="commandData">An object that is passed to the external application 
      /// which contains data related to the command, 
      /// such as the application object and active view.</param>
      /// <param name="message">A message that can be set by the external application 
      /// which will be displayed if a failure or cancellation is returned by 
      /// the external command.</param>
      /// <param name="elements">A set of elements to which the external application 
      /// can add elements that are to be highlighted in case of failure or cancellation.</param>
      /// <returns>Return the status of the external command. 
      /// A result of Succeeded means that the API external method functioned as expected. 
      /// Cancelled can be used to signify that the user cancelled the external operation 
      /// at some point. Failure should be returned if the application is unable to proceed with 
      /// the operation.</returns>
      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         ExternalCommandData cdata = commandData;
         Autodesk.Revit.ApplicationServices.Application app = commandData.Application.Application;
         app = commandData.Application.Application;
         Document doc = commandData.Application.ActiveUIDocument.Document;

         Transaction transaction = new Transaction(doc, "MakeCapForm");
         transaction.Start();

         // Create one profile
         ReferenceArray ref_ar = new ReferenceArray();

         Autodesk.Revit.DB.XYZ ptA = new Autodesk.Revit.DB.XYZ(10, 10, 0);
         Autodesk.Revit.DB.XYZ ptB = new Autodesk.Revit.DB.XYZ(100, 10, 0);
         Line line = Line.CreateBound(ptA, ptB);
         ModelCurve modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);

         ptA = new Autodesk.Revit.DB.XYZ(100, 10, 0);
         ptB = new Autodesk.Revit.DB.XYZ(50, 50, 0);
         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);

         ptA = new Autodesk.Revit.DB.XYZ(50, 50, 0);
         ptB = new Autodesk.Revit.DB.XYZ(10, 10, 0);
         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);

         Autodesk.Revit.DB.Form form = doc.FamilyCreate.NewFormByCap(true, ref_ar);

         transaction.Commit();

         return Autodesk.Revit.UI.Result.Succeeded;
      }
      #endregion
   }

   /// <summary>
   /// A class inherits IExternalCommand interface.
   /// This class show how to create revolve form by Revit API.
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class MakeRevolveForm : IExternalCommand
   {
      #region Class Interface Implementation
      /// <summary>
      /// Implement this method as an external command for Revit.
      /// </summary>
      /// <param name="commandData">An object that is passed to the external application 
      /// which contains data related to the command, 
      /// such as the application object and active view.</param>
      /// <param name="message">A message that can be set by the external application 
      /// which will be displayed if a failure or cancellation is returned by 
      /// the external command.</param>
      /// <param name="elements">A set of elements to which the external application 
      /// can add elements that are to be highlighted in case of failure or cancellation.</param>
      /// <returns>Return the status of the external command. 
      /// A result of Succeeded means that the API external method functioned as expected. 
      /// Cancelled can be used to signify that the user cancelled the external operation 
      /// at some point. Failure should be returned if the application is unable to proceed with 
      /// the operation.</returns>
      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         ExternalCommandData cdata = commandData;
         Autodesk.Revit.ApplicationServices.Application app = commandData.Application.Application;
         app = commandData.Application.Application;
         Document doc = commandData.Application.ActiveUIDocument.Document;

         Transaction transaction = new Transaction(doc, "MakeRevolveForm");
         transaction.Start();

         // Create one profile
         ReferenceArray ref_ar = new ReferenceArray();
         Autodesk.Revit.DB.XYZ norm = Autodesk.Revit.DB.XYZ.BasisZ;

         Autodesk.Revit.DB.XYZ ptA = new Autodesk.Revit.DB.XYZ(0, 0, 10);
         Autodesk.Revit.DB.XYZ ptB = new Autodesk.Revit.DB.XYZ(100, 0, 10);
         ModelCurve modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB, norm);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);

         ptA = new Autodesk.Revit.DB.XYZ(100, 0, 10);
         ptB = new Autodesk.Revit.DB.XYZ(100, 100, 10);
         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB, norm);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);

         ptA = new Autodesk.Revit.DB.XYZ(100, 100, 10);
         ptB = new Autodesk.Revit.DB.XYZ(0, 0, 10);
         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB, norm);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);

         // Create axis for revolve form
         ptA = new Autodesk.Revit.DB.XYZ(-5, 0, 10);
         ptB = new Autodesk.Revit.DB.XYZ(-5, 10, 10);
         ModelCurve axis = FormUtils.MakeLine(commandData.Application, ptA, ptB, norm);
         axis.ChangeToReferenceLine();

         Autodesk.Revit.DB.FormArray form = doc.FamilyCreate.NewRevolveForms(true, ref_ar, axis.GeometryCurve.Reference, 0, Math.PI / 4);

         transaction.Commit();

         return Autodesk.Revit.UI.Result.Succeeded;
      }
      #endregion
   }

   /// <summary>
   /// A class inherits IExternalCommand interface.
   /// This class show how to create swept blend form by Revit API.
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class MakeSweptBlendForm : IExternalCommand
   {
      #region Class Interface Implementation
      /// <summary>
      /// Implement this method as an external command for Revit.
      /// </summary>
      /// <param name="commandData">An object that is passed to the external application 
      /// which contains data related to the command, 
      /// such as the application object and active view.</param>
      /// <param name="message">A message that can be set by the external application 
      /// which will be displayed if a failure or cancellation is returned by 
      /// the external command.</param>
      /// <param name="elements">A set of elements to which the external application 
      /// can add elements that are to be highlighted in case of failure or cancellation.</param>
      /// <returns>Return the status of the external command. 
      /// A result of Succeeded means that the API external method functioned as expected. 
      /// Cancelled can be used to signify that the user cancelled the external operation 
      /// at some point. Failure should be returned if the application is unable to proceed with 
      /// the operation.</returns>
      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         ExternalCommandData cdata = commandData;
         Autodesk.Revit.ApplicationServices.Application app = commandData.Application.Application;
         app = commandData.Application.Application;
         Document doc = commandData.Application.ActiveUIDocument.Document;

         Transaction transaction = new Transaction(doc, "MakeSweptBlendForm");
         transaction.Start();

         // Create first profile
         ReferenceArray ref_ar = new ReferenceArray();
         Autodesk.Revit.DB.XYZ ptA = new Autodesk.Revit.DB.XYZ(10, 10, 0);
         Autodesk.Revit.DB.XYZ ptB = new Autodesk.Revit.DB.XYZ(50, 10, 0);
         ModelCurve modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);

         ptA = new Autodesk.Revit.DB.XYZ(50, 10, 0);
         ptB = new Autodesk.Revit.DB.XYZ(10, 50, 0);
         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);

         ptA = new Autodesk.Revit.DB.XYZ(10, 50, 0);
         ptB = new Autodesk.Revit.DB.XYZ(10, 10, 0);
         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);

         // Create second profile
         ReferenceArray ref_ar2 = new ReferenceArray();
         ptA = new Autodesk.Revit.DB.XYZ(10, 10, 90);
         ptB = new Autodesk.Revit.DB.XYZ(80, 10, 90);
         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         ref_ar2.Append(modelcurve.GeometryCurve.Reference);

         ptA = new Autodesk.Revit.DB.XYZ(80, 10, 90);
         ptB = new Autodesk.Revit.DB.XYZ(10, 50, 90);
         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         ref_ar2.Append(modelcurve.GeometryCurve.Reference);

         ptA = new Autodesk.Revit.DB.XYZ(10, 50, 90);
         ptB = new Autodesk.Revit.DB.XYZ(10, 10, 90);
         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         ref_ar2.Append(modelcurve.GeometryCurve.Reference);

         // Add profiles
         ReferenceArrayArray profiles = new ReferenceArrayArray();
         profiles.Append(ref_ar);
         profiles.Append(ref_ar2);

         // Create path for swept blend form
         ReferenceArray path = new ReferenceArray();
         ptA = new Autodesk.Revit.DB.XYZ(10, 10, 0);
         ptB = new Autodesk.Revit.DB.XYZ(10, 10, 90);
         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);
         path.Append(modelcurve.GeometryCurve.Reference);

         Autodesk.Revit.DB.Form form = doc.FamilyCreate.NewSweptBlendForm(true, path, profiles);

         transaction.Commit();

         return Autodesk.Revit.UI.Result.Succeeded;
      }
      #endregion
   }

   /// <summary>
   /// A class inherits IExternalCommand interface.
   /// This class show how to create loft form by Revit API.
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class MakeLoftForm : IExternalCommand
   {
      #region Class Interface Implementation
      /// <summary>
      /// Implement this method as an external command for Revit.
      /// </summary>
      /// <param name="commandData">An object that is passed to the external application 
      /// which contains data related to the command, 
      /// such as the application object and active view.</param>
      /// <param name="message">A message that can be set by the external application 
      /// which will be displayed if a failure or cancellation is returned by 
      /// the external command.</param>
      /// <param name="elements">A set of elements to which the external application 
      /// can add elements that are to be highlighted in case of failure or cancellation.</param>
      /// <returns>Return the status of the external command. 
      /// A result of Succeeded means that the API external method functioned as expected. 
      /// Cancelled can be used to signify that the user cancelled the external operation 
      /// at some point. Failure should be returned if the application is unable to proceed with 
      /// the operation.</returns>
      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         ExternalCommandData cdata = commandData;
         Autodesk.Revit.ApplicationServices.Application app = commandData.Application.Application;
         app = commandData.Application.Application;
         Document doc = commandData.Application.ActiveUIDocument.Document;

         Transaction transaction = new Transaction(doc, "MakeLoftForm");
         transaction.Start();

         // Create profiles array
         ReferenceArrayArray ref_ar_ar = new ReferenceArrayArray();

         // Create first profile
         ReferenceArray ref_ar = new ReferenceArray();

         int y = 100;
         int x = 50;
         Autodesk.Revit.DB.XYZ ptA = new Autodesk.Revit.DB.XYZ(-x, y, 0);
         Autodesk.Revit.DB.XYZ ptB = new Autodesk.Revit.DB.XYZ(x, y, 0);
         Autodesk.Revit.DB.XYZ ptC = new Autodesk.Revit.DB.XYZ(0, y + 10, 10);
         ModelCurve modelcurve = FormUtils.MakeArc(commandData.Application, ptA, ptB, ptC);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);
         ref_ar_ar.Append(ref_ar);


         // Create second profile
         ref_ar = new ReferenceArray();

         y = 40;
         ptA = new Autodesk.Revit.DB.XYZ(-x, y, 5);
         ptB = new Autodesk.Revit.DB.XYZ(x, y, 5);
         ptC = new Autodesk.Revit.DB.XYZ(0, y, 25);
         modelcurve = FormUtils.MakeArc(commandData.Application, ptA, ptB, ptC);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);
         ref_ar_ar.Append(ref_ar);

         // Create third profile
         ref_ar = new ReferenceArray();

         y = -20;
         ptA = new Autodesk.Revit.DB.XYZ(-x, y, 0);
         ptB = new Autodesk.Revit.DB.XYZ(x, y, 0);
         ptC = new Autodesk.Revit.DB.XYZ(0, y, 15);
         modelcurve = FormUtils.MakeArc(commandData.Application, ptA, ptB, ptC);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);
         ref_ar_ar.Append(ref_ar);

         // Create fourth profile
         ref_ar = new ReferenceArray();

         y = -60;
         ptA = new Autodesk.Revit.DB.XYZ(-x, y, 0);
         ptB = new Autodesk.Revit.DB.XYZ(x, y, 0);
         ptC = new Autodesk.Revit.DB.XYZ(0, y + 10, 20);
         modelcurve = FormUtils.MakeArc(commandData.Application, ptA, ptB, ptC);
         ref_ar.Append(modelcurve.GeometryCurve.Reference);
         ref_ar_ar.Append(ref_ar);

         Autodesk.Revit.DB.Form form = doc.FamilyCreate.NewLoftForm(true, ref_ar_ar);

         transaction.Commit();

         return Autodesk.Revit.UI.Result.Succeeded;
      }
      #endregion
   }

   /// <summary>
   /// This class is utility class for form creation.
   /// </summary>
   public class FormUtils
   {
      #region Class Implementation
      /// <summary>
      /// Create arc element by three points
      /// </summary>
      /// <param name="app">revit application</param>
      /// <param name="ptA">point a</param>
      /// <param name="ptB">point b</param>
      /// <param name="ptC">point c</param>
      /// <returns></returns>
      public static ModelCurve MakeArc(UIApplication app, Autodesk.Revit.DB.XYZ ptA, Autodesk.Revit.DB.XYZ ptB, Autodesk.Revit.DB.XYZ ptC)
      {
         Document doc = app.ActiveUIDocument.Document;
         Arc arc = Arc.Create(ptA, ptB, ptC);
         // Create three lines and a plane by the points
         Line line1 = Line.CreateBound(ptA, ptB);
         Line line2 = Line.CreateBound(ptB, ptC);
         Line line3 = Line.CreateBound(ptC, ptA);
         CurveLoop ca = new CurveLoop();
         ca.Append(line1);
         ca.Append(line2);
         ca.Append(line3);

            Plane plane = ca.GetPlane();// app.Application.Create.NewPlane(ca);
         SketchPlane skplane = SketchPlane.Create(doc, plane);
         // Create arc here
         ModelCurve modelcurve = doc.FamilyCreate.NewModelCurve(arc, skplane);
         return modelcurve;
      }

      /// <summary>
      /// Create line element
      /// </summary>
      /// <param name="app">revit application</param>
      /// <param name="ptA">start point</param>
      /// <param name="ptB">end point</param>
      /// <returns></returns>
      public static ModelCurve MakeLine(UIApplication app, Autodesk.Revit.DB.XYZ ptA, Autodesk.Revit.DB.XYZ ptB)
      {
         Document doc = app.ActiveUIDocument.Document;
         // Create plane by the points
         Line line = Line.CreateBound(ptA, ptB);
         Autodesk.Revit.DB.XYZ norm = ptA.CrossProduct(ptB);
         if (norm.GetLength() == 0) norm = Autodesk.Revit.DB.XYZ.BasisZ;
         Plane plane = Plane.CreateByNormalAndOrigin(norm, ptB);
         SketchPlane skplane = SketchPlane.Create(doc, plane);
         // Create line here
         ModelCurve modelcurve = doc.FamilyCreate.NewModelCurve(line, skplane);
         return modelcurve;
      }

      /// <summary>
      /// Create line element
      /// </summary>
      /// <param name="app">revit application</param>
      /// <param name="ptA">start point</param>
      /// <param name="ptB">end point</param>
      /// <returns></returns>
      public static ModelCurve MakeLine(UIApplication app, Autodesk.Revit.DB.XYZ ptA, Autodesk.Revit.DB.XYZ ptB, Autodesk.Revit.DB.XYZ norm)
      {
         Document doc = app.ActiveUIDocument.Document;
         // Create plane by the points
         Line line = Line.CreateBound(ptA, ptB);
         Plane plane = Plane.CreateByNormalAndOrigin(norm, ptB);
         SketchPlane skplane = SketchPlane.Create(doc, plane);
         // Create line here
         ModelCurve modelcurve = doc.FamilyCreate.NewModelCurve(line, skplane);
         return modelcurve;
      }
      #endregion
   }
}

=== CODE_BLOCK_0103 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         m_app = commandData.Application.Application;
         m_doc = commandData.Application.ActiveUIDocument.Document;

         // step 1: get all the divided surfaces in the Revit document
         List<DividedSurface> dsList = GetElements<DividedSurface>();

         foreach (DividedSurface ds in dsList)
         {
            // step 2: get the panel instances from the divided surface
            List<FamilyInstance> fiList = GetFamilyInstances(ds);
            foreach (FamilyInstance inst in fiList)
            {
               // step 3: compute the length and angle and set them to the parameters
               InstParameters instParams = GetParams(inst);
               EdgeArray edges = GetEdges(inst);
               SetParams(m_doc, edges, instParams);
            }
         }
         return Autodesk.Revit.UI.Result.Succeeded;
      }

      /// <summary>
      /// Get all the panel instances from a divided surface
      /// </summary>
      /// <param name="ds">The divided surface with some panels</param>
      /// <returns>A list containing all the panel instances</returns>
      private List<FamilyInstance> GetFamilyInstances(DividedSurface ds)
      {
         List<FamilyInstance> fiList = new List<FamilyInstance>();

         for (int u = 0; u < ds.NumberOfUGridlines; ++u)
         {
            for (int v = 0; v < ds.NumberOfVGridlines; ++v)
            {
               GridNode gn = new GridNode(u, v);
               FamilyInstance familyInstance = ds.GetTileFamilyInstance(gn, 0);
               if (familyInstance != null)
               {
                  fiList.Add(familyInstance);
               }
            }
         }
         return fiList;
      }

      /// <summary>
      /// Get all the edges from the given family instance
      /// </summary>
      /// <param name="familyInstance">The family instance with some edges</param>
      /// <returns>Edges of the family instance</returns>
      private EdgeArray GetEdges(FamilyInstance familyInstance)
      {
         Autodesk.Revit.DB.Options opt = m_app.Create.NewGeometryOptions();
         opt.ComputeReferences = true;
         Autodesk.Revit.DB.GeometryElement geomElem = familyInstance.get_Geometry(opt);
         //foreach (GeometryObject geomObject1 in geomElem.Objects)
         IEnumerator<GeometryObject> Objects = geomElem.GetEnumerator();
         while (Objects.MoveNext())
         {
            GeometryObject geomObject1 = Objects.Current;

            Solid solid = null;
            // partial panels
            if (geomObject1 is Solid)
            {
               solid = (Solid)geomObject1;
               if (null == solid)
                  continue;
            }
            // non-partial panels
            else if (geomObject1 is Autodesk.Revit.DB.GeometryInstance)
            {
               GeometryInstance geomInst = geomObject1 as GeometryInstance;
               //foreach (Object geomObj in geomInst.SymbolGeometry.Objects)
               IEnumerator<GeometryObject> Objects1 = geomInst.SymbolGeometry.GetEnumerator();
               while (Objects1.MoveNext())
               {
                  Object geomObj = Objects1.Current;

                  solid = geomObj as Solid;
                  if (solid != null)
                     break;
               }
            }

            if (null == solid ||    // the solid can't be null
                null == solid.Faces || 0 == solid.Faces.Size ||   // the solid must have 1 or more faces
                null == solid.Faces.get_Item(0) ||   // the solid must have a NOT-null face
                null == solid.Faces.get_Item(0).EdgeLoops || 0 == solid.Faces.get_Item(0).EdgeLoops.Size) // the face must have some edges
               continue;

            return solid.Faces.get_Item(0).EdgeLoops.get_Item(0);
         }

         return null;
      }

      /// <summary>
      /// Compute the length and angle data of the edges, then update the parameters with these values
      /// </summary>
      /// <param name="document">The active document.</param>
      /// <param name="edge_ar">The edges of the curtain panel</param>
      /// <param name="instParams">The parameters which records the length and angle data</param>
      private void SetParams(Document document, EdgeArray edge_ar, InstParameters instParams)
      {
         double length4 = 0d;
         double angle3 = 0d;
         double angle4 = 0d;
         Edge edge1 = edge_ar.get_Item(0);
         Edge edge2 = edge_ar.get_Item(1);
         Edge edge3 = edge_ar.get_Item(2);
         double length1 = edge1.ApproximateLength;
         double length2 = edge2.ApproximateLength;
         double length3 = edge3.ApproximateLength;
         double angle1 = AngleBetweenEdges(edge1, edge2);
         double angle2 = AngleBetweenEdges(edge2, edge3);

         if (edge_ar.Size == 3)
         {
            angle3 = AngleBetweenEdges(edge3, edge1);
         }
         else if (edge_ar.Size > 3)
         {
            Edge edge4 = edge_ar.get_Item(3);
            length4 = edge4.ApproximateLength;
            angle3 = AngleBetweenEdges(edge3, edge4);
            angle4 = AngleBetweenEdges(edge4, edge1);
         }

         using (Transaction transaction = new Transaction(document, "Update family instance parameters"))
         {
            transaction.Start();

            instParams["Length1"].Set(length1);
            instParams["Length2"].Set(length2);
            instParams["Length3"].Set(length3);
            instParams["Length4"].Set(length4);
            instParams["Angle1"].Set(angle1);
            instParams["Angle2"].Set(angle2);
            instParams["Angle3"].Set(angle3);
            instParams["Angle4"].Set(angle4);

            transaction.Commit();
         }
      }

      /// <summary>
      /// Compute the angle between two edges
      /// </summary>
      /// <param name="edgeA">The 1st edge</param>
      /// <param name="edgeB">The 2nd edge</param>
      /// <returns>The angle of the 2 edges</returns>
      private double AngleBetweenEdges(Edge edgeA, Edge edgeB)
      {
         Autodesk.Revit.DB.XYZ vectorA = null;
         Autodesk.Revit.DB.XYZ vectorB = null;

         // find coincident vertices
         Autodesk.Revit.DB.XYZ A_0 = edgeA.Evaluate(0);
         Autodesk.Revit.DB.XYZ A_1 = edgeA.Evaluate(1);
         Autodesk.Revit.DB.XYZ B_0 = edgeB.Evaluate(0);
         Autodesk.Revit.DB.XYZ B_1 = edgeB.Evaluate(1);
         if (A_0.IsAlmostEqualTo(B_0))
         {
            vectorA = edgeA.ComputeDerivatives(0).BasisX.Normalize();
            vectorB = edgeA.ComputeDerivatives(0).BasisX.Normalize();
         }
         else if (A_0.IsAlmostEqualTo(B_1))
         {
            vectorA = edgeA.ComputeDerivatives(0).BasisX.Normalize();
            vectorB = edgeB.ComputeDerivatives(1).BasisX.Normalize();
         }
         else if (A_1.IsAlmostEqualTo(B_0))
         {
            vectorA = edgeA.ComputeDerivatives(1).BasisX.Normalize();
            vectorB = edgeB.ComputeDerivatives(0).BasisX.Normalize();
         }
         else if (A_1.IsAlmostEqualTo(B_1))
         {
            vectorA = edgeA.ComputeDerivatives(1).BasisX.Normalize();
            vectorB = edgeB.ComputeDerivatives(1).BasisX.Normalize();
         }

         if (A_1.IsAlmostEqualTo(B_0) || A_0.IsAlmostEqualTo(B_1)) vectorA = vectorA.Negate();

         if (null == vectorA || null == vectorB)
         {
            return 0d;
         }
         double angle = Math.Acos(vectorA.DotProduct(vectorB));
         return angle;
      }

      /// <summary>
      /// Get all the parameters and store them into a list
      /// </summary>
      /// <param name="familyInstance">The instance of a curtain panel</param>
      /// <returns>A list containing all the required parameters</returns>
      private InstParameters GetParams(FamilyInstance familyInstance)
      {
         InstParameters iParams = new InstParameters();
         Parameter L1 = familyInstance.LookupParameter("Length1");
         Parameter L2 = familyInstance.LookupParameter("Length2");
         Parameter L3 = familyInstance.LookupParameter("Length3");
         Parameter L4 = familyInstance.LookupParameter("Length4");
         Parameter A1 = familyInstance.LookupParameter("Angle1");
         Parameter A2 = familyInstance.LookupParameter("Angle2");
         Parameter A3 = familyInstance.LookupParameter("Angle3");
         Parameter A4 = familyInstance.LookupParameter("Angle4");

         if (L1 == null || L2 == null || L3 == null || L4 == null || A1 == null || A2 == null || A3 == null || A4 == null)
         {
            string errorstring = "Panel family: " + familyInstance.Id.ToString() + " '" + familyInstance.Symbol.Family.Name + "' must have instance parameters Length1, Length2, Length3, Length4, Angle1, Angle2, Angle3, and Angle4";
            TaskDialog.Show("Revit", errorstring);
            //   throw new ArgumentException(errorstring);
         }

         iParams["Length1"] = L1;
         iParams["Length2"] = L2;
         iParams["Length3"] = L3;
         iParams["Length4"] = L4;
         iParams["Angle1"] = A1;
         iParams["Angle2"] = A2;
         iParams["Angle3"] = A3;
         iParams["Angle4"] = A4;

         return iParams;
      }

      protected List<T> GetElements<T>() where T : Element
      {
         List<T> returns = new List<T>();
         FilteredElementCollector collector = new FilteredElementCollector(m_doc);
         ICollection<Element> founds = collector.OfClass(typeof(T)).ToElements();
         foreach (Element elem in founds)
         {
            returns.Add(elem as T);
         }
         return returns;
      }

   }

   /// <summary>
   /// This class contains a dictionary which stores the parameter and parameter name pairs
   /// </summary>
   class InstParameters
   {
      private Dictionary<string, Parameter> m_parameters = new Dictionary<string, Parameter>(8);

      /// <summary>
      /// Get/Set the parameter by its name
      /// </summary>
      /// <param name="index">the name of the parameter</param>
      /// <returns>The parameter which matches the name</returns>
      public Parameter this[string index]
      {
         get
         {
            return m_parameters[index];
         }
         set
         {
            m_parameters[index] = value;
         }
      }
   }
}

=== CODE_BLOCK_0105 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
                                               ref string message,
                                               ElementSet elements)
        {
            try
            {
                Transaction documentTransaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "Document");
                documentTransaction.Start();
                // Get the application of revit
                Autodesk.Revit.UI.UIApplication revit = commandData.Application;

                // New a real operation class.
                ModelLines deal = new ModelLines(revit);

                // The main deal operation
                deal.Run();
                documentTransaction.Commit();

                // if everything goes well, return succeeded.
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception ex)
            {
                // If any error, give error information and return failed
                message = ex.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }           
        }
    }
}

=== CODE_BLOCK_0107 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
          ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         Transaction newTran = null;
         try
         {
            UIDocument uiDoc = commandData.Application.ActiveUIDocument;
            if (null == uiDoc)
            {
               message = "this command needs to be run in an active document.";
               return Result.Failed;
            }
            Document doc = uiDoc.Document;

            ICollection<ElementId> selectedId = uiDoc.Selection.GetElementIds();
            if (1 != selectedId.Count)
            {
               message = "Please select a multistory stairs before running this command.";
               return Result.Failed;
            }
            MultistoryStairs mStairs = doc.GetElement(selectedId.ElementAt(0)) as MultistoryStairs;
            if (null == mStairs)
            {
               message = "Please select a multistory stairs before running this command.";
               return Result.Failed;
            }

            View currentView = doc.ActiveView;
            if (null == currentView || currentView.ViewType != ViewType.Elevation || !currentView.CanBePrinted)
            {
               message = "The current view should be an elevation view to allow user to select levels.";
               return Result.Failed;
            }

            // allow the user to select the stairs to add stairs.
            LevelSelectionFilter selectionFilter = new LevelSelectionFilter(mStairs, OperationAction.Add);
            IList<Reference> userSelectedRefs = uiDoc.Selection.PickObjects(Autodesk.Revit.UI.Selection.ObjectType.Element, selectionFilter);
            IEnumerable<ElementId> userSelectedIds = from refer in userSelectedRefs select refer.ElementId;

            // start the transaction and add the stairs into the multistory stairs.
            newTran = new Transaction(doc, "Add Stairs to Multistory Stairs");
            newTran.Start();
            mStairs.AddStairsByLevelIds(new HashSet<ElementId>(userSelectedIds));
            newTran.Commit();

            return Autodesk.Revit.UI.Result.Succeeded;
         }
         catch (Exception e)
         {
            message = e.Message;
            if ((newTran != null) && newTran.HasStarted() && !newTran.HasEnded())
               newTran.RollBack();
            return Autodesk.Revit.UI.Result.Failed;
         }
      }
      #endregion IExternalCommand Members Implementation
   }


   /// <summary>
   /// A command that remove the stairs from multistory stairs by picking the levels (have aligned stairs to)
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   [Autodesk.Revit.Attributes.Journaling(Autodesk.Revit.Attributes.JournalingMode.NoCommandData)]
   public class RemoveStairsCommand : IExternalCommand
   {
      #region IExternalCommand Members Implementation
      /// <summary>
      /// Implement this method as an external command for Revit.
      /// </summary>
      /// <param name="commandData">An object that is passed to the external application 
      /// which contains data related to the command, 
      /// such as the application object and active view.</param>
      /// <param name="message">A message that can be set by the external application 
      /// which will be displayed if a failure or cancellation is returned by 
      /// the external command.</param>
      /// <param name="elements">A set of elements to which the external application 
      /// can add elements that are to be highlighted in case of failure or cancellation.</param>
      /// <returns>Return the status of the external command. 
      /// A result of Succeeded means that the API external method functioned as expected. 
      /// Cancelled can be used to signify that the user canceled the external operation 
      /// at some point. Failure should be returned if the application is unable to proceed with 
      /// the operation.</returns>
      public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
          ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         Transaction newTran = null;
         try
         {
            UIDocument uiDoc = commandData.Application.ActiveUIDocument;
            if (null == uiDoc)
            {
               message = "this command needs to be run in an active document.";
               return Result.Failed;
            }
            Document doc = uiDoc.Document;

            ICollection<ElementId> selectedId = uiDoc.Selection.GetElementIds();
            if (1 != selectedId.Count)
            {
               message = "Please select a multistory stairs before running this command.";
               return Result.Failed;
            }
            MultistoryStairs mStairs = doc.GetElement(selectedId.ElementAt(0)) as MultistoryStairs;
            if (null == mStairs)
            {
               message = "Please select a multistory stairs before running this command.";
               return Result.Failed;
            }

            View currentView = doc.ActiveView;
            if (null == currentView || currentView.ViewType != ViewType.Elevation || !currentView.CanBePrinted)
            {
               message = "The current view should be an elevation view to allow user to select levels.";
               return Result.Failed;
            }

            // allow the user to select the levels to remove stairs.
            LevelSelectionFilter selectionFilter = new LevelSelectionFilter(mStairs, OperationAction.Remove);
            IList<Reference> userSelectedRefs = uiDoc.Selection.PickObjects(Autodesk.Revit.UI.Selection.ObjectType.Element, selectionFilter);
            IEnumerable<ElementId> userSelectedIds = from refer in userSelectedRefs select refer.ElementId;

            // start the transaction and remove stairs from the multistory stairs.
            newTran = new Transaction(doc, "Remove Stairs from Multistory Stairs");
            newTran.Start();
            mStairs.RemoveStairsByLevelIds(new HashSet<ElementId>(userSelectedIds));
            newTran.Commit();

            return Autodesk.Revit.UI.Result.Succeeded;
         }
         catch (Exception e)
         {
            message = e.Message;
            if ((newTran != null) && newTran.HasStarted() && !newTran.HasEnded())
               newTran.RollBack();
            return Autodesk.Revit.UI.Result.Failed;
         }
      }
      #endregion IExternalCommand Members Implementation
   }
}

=== CODE_BLOCK_0109 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {

            // Get the application and document from external command data.
            Document activeDoc = commandData.Application.ActiveUIDocument.Document;

            NetworkDialog dlg = new NetworkDialog(activeDoc);
            dlg.ShowDialog();

            return Autodesk.Revit.UI.Result.Succeeded;
        }
        #endregion
    }
}

=== CODE_BLOCK_0111 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, 
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            try
            {
                CreationMgr mgr = new CreationMgr(commandData.Application.ActiveUIDocument);
                mgr.Execute();
            }
            catch(Exception e)
            {
                message += e.StackTrace;
                return Autodesk.Revit.UI.Result.Cancelled;
            }            

            return Autodesk.Revit.UI.Result.Succeeded;
        }

        #endregion
    }
}

=== CODE_BLOCK_0113 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
      ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         try
         {
            UIMacroManager uiMacroManager = UIMacroManager.GetMacroManager(commandData.Application);
            //Create new MacroModule, if exists old MacroModule with same name,return old.
            MacroModule module = GetModule(uiMacroManager, ModuleMaker.ProjectName);

            if (module == null)
            {
               ModuleSettings ms = new ModuleSettings(ModuleMaker.ProjectName, MacroLanguageType.CSharp);
               module = uiMacroManager.AddModule(ms, MacroEnvironment.UI, new ModuleMaker());
            }

            Macro macro = GetMacro(module, ModuleMaker.MacroName);
            if (macro != null)
            {
               macro.Execute();
            }
            else
            {
               TaskDialog.Show("Error", $"can't found Macro:{ModuleMaker.MacroName}");
               return Result.Failed;
            }

         }
         catch (Exception e)
         {
            message = e.Message;
            return Result.Failed;
         }
         return Result.Succeeded;
      }


      /// <summary>
      /// Get MacroModule from UIMacroManager.
      /// </summary>
      /// <param name="manager">UIMacroManager, manage all UI MacroModules.</param>
      /// <param name="moduleName">Used to identify the module.</param>
      private MacroModule GetModule(UIMacroManager uiMacroManager, string moduleName)
      {

         foreach (var module in uiMacroManager.MacroManager)
         {
            if (module == null || module.Name != moduleName)
               continue;
            return module;
         }
         return null;
      }

      /// <summary>
      /// Get Macro from MacroModule.
      /// </summary>
      /// <param name="module">MacroModule, manage all Macro in current Module.</param>
      /// <param name="macroName">Used to identify the Macro.</param>
      private Macro GetMacro(MacroModule module, string macroName)
      {
         if (module == null)
            return null;
         foreach (var macroMethod in module)
         {
            if (macroMethod != null && macroMethod.Name == macroName)
               return macroMethod;
         }
         return null;
      }
      #endregion IExternalCommand Members Implementation
   }
}

=== CODE_BLOCK_0115 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         try
         {
            Wall wall = null;
            Floor floor = null;

            ElementSet elems = new ElementSet();
            foreach (ElementId elementId in commandData.Application.ActiveUIDocument.Selection.GetElementIds())
            {
               elems.Insert(commandData.Application.ActiveUIDocument.Document.GetElement(elementId));
            }
            #region selection handle -- select one Slab (or Structure Wall)
            //if user had some wrong selection, give user an Error message
            string errorMessage =
                "Please select one Slab (or Structure Wall) to create PathReinforcement.";
            if (1 != elems.Size)
            {
               message = errorMessage;
               return Autodesk.Revit.UI.Result.Cancelled;
            }

            Autodesk.Revit.DB.Element selectElem = null;
            IEnumerator iter = elems.GetEnumerator();
            iter.Reset();
            if (iter.MoveNext())
            {
               selectElem = (Autodesk.Revit.DB.Element)iter.Current;
            }

            if (selectElem is Wall)
            {
               wall = selectElem as Wall;
            }
            else if (selectElem is Floor)
            {
               floor = selectElem as Floor;
            }
            else
            {
               message = errorMessage;
               return Autodesk.Revit.UI.Result.Cancelled;
            }
            #endregion
            try
            {
               if (null != wall)
               {
                  ProfileWall profileWall = new ProfileWall(wall, commandData);
                  NewPathReinforcementForm newPathReinforcementForm =
                      new NewPathReinforcementForm(profileWall);
                  newPathReinforcementForm.ShowDialog();
               }
               else if (null != floor)
               {
                  ProfileFloor profileFloor = new ProfileFloor(floor, commandData);
                  NewPathReinforcementForm newPathReinforcementForm =
                      new NewPathReinforcementForm(profileFloor);
                  newPathReinforcementForm.ShowDialog();
               }
            }
            catch (Exception ex)
            {
               message = ex.Message;
               return Autodesk.Revit.UI.Result.Cancelled;
            }

            return Autodesk.Revit.UI.Result.Succeeded;
         }
         catch (Exception e)
         {
            message = e.Message;
            return Autodesk.Revit.UI.Result.Failed;
         }
      }
      #endregion
   }
}

=== CODE_BLOCK_0117 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {

            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "External Tool");
            try
            {
                transaction.Start();
                RebarCreator creator = new RebarCreator(commandData);
                creator.Execute();
            }
            catch(Exception e)
            {
                message = e.Message.ToString();
                return Autodesk.Revit.UI.Result.Cancelled;
            }
            finally
            {
                transaction.Commit();
            }
            return Autodesk.Revit.UI.Result.Succeeded;
        } 
    }
}

=== CODE_BLOCK_0119 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
                                               ref string message,
                                               ElementSet elements)
        {
            try
            {
                m_activeView = commandData.Application.ActiveUIDocument.Document.ActiveView;

                //// Create a new instance of class DataManager
                RoofsManager.CS.RoofsManager roofsManager = new RoofsManager.CS.RoofsManager(commandData);
                LevelConverter.SetStandardValues(roofsManager.Levels);

                // Create a form to create and edit a roof.
                DialogResult result = System.Windows.Forms.DialogResult.None;
                while (result == DialogResult.None || result == DialogResult.Retry)
                {
                    if (result == DialogResult.Retry)
                    {
                        roofsManager.WindowSelect();
                    }
                    
                    using (RoofForms.CS.RoofForm mainForm = new RoofForms.CS.RoofForm(roofsManager))
                    {
                        result = mainForm.ShowDialog();
                    }
                }

                if (result == System.Windows.Forms.DialogResult.OK)
                {
                    return Autodesk.Revit.UI.Result.Succeeded;
                }
                else
                {
                    return Autodesk.Revit.UI.Result.Cancelled;
                }
            }
            catch (Exception ex)
            {
                // If there are something wrong, give error information and return failed
                message = ex.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
    }
}

=== CODE_BLOCK_0121 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, 
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "External Tool");
            try
            {
                transaction.Start();
                Application app = commandData.Application.Application;
                bool haveOpening = false;

                //search Opening in Revit
                List<OpeningInfo> openingInfos = new List<OpeningInfo>();
                FilteredElementIterator iter = (new FilteredElementCollector(commandData.Application.ActiveUIDocument.Document)).OfClass(typeof(Opening)).GetElementIterator();
                iter.Reset();
                while (iter.MoveNext())
                {
                    Object obj = iter.Current;
                    if (obj is Opening)
                    {
                        haveOpening = true;
                        Opening opening = obj as Opening;
                        OpeningInfo openingInfo = new OpeningInfo(opening, commandData.Application);
                        openingInfos.Add(openingInfo);
                    }
                }

                if (!haveOpening)
                {
                    message = "don't have opening in the project";
                    return Autodesk.Revit.UI.Result.Cancelled;
                }

                //show dialogue
                using (OpeningForm openingForm = new OpeningForm(openingInfos))
                {
                    openingForm.ShowDialog();
                }
            }
            catch (Exception e)
            {
                message = e.ToString();
                return Autodesk.Revit.UI.Result.Failed;
            }
            finally
            {
                transaction.Commit();
            }

            return Autodesk.Revit.UI.Result.Succeeded;
        }
        #endregion
    }
}

=== CODE_BLOCK_0123 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message,
            ElementSet elements)
        {
            // set out default result to failure.
            Autodesk.Revit.UI.Result retRes = Autodesk.Revit.UI.Result.Failed;

            Autodesk.Revit.UI.UIApplication app = commandData.Application;

            // get the elements selected
            // The current selection can be retrieved from the active 
            // document via the selection object
            ElementSet seletion = new ElementSet();
            foreach (ElementId elementId in app.ActiveUIDocument.Selection.GetElementIds())
            {
               seletion.Insert(app.ActiveUIDocument.Document.GetElement(elementId));
            }

            // we need to make sure that only one element is selected.
            if (seletion.Size == 1)
            {
                // we need to get the first and only element in the selection. Do this by getting 
                // an iterator. MoveNext and then get the current element.
                ElementSetIterator it = seletion.ForwardIterator();
                it.MoveNext();
                Element element = it.Current as Element;

                // Next we need to iterate through the parameters of the element,
                // as we iterating, we will store the strings that are to be displayed
                // for the parameters in a string list "parameterItems"
                List<string> parameterItems = new List<string>();
                ParameterSet parameters = element.Parameters;
                foreach (Parameter param in parameters)
                {
                    if (param == null) continue;

                    // We will make a string that has the following format,
                    // name type value
                    // create a StringBuilder object to store the string of one parameter
                    // using the character '\t' to delimit parameter name, type and value 
                    StringBuilder sb = new StringBuilder();

                    // the name of the parameter can be found from its definition.
                    sb.AppendFormat("{0}\t", param.Definition.Name);

                    // Revit parameters can be one of 5 different internal storage types:
                    // double, int, string, Autodesk.Revit.DB.ElementId and None. 
                    // if it is double then use AsDouble to get the double value
                    // then int AsInteger, string AsString, None AsStringValue.
                    // Switch based on the storage type
                    switch (param.StorageType)
                    {
                        case Autodesk.Revit.DB.StorageType.Double:
                            // append the type and value
                            sb.AppendFormat("double\t{0}", param.AsDouble());
                            break;
                        case Autodesk.Revit.DB.StorageType.ElementId:
                            // for element ids, we will try and retrieve the element from the 
                            // document if it can be found we will display its name.
                            sb.Append("Element\t");

                            // using ActiveDocument.GetElement(the element id) to 
                            // retrieve the element from the active document
                            Autodesk.Revit.DB.ElementId elemId = param.AsElementId();
                            Element elem = app.ActiveUIDocument.Document.GetElement(elemId);

                            // if there is an element then display its name, 
                            // otherwise display the fact that it is not set
                            sb.Append(elem != null ? elem.Name : "Not set");
                            break;
                        case Autodesk.Revit.DB.StorageType.Integer:
                            // append the type and value
                            sb.AppendFormat("int\t{0}", param.AsInteger());
                            break;
                        case Autodesk.Revit.DB.StorageType.String:
                            // append the type and value
                            sb.AppendFormat("string\t{0}", param.AsString());
                            break;
                        case Autodesk.Revit.DB.StorageType.None:
                            // append the type and value
                            sb.AppendFormat("none\t{0}", param.AsValueString());
                            break;
                        default:
                            break;
                    }

                    // add the completed line to the string list
                    parameterItems.Add(sb.ToString());
                }

                // Create our dialog, passing it the parameters array for display.
                PropertiesForm propertiesForm = new PropertiesForm(parameterItems.ToArray());
                propertiesForm.StartPosition = FormStartPosition.CenterParent;
                propertiesForm.ShowDialog();
                retRes = Autodesk.Revit.UI.Result.Succeeded;
            }
            else
            {
                message = "Please select only one element";
            }
            return retRes;
        }

        #endregion
    }
}

=== CODE_BLOCK_0125 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "External Tool");
            try
            {
                transaction.Start();
                ElementSet elems = new ElementSet();
                foreach (ElementId elementId in commandData.Application.ActiveUIDocument.Selection.GetElementIds())
                {
                   elems.Insert(commandData.Application.ActiveUIDocument.Document.GetElement(elementId));
                }
                #region selection error handle
                //if user have some wrong selection, give user an Error message
                if (1 != elems.Size)
                {
                    message = "please select one PathReinforcement.";
                    return Autodesk.Revit.UI.Result.Cancelled;
                }

                Autodesk.Revit.DB.Element selectElem = null;
                foreach (Autodesk.Revit.DB.Element e in elems)
                {
                    selectElem = e;
                }

                if (!(selectElem is Autodesk.Revit.DB.Structure.PathReinforcement))
                {
                    message = "please select one PathReinforcement.";
                    return Autodesk.Revit.UI.Result.Cancelled;
                }
                #endregion

                //clear all rebar bar type.
                if (s_rebarBarTypes.Count > 0)
                {
                    s_rebarBarTypes.Clear();
                }

                //get all bar type.
                FilteredElementCollector collector = new FilteredElementCollector(commandData.Application.ActiveUIDocument.Document);
                FilteredElementIterator itor = collector.OfClass(typeof(RebarBarType)).GetElementIterator();
                itor.Reset();
                while (itor.MoveNext())
                {
                    RebarBarType bartype = itor.Current as RebarBarType;
                    if (null != bartype)
                    {
                        Autodesk.Revit.DB.ElementId id = bartype.Id;
                        String name = bartype.Name;
                        s_rebarBarTypes.Add(name, id);
                    }
                }

                //Create a form to view the path reinforcement.
                Autodesk.Revit.DB.Structure.PathReinforcement pathRein = selectElem as
                                       Autodesk.Revit.DB.Structure.PathReinforcement;
                using (PathReinforcementForm form = new PathReinforcementForm(pathRein, commandData))
                {
                    form.ShowDialog();
                }
            }
            catch (Exception e)
            {
                transaction.RollBack();
                message = e.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
            finally
            {
                transaction.Commit();
            }
            return Autodesk.Revit.UI.Result.Succeeded;
        }

        #endregion
    }
}

=== CODE_BLOCK_0127 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
                                               ref string message,
                                               ElementSet elements)
        {
            // Quit if active document is null
            if (null == commandData.Application.ActiveUIDocument.Document)
            {
                message = "Active document is null.";
                return Autodesk.Revit.UI.Result.Failed;
            }

            try
            {
                FamilyInstanceCreator creator = new FamilyInstanceCreator(commandData.Application);

                // an option dialog for user choosing based type of creating
                BasedTypeForm baseTypeform = new BasedTypeForm();
                if (DialogResult.OK == baseTypeform.ShowDialog())
                {
                    PlaceFamilyInstanceForm placeForm = new PlaceFamilyInstanceForm(creator
                        , baseTypeform.BaseType);
                    placeForm.ShowDialog();
                }

                // if everything goes well, return succeeded.
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception ex)
            {
                // If any error, give error information and return failed
                message = ex.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
    }
}

=== CODE_BLOCK_0129 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
        ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            try
            {
                // Quit if active document is null
                if (null == commandData.Application.ActiveUIDocument.Document)
                {
                    message = Properties.Resources.ResourceManager.GetString("NullActiveDocument");
                    return Autodesk.Revit.UI.Result.Failed;
                }

                // Quit if no elements selected
                if (commandData.Application.ActiveUIDocument.Selection.GetElementIds().Count == 0)
                {
                    message = Properties.Resources.ResourceManager.GetString("SelectPowerElements");
                    return Autodesk.Revit.UI.Result.Failed;
                }

                // Collect information from selected elements and show operation dialog
                CircuitOperationData optionData = new CircuitOperationData(commandData);
                using (CircuitOperationForm mainForm = new CircuitOperationForm(optionData))
                {
                    if (mainForm.ShowDialog() == DialogResult.Cancel)
                    {
                        return Autodesk.Revit.UI.Result.Cancelled;
                    }
                }

                // Show the dialog for user to select a circuit if more than one circuit available
                if (optionData.Operation != Operation.CreateCircuit && 
                    optionData.ElectricalSystemCount > 1)
                {
                    using (SelectCircuitForm selectForm = new SelectCircuitForm(optionData))
                    {
                        if (selectForm.ShowDialog() == DialogResult.Cancel)
                        {
                            return Autodesk.Revit.UI.Result.Cancelled;
                        }
                    }
                }

                // If user choose to edit circuit, display the circuit editing dialog
                if (optionData.Operation == Operation.EditCircuit)
                {
                    using (EditCircuitForm editForm = new EditCircuitForm(optionData))
                    {
                        if (editForm.ShowDialog() == DialogResult.Cancel)
                        {
                            return Autodesk.Revit.UI.Result.Cancelled;
                        }
                    }
                }

                // Perform the operation
                optionData.Operate();
            }
            catch (Exception ex)
            {
                message = ex.ToString();
                return Autodesk.Revit.UI.Result.Failed;
            }

            return Autodesk.Revit.UI.Result.Succeeded;
        }
    }
}

=== CODE_BLOCK_0131 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "External Tool");
            try
            {
                transaction.Start();
                // create a factory to create the corresponding FrameReinMaker
                FrameReinMakerFactory factory = new FrameReinMakerFactory(commandData);

                // Do some data checks, such whether the user select concrete beam or column
                if (!factory.AssertData())
                {
                    message = "Please select a concrete beam or column without reinforcement.";
                    return Autodesk.Revit.UI.Result.Failed;
                }

                // Invoke work() method to create corresponding FrameReinMaker,
                // and create the reinforcement rebars
                factory.work();

                // if everything goes well, return succeeded.
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception ex)
            {
                message = ex.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
            finally
            {
                transaction.Commit();
            }
        }
    }
}

=== CODE_BLOCK_0133 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message,
            ElementSet elements)
        {
            Transaction trans = new Transaction(commandData.Application.ActiveUIDocument.Document, "Revit.SDK.Samples.ReferencePlane");
            trans.Start();
            try
            {
                // Generate an object of Revit reference plane management.
                ReferencePlaneMgr refPlaneMgr = new ReferencePlaneMgr(commandData);

                using (ReferencePlaneForm dlg = new ReferencePlaneForm(refPlaneMgr))
                {
                    if (dlg.ShowDialog() == System.Windows.Forms.DialogResult.OK)
                    {
                        // Done some actions, ask revit to execute it.
                        trans.Commit();
                        return Autodesk.Revit.UI.Result.Succeeded;
                    }
                    else
                    {
                        // Revit need to do nothing.
                        trans.RollBack();
                        return Autodesk.Revit.UI.Result.Cancelled;
                    }
                }
            }
            catch (Exception e)
            {
                // Exception raised, report it by revit error reporting mechanism. 
                message = e.ToString();
                trans.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }
            
        }
    }
}

=== CODE_BLOCK_0135 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                                ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "External Tool");
            try
            {
                transaction.Start();
                // create a factory to create the corresponding FrameReinMaker
                FrameReinMakerFactory factory = new FrameReinMakerFactory(commandData);

                // Do some data checks, such whether the user select concrete beam or column
                if (!factory.AssertData())
                {
                    message = "Please select a concrete beam or column without reinforcement.";
                    return Autodesk.Revit.UI.Result.Failed;
                }

                // Invoke work() method to create corresponding FrameReinMaker,
                // and create the reinforcement rebars
                factory.work();

                // if everything goes well, return succeeded.
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception ex)
            {
                message = ex.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
            finally
            {
                transaction.Commit();
            }
        }
    }
}

=== CODE_BLOCK_0137 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,
                                             ref string message,
                                             ElementSet elements)
      {
         Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, "CreateWall");
         trans.Start();
         Autodesk.Revit.UI.UIApplication app = revit.Application;

         WallType newWallType = GetNewWallType(app); //get WallType from RadioButtonGroup - WallTypeSelector
         Level newWallLevel = GetNewWallLevel(app); //get Level from Combobox - LevelsSelector
         List<Curve> newWallShape = GetNewWallShape(app); //get wall Curve from Combobox - WallShapeComboBox
         String newWallMark = GetNewWallMark(app); //get mark of new wall from Text box - WallMark

         Wall newWall = null;
         if ("CreateStructureWall" == this.GetType().Name) //decided by SplitButton
         { newWall = Wall.Create(app.ActiveUIDocument.Document, newWallShape, newWallType.Id, newWallLevel.Id, true); }
         else { newWall = Wall.Create(app.ActiveUIDocument.Document, newWallShape, newWallType.Id, newWallLevel.Id, false); }
         if (null != newWall)
         {
            newWall.get_Parameter(BuiltInParameter.ALL_MODEL_MARK).Set(newWallMark); //set new wall's mark
            CreatedWalls.Insert(newWall);
         }
         trans.Commit();
         return Autodesk.Revit.UI.Result.Succeeded;
      }

      #endregion IExternalCommand Members Implementation

      #region protected methods
      protected WallType GetNewWallType(Autodesk.Revit.UI.UIApplication app)
      {
         RibbonPanel myPanel = app.GetRibbonPanels()[0];
         RadioButtonGroup radioGroupTypeSelector =
             GetRibbonItemByName(myPanel, "WallTypeSelector") as RadioButtonGroup;
         if (null == radioGroupTypeSelector) { throw new InvalidCastException("Cannot get Wall Type selector!"); }
         String wallTypeName = radioGroupTypeSelector.Current.ItemText;
         WallType newWallType = null;
         FilteredElementCollector collector = new FilteredElementCollector(app.ActiveUIDocument.Document);
         ICollection<Element> founds = collector.OfClass(typeof(WallType)).ToElements();
         foreach (Element elem in founds)
         {
            WallType wallType = elem as WallType;
            if (wallType.Name.StartsWith(wallTypeName))
            {
               newWallType = wallType; break;
            }
         }

         return newWallType;
      }

      protected Level GetNewWallLevel(Autodesk.Revit.UI.UIApplication app)
      {
         RibbonPanel myPanel = app.GetRibbonPanels()[0];
         Autodesk.Revit.UI.ComboBox comboboxLevel =
             GetRibbonItemByName(myPanel, "LevelsSelector") as Autodesk.Revit.UI.ComboBox;
         if (null == comboboxLevel) { throw new InvalidCastException("Cannot get Level selector!"); }
         String wallLevel = comboboxLevel.Current.ItemText;
         //find wall type in document
         Level newWallLevel = null;
         FilteredElementCollector collector = new FilteredElementCollector(app.ActiveUIDocument.Document);
         ICollection<Element> founds = collector.OfClass(typeof(Level)).ToElements();
         foreach (Element elem in founds)
         {
            Level level = elem as Level;
            if (level.Name.StartsWith(wallLevel))
            {
               newWallLevel = level; break;
            }
         }

         return newWallLevel;
      }

      protected List<Curve> GetNewWallShape(Autodesk.Revit.UI.UIApplication app)
      {
         RibbonPanel myPanel = app.GetRibbonPanels()[0];
         Autodesk.Revit.UI.ComboBox comboboxWallShape =
             GetRibbonItemByName(myPanel, "WallShapeComboBox") as Autodesk.Revit.UI.ComboBox;
         if (null == comboboxWallShape) { throw new InvalidCastException("Cannot get Wall Shape Gallery!"); }
         String wallShape = comboboxWallShape.Current.ItemText;
         if ("SquareWall" == wallShape) { return GetSquareWallShape(app.Application.Create); }
         else if ("CircleWall" == wallShape) { return GetCircleWallShape(app.Application.Create); }
         else if ("TriangleWall" == wallShape) { return GetTriangleWallShape(app.Application.Create); }
         else { return GetRectangleWallShape(app.Application.Create); }
      }

      protected String GetNewWallMark(Autodesk.Revit.UI.UIApplication app)
      {
         RibbonPanel myPanel = app.GetRibbonPanels()[0];
         Autodesk.Revit.UI.TextBox textBox =
             GetRibbonItemByName(myPanel, "WallMark") as Autodesk.Revit.UI.TextBox;
         if (null == textBox) { throw new InvalidCastException("Cannot get Wall Mark TextBox!"); }
         String newWallMark;
         int newWallIndex = 0;
         FilteredElementCollector collector = new FilteredElementCollector(app.ActiveUIDocument.Document);
         ICollection<Element> founds = collector.OfClass(typeof(Wall)).ToElements();
         foreach (Element elem in founds)
         {
            Wall wall = elem as Wall;
            string wallMark = wall.get_Parameter(BuiltInParameter.ALL_MODEL_MARK).AsString();
            if (wallMark.StartsWith(textBox.Value.ToString()) && wallMark.Contains('_'))
            {
               //get the index for new wall (wall_1, wall_2...)
               char[] chars = { '_' };
               string[] strings = wallMark.Split(chars);
               if (strings.Length >= 2)
               {
                  try
                  {
                     int index = Convert.ToInt32(strings[strings.Length - 1]);
                     if (index > newWallIndex) { newWallIndex = index; }
                  }
                  catch (System.Exception)
                  {
                     continue;
                  }
               }
            }
         }
         newWallMark = textBox.Value.ToString() + '_' + (newWallIndex + 1);
         return newWallMark;
      }

      protected List<Curve> GetRectangleWallShape(Autodesk.Revit.Creation.Application creApp)
      {
         //calculate size of Structural and NonStructural walls
         int WallsSize = CreateStructureWall.CreatedWalls.Size + CreatedWalls.Size;
         List<Curve> curves = new List<Curve>();
         //15: distance from each wall, 60: wall length , 60: wall width 
         Line line1 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 60, 0));
         Line line2 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 60, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 60, 40));
         Line line3 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 60, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 40));
         Line line4 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 0));
         curves.Add(line1);
         curves.Add(line2);
         curves.Add(line3);
         curves.Add(line4);
         return curves;
      }

      protected List<Curve> GetSquareWallShape(Autodesk.Revit.Creation.Application creApp)
      {
         //calculate size of Structural and NonStructural walls
         int WallsSize = CreateStructureWall.CreatedWalls.Size + CreatedWalls.Size;
         List<Curve> curves = new List<Curve>();
         //15: distance from each wall, 40: wall length  
         Line line1 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 0));
         Line line2 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 40));
         Line line3 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 40));
         Line line4 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 0));
         curves.Add(line1);
         curves.Add(line2);
         curves.Add(line3);
         curves.Add(line4);
         return curves;
      }

      protected List<Curve> GetCircleWallShape(Autodesk.Revit.Creation.Application creApp)
      {
         //calculate size of Structural and NonStructural walls
         int WallsSize = CreateStructureWall.CreatedWalls.Size + CreatedWalls.Size;
         List<Curve> curves = new List<Curve>();
         //15: distance from each wall, 40: diameter of circle  
         Arc arc = Arc.Create(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 20, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 20, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 20));
         Arc arc2 = Arc.Create(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 20, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 20, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 20));
         curves.Add(arc);
         curves.Add(arc2);
         return curves;
      }

      protected List<Curve> GetTriangleWallShape(Autodesk.Revit.Creation.Application creApp)
      {
         //calculate size of Structural and NonStructural walls
         int WallsSize = CreateStructureWall.CreatedWalls.Size + CreatedWalls.Size;
         List<Curve> curves = new List<Curve>();
         //15: distance from each wall, 40: height of triangle  
         Line line1 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 0));
         Line line2 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 20, 40));
         Line line3 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 20, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 0));
         curves.Add(line1);
         curves.Add(line2);
         curves.Add(line3);
         return curves;
      }
      #endregion

      /// <summary>
      /// return the RibbonItem by the input name in a specific panel
      /// </summary>
      /// <param name="panelRibbon">RibbonPanel which contains the RibbonItem </param>
      /// <param name="itemName">name of RibbonItem</param>
      /// <return>RibbonItem whose name is same with input string</param>
      public RibbonItem GetRibbonItemByName(RibbonPanel panelRibbon, String itemName)
      {
         foreach (RibbonItem item in panelRibbon.GetItems())
         {
            if (itemName == item.Name)
            {
               return item;
            }
         }

         return null;
      }
   }

   /// <summary>
   /// Implements the Revit add-in interface IExternalCommand,create a structural wall
   /// all the properties for new wall comes from user selection in Ribbon
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class CreateStructureWall : CreateWall
   {
   }

   /// <summary>
   /// Implements the Revit add-in interface IExternalCommand, 
   /// delete all the walls which create by Ribbon sample
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class DeleteWalls : IExternalCommand
   {
      #region IExternalCommand Members Implementation
      public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,
                                             ref string message,
                                             ElementSet elements)
      {
         // delete all the walls which create by RibbonSample
         ElementSet wallSet = CreateWall.CreatedWalls;
         Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, "DeleteWalls");
         trans.Start();
         foreach (Element e in wallSet)
         {
             revit.Application.ActiveUIDocument.Document.Delete(e.Id);
         }
         CreateWall.CreatedWalls.Clear();
         trans.Commit();
         return Autodesk.Revit.UI.Result.Succeeded;
      }
      #endregion IExternalCommand Members Implementation
   }

   /// <summary>
   /// Implements the Revit add-in interface IExternalCommand,Move walls, X direction
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class XMoveWalls : IExternalCommand
   {
      #region IExternalCommand Members Implementation

      public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,
                                             ref string message,
                                             ElementSet elements)
      {
         Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, "XMoveWalls");
         trans.Start();
         IEnumerator iter = CreateWall.CreatedWalls.GetEnumerator();
         iter.Reset();
         while (iter.MoveNext())
         {
            Wall wall = iter.Current as Wall;
            if (null != wall)
            {
               wall.Location.Move(new Autodesk.Revit.DB.XYZ(12, 0, 0));
            }
         }
         trans.Commit();
         return Autodesk.Revit.UI.Result.Succeeded;
      }
      #endregion IExternalCommand Members Implementation
   }

   /// <summary>
   /// Implements the Revit add-in interface IExternalCommand,Move walls, Y direction
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class YMoveWalls : IExternalCommand
   {
      #region IExternalCommand Members Implementation

      public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,
                                             ref string message,
                                             ElementSet elements)
      {
         Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, "YMoveWalls");
         trans.Start();
         IEnumerator iter = CreateWall.CreatedWalls.GetEnumerator();
         iter.Reset();
         while (iter.MoveNext())
         {
            Wall wall = iter.Current as Wall;
            if (null != wall)
            {
               wall.Location.Move(new Autodesk.Revit.DB.XYZ(0, 12, 0));
            }
         }
        trans.Commit();
         return Autodesk.Revit.UI.Result.Succeeded;
      }
      #endregion IExternalCommand Members Implementation
   }

   /// <summary>
   /// Implements the Revit add-in interface IExternalCommand,
   /// Reset all the Ribbon options to default, such as level, wall type...
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class ResetSetting : IExternalCommand
   {
      #region IExternalCommand Members Implementation

      public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,
                                             ref string message,
                                             ElementSet elements)
      {
         RibbonPanel myPanel = revit.Application.GetRibbonPanels()[0];
         //reset wall type
         RadioButtonGroup radioGroupTypeSelector =
             GetRibbonItemByName(myPanel, "WallTypeSelector") as RadioButtonGroup;
         if (null == radioGroupTypeSelector) { throw new InvalidCastException("Cannot get Wall Type selector!"); }
         radioGroupTypeSelector.Current = radioGroupTypeSelector.GetItems()[0];

         //reset level
         Autodesk.Revit.UI.ComboBox comboboxLevel =
             GetRibbonItemByName(myPanel, "LevelsSelector") as Autodesk.Revit.UI.ComboBox;
         if (null == comboboxLevel) { throw new InvalidCastException("Cannot get Level selector!"); }
         comboboxLevel.Current = comboboxLevel.GetItems()[0];

         //reset wall shape
         Autodesk.Revit.UI.ComboBox comboboxWallShape =
             GetRibbonItemByName(myPanel, "WallShapeComboBox") as Autodesk.Revit.UI.ComboBox;
         if (null == comboboxLevel) { throw new InvalidCastException("Cannot get wall shape combo box!"); }
         comboboxWallShape.Current = comboboxWallShape.GetItems()[0];

         //get wall mark
         Autodesk.Revit.UI.TextBox textBox =
             GetRibbonItemByName(myPanel, "WallMark") as Autodesk.Revit.UI.TextBox;
         if (null == textBox) { throw new InvalidCastException("Cannot get Wall Mark TextBox!"); }
         textBox.Value = "new wall";

         return Autodesk.Revit.UI.Result.Succeeded;
      }

      /// <summary>
      /// return the RibbonItem by the input name in a specific panel
      /// </summary>
      /// <param name="panelRibbon">RibbonPanel which contains the RibbonItem </param>
      /// <param name="itemName">name of RibbonItem</param>
      /// <return>RibbonItem whose name is same with input string</param>
      public RibbonItem GetRibbonItemByName(RibbonPanel panelRibbon, String itemName)
      {
         foreach (RibbonItem item in panelRibbon.GetItems())
         {
            if (itemName == item.Name)
            {
               return item;
            }
         }

         return null;
      }

      #endregion IExternalCommand Members Implementation
   }

   /// <summary>
   /// Do Nothing, 
   /// Create this just because ToggleButton have to bind to a ExternalCommand
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class Dummy : IExternalCommand
   {
      #region IExternalCommand Members Implementation

      public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,
                                             ref string message,
                                             ElementSet elements)
      {
         return Autodesk.Revit.UI.Result.Succeeded;
      }

      #endregion IExternalCommand Members Implementation
   }
}

=== CODE_BLOCK_0139 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            string assemblyLocation = Assembly.GetExecutingAssembly().Location;
            string log = assemblyLocation + "." + DateTime.Now.ToString("yyyyMMdd") + ".log";
            if (File.Exists(log)) File.Delete(log);
            TraceListener txtListener = new TextWriterTraceListener(log);
            Trace.Listeners.Add(txtListener);
            try
            {
                // variable initialization
                m_application = commandData.Application.Application;
                m_document = commandData.Application.ActiveUIDocument.Document;
                Environment.CurrentDirectory = Path.GetDirectoryName(assemblyLocation);

                FindRoomBoundingRoofs(ref message, elements);

                // Not show TaskDialog in regression mode
                if (0 == commandData.JournalData.Count)
                {
                    TaskDialog.Show("Roofs Rooms", message);
                }

                // Insert result to journal data for regression purpose.
                const string DataKey = "Results";
                if (!commandData.JournalData.ContainsKey(DataKey))
                {
                    // In normal/recording mode 
                    commandData.JournalData.Add(DataKey, message);
                }
                else
                {
                    // In regression/replaying mode
                    commandData.JournalData[DataKey] = message;
                }

                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception ex)
            {
                Trace.WriteLine(ex.ToString());
                message = ex.ToString();
                return Autodesk.Revit.UI.Result.Failed;
            }
            finally
            {
                Trace.Flush();
                txtListener.Close();
                Trace.Close();
                Trace.Listeners.Remove(txtListener);
            }
        }

        /// <summary>
        /// Test whether each room has a roof to bound it.
        /// </summary>
        /// <param name="message">Error message to be dumped.</param>
        /// <param name="elements">Some elements to return.</param>
        /// <returns></returns>
        private bool FindRoomBoundingRoofs(ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            // Get all rooms
            List<Element> rooms = GetRoomsElements();
            if (rooms.Count == 0)
            {
                message = "Unable to identify any rooms, please create room first!";
                return false;
            }

            // Represents the criteria for boundary elements to be considered bounding roofs
            LogicalOrFilter categoryFilter = new LogicalOrFilter(new ElementCategoryFilter(BuiltInCategory.OST_Roofs),
                                                                    new ElementCategoryFilter(BuiltInCategory.OST_RoofSoffit));

            // Calculator for room/space geometry.
            SpatialElementGeometryCalculator calculator = new SpatialElementGeometryCalculator(m_document);

            // Stores the resulting room->roof relationships
            Dictionary<Element, List<ElementId>> roomsAndRoofs = new Dictionary<Element, List<ElementId>>();

            foreach (Element room in rooms)
            {
                // Get room geometry & boundaries          
                SpatialElementGeometryResults results = calculator.CalculateSpatialElementGeometry((SpatialElement)room);

                // Get solid geometry so we can examine each face
                Solid geometry = results.GetGeometry();

                foreach (Face face in geometry.Faces)
                {
                    // Get list of roof boundary subfaces for a given face
                    IList<SpatialElementBoundarySubface> boundaryFaces = results.GetBoundaryFaceInfo(face);
                    foreach (SpatialElementBoundarySubface boundaryFace in boundaryFaces)
                    {
                        // Get boundary element
                        LinkElementId boundaryElementId = boundaryFace.SpatialBoundaryElement;

                        // Only considering local file room bounding elements
                        ElementId localElementId = boundaryElementId.HostElementId;

                        // Evaluate if element meets criteria using PassesFilter()
                        if (localElementId != ElementId.InvalidElementId && categoryFilter.PassesFilter(m_document, localElementId))
                        {
                            // Room already has roofs, add more
                            if (roomsAndRoofs.ContainsKey(room))
                            {
                                List<ElementId> roofs = roomsAndRoofs[room];
                                if (!roofs.Contains(localElementId))
                                    roofs.Add(localElementId);
                            }
                            // Room found first roof
                            else
                            {
                                List<ElementId> roofs = new List<ElementId>();
                                roofs.Add(localElementId);
                                roomsAndRoofs.Add(room, roofs);
                            }
                            break;
                        }
                    }
                }
            }

            // Format results
            if (roomsAndRoofs.Count > 0)
            {
                String logs = String.Format("Rooms that have a bounding roof:");
                message += logs + "\t\r\n";
                Trace.WriteLine(logs);
                foreach (KeyValuePair<Element, List<ElementId>> kvp in roomsAndRoofs)
                {
                    // remove this room from all rooms list
                    rooms.Remove(kvp.Key);

                    List<ElementId> roofs = kvp.Value;
                    String roofsString;

                    // Single roof boundary
                    if (roofs.Count == 1)
                    {
                        Element roof = m_document.GetElement(roofs[0]);
                        roofsString = String.Format("Roof: Id = {0}, Name = {1}", roof.Id.ToString(), roof.Name);
                    }
                    // Multiple roofs
                    else
                    {
                        roofsString = "Roofs ids = " + string.Join(", ", Array.ConvertAll<ElementId, string>(roofs.ToArray(), i => i.ToString()));
                    }

                    // Save results
                    logs = String.Format(
                        "  Room: Id = {0}, Name = {1} --> {2}",
                        kvp.Key.Id.ToString(), kvp.Key.Name, roofsString);
                    message += logs + "\t\r\n";
                    Trace.WriteLine(logs);
                }
            }

            // Format the rooms that have no bounding roof
            Trace.WriteLine("Geometry relationship checking finished...");
            if (rooms.Count != 0)
            {
                String logs = String.Format("Below rooms don't have bounding roofs:");
                message += logs + "\t\r\n";
                Trace.WriteLine(logs);
                foreach (Element room in rooms)
                {
                    elements.Insert(room);
                    logs = String.Format("  Room Id: {0}, Room Name: {1}",
                        room.Id.ToString(), room.Name);
                    message += logs + "\t\r\n";
                    Trace.WriteLine(logs);
                }
            }

            return true;
        }

        /// <summary>
        /// Retrieve all Rooms and Spaces elements from active document.
        /// </summary>
        /// <returns>Element list retrieved from current document.</returns>
        private List<Element> GetRoomsElements()
        {
            List<Element> array = new List<Element>();
            ElementFilter roomSpaceFilter = new LogicalOrFilter(new RoomFilter(), new SpaceFilter());
            FilteredElementCollector collector = new FilteredElementCollector(m_document);
            array.AddRange(collector.WherePasses(roomSpaceFilter).ToElements());
            return array;
        }

        #endregion
    }
}

=== CODE_BLOCK_0141 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
                                               ref string message,
                                               ElementSet elements)
        {
            try
            {
                Transaction tran = new Transaction(commandData.Application.ActiveUIDocument.Document, "Rooms");
                tran.Start();
                // create a new instance of class data
                RoomsData data = new RoomsData(commandData);

                // create a form to display the information of rooms
                using (roomsInformationForm infoForm = new roomsInformationForm(data))
                {
                    infoForm.ShowDialog();
                }
                tran.Commit();
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception ex)
            {
                // If there are something wrong, give error information and return failed
                message = ex.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
    }
}

=== CODE_BLOCK_0143 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
                                               ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Transaction tranSample = null;
            try
            {
                tranSample = new Transaction(commandData.Application.ActiveUIDocument.Document, "Sample Start");
                tranSample.Start();
                // create a form to display the information of Revit rooms and xls based rooms
                using (RoomScheduleForm infoForm = new RoomScheduleForm(commandData))
                {
                    infoForm.ShowDialog();
                }
                tranSample.Commit();
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception ex)
            {
                if (null != tranSample) tranSample.RollBack();
                // if there are something wrong, give error information and return failed
                message = ex.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
    }
    #endregion
}

=== CODE_BLOCK_0145 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Transaction trans = new Transaction(commandData.Application.ActiveUIDocument.Document, "Revit.SDK.Samples.ShaftHolePuncher");
            trans.Start();
            try
            {
                Wall wall = null;
                Floor floor = null;
                FamilyInstance familyInstance = null;
                ElementSet elems = new ElementSet();
                foreach (ElementId elementId in commandData.Application.ActiveUIDocument.Selection.GetElementIds())
                {
                   elems.Insert(commandData.Application.ActiveUIDocument.Document.GetElement(elementId));
                }

                #region selection handle -- select one floor, wall, beam or nothing
                //if user had some wrong selection, give user an Error message
                string errorMessage =
                    "Please select one Floor (Beam or Wall) to create opening or select nothing to create Shaft Opening";
                if (elems.Size > 1)
                {
                    message = errorMessage;
                    trans.RollBack();
                    return Autodesk.Revit.UI.Result.Cancelled;
                }

                Autodesk.Revit.DB.Element selectElem = null;
                if (1 == elems.Size)
                {
                    IEnumerator iter = elems.GetEnumerator();
                    iter.Reset();
                    if (iter.MoveNext())
                    {
                        selectElem = (Autodesk.Revit.DB.Element)iter.Current;
                    }

                    if (selectElem is Wall)
                    {
                        wall = selectElem as Wall;
                    }
                    else if (selectElem is Floor)
                    {
                        floor = selectElem as Floor;
                    }
                    else if (selectElem is FamilyInstance)
                    {
                        familyInstance = selectElem as FamilyInstance;
                        if (familyInstance.StructuralType !=
                            Autodesk.Revit.DB.Structure.StructuralType.Beam)
                        {
                            message = errorMessage;
                            trans.RollBack();
                            return Autodesk.Revit.UI.Result.Cancelled;
                        }
                    }
                    else
                    {
                        message = errorMessage;
                        trans.RollBack();
                        return Autodesk.Revit.UI.Result.Cancelled;
                    }
                }
                #endregion

                try
                {
                    if (null != wall)
                    {
                        ProfileWall profileWall = new ProfileWall(wall, commandData);
                        ShaftHolePuncherForm shaftHolePuncherForm = 
                            new ShaftHolePuncherForm(profileWall);
                        shaftHolePuncherForm.ShowDialog();
                    }
                    else if (null != floor)
                    {
                        ProfileFloor profileFloor = new ProfileFloor(floor, commandData);
                        ShaftHolePuncherForm shaftHolePuncherForm =
                            new ShaftHolePuncherForm(profileFloor);
                        shaftHolePuncherForm.ShowDialog();
                    }
                    else if (null != familyInstance)
                    {
                        ProfileBeam profileBeam = new ProfileBeam(familyInstance, commandData);
                        ShaftHolePuncherForm shaftHolePuncherForm =
                            new ShaftHolePuncherForm(profileBeam);
                        shaftHolePuncherForm.ShowDialog();
                    }
                    else
                    {
                        ProfileNull profileNull = new ProfileNull(commandData);
                        ShaftHolePuncherForm shaftHolePuncherForm =
                            new ShaftHolePuncherForm(profileNull);
                        shaftHolePuncherForm.ShowDialog();
                    }
                }
                catch (Exception ex)
                {
                    message = ex.Message;
                    trans.RollBack();
                    return Autodesk.Revit.UI.Result.Cancelled;
                }
                trans.Commit();
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception e)
            {
                message = e.Message;
                trans.RollBack();
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
        #endregion
    }
}

=== CODE_BLOCK_0147 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
                                             ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
           
         try
         {
            Transaction trans = new Transaction(commandData.Application.ActiveUIDocument.Document, "Revit.SDK.Samples.SharedCoordinateSystem");
            trans.Start();
            CoordinateSystemData Data = new CoordinateSystemData(commandData);
            Data.GatData();

            using (CoordinateSystemDataForm displayForm =
                                    new CoordinateSystemDataForm(Data, commandData.Application.Application.Cities,
                                                commandData.Application.ActiveUIDocument.Document.SiteLocation))
            {
               if (DialogResult.OK != displayForm.ShowDialog())
               {
                  trans.RollBack();
                  return Autodesk.Revit.UI.Result.Cancelled;
               }
            }
            trans.Commit();
            return Autodesk.Revit.UI.Result.Succeeded;
         }
         catch (Exception ex)
         {
            message = ex.Message;            
            return Autodesk.Revit.UI.Result.Failed;
         }

     }
     #endregion IExternalCommand Members Implementation
 }
}

=== CODE_BLOCK_0149 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
        ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         if (null == commandData)
         {
            throw new ArgumentNullException("commandData");
         }

         Result result = Result.Succeeded;
         try
         {
            result = MakeView3D.MakeFromViewportClick(commandData.Application.ActiveUIDocument);
         }
         catch (Exception e)
         {
            message = e.Message;
            return Autodesk.Revit.UI.Result.Failed;
         }

         return result;
      }

      #endregion IExternalCommand Members Implementation
   }

   /// <summary>
   /// Generates a View3D from a click on a viewport on a sheet.
   /// </summary>
   public class MakeView3D
   {
      private static double CLICK_TOLERANCE = 0.0001;

      /// <summary>
      /// Makes a View3D from a click on a viewport on a sheet.
      /// </summary>
      /// <param name="uidoc">the currently active uidocument</param>
      /// <param name="doc">the currently active document</param>
      public static Autodesk.Revit.UI.Result MakeFromViewportClick(UIDocument uidoc)
      {
         if (null == uidoc)
         {
            throw new ArgumentNullException("uidoc");
         }

         Document doc = uidoc.Document;
         if (null == doc)
         {
            throw new InvalidOperationException("The document can't be found.");
         }

         Result result = Result.Succeeded;

         // Have the user click on a plan view viewport on a sheet.
         XYZ click = uidoc.Selection.PickPoint("Click on a plan view viewport on a sheet to create a perspective View3D with its camera at that point.");
         if (null == click)
         {
            throw new InvalidOperationException("Please click on a plan view viewport on a sheet.");
         }

         // Make sure the active view was a sheet view.
         ViewSheet viewSheet = uidoc.ActiveGraphicalView as ViewSheet;
         if (null == viewSheet)
         {
            throw new InvalidOperationException("The click was not on a sheet.");
         }

         // Find which viewport was clicked.
         Viewport clickedViewport = GetViewportAtClick(viewSheet, click);
         if (null == clickedViewport)
         {
            throw new InvalidOperationException("The click was not on a viewport.");
         }

         // Verify that the transforms are reported by the viewport and its view.
         View clickedView = doc.GetElement(clickedViewport.ViewId) as View;
         if (null == clickedView || !clickedView.HasViewTransforms() || !clickedViewport.HasViewportTransforms())
         {
            throw new InvalidOperationException("The clicked viewport doesn't report 3D model space to sheet space transforms.");
         }

         // Restrict application to plan view types.  
         // Note: Sections and Elevations report transforms but are not covered in this demo.
         if (ViewType.AreaPlan != clickedView.ViewType &&
             ViewType.CeilingPlan != clickedView.ViewType &&
             ViewType.EngineeringPlan != clickedView.ViewType &&
             ViewType.FloorPlan != clickedView.ViewType)
         {
            throw new InvalidOperationException("Only plan views are supported by this demo application.");
         }

         ViewPlan plan = clickedView as ViewPlan;
         if (null == plan)
         {
            throw new InvalidOperationException("Only plan views are supported by this demo application.");
         }

         // Convert the viewport click into a ray through 3d model space.
         // Note: The output XYZ needs to be projected onto the view's cut plane before use.
         XYZ clickAsModelRay = CalculateClickAsModelRay(clickedViewport, click);
         if (null == clickAsModelRay)
         {
            throw new InvalidOperationException("The click was outside the view crop regions.");
         }

         // Project the ray onto the view's cut plane.  
         // This picks a reasonable height in the model for the View3D camera.
         Plane cutPlane = GetViewPlanCutPlane(plan);
         if (null == cutPlane)
         {
            throw new InvalidOperationException("An error occured when getting the view's cut plane.");
         }
         XYZ view3dCameraLocation = ProjectPointOnPlane(cutPlane, clickAsModelRay);
         if (null == view3dCameraLocation)
         {
            throw new InvalidOperationException("An error occured when calculating the View3D camera position.");
         }

         using (Transaction tran = new Transaction(doc, "New 3D View"))
         {
            tran.Start();

            // Create a new perspective 3D View with its camera at the point.
            View3D view3d = Create3DView(doc, view3dCameraLocation, XYZ.BasisZ, XYZ.BasisY);
            if (null != view3d)
            {
               tran.Commit();

               // Activate the new 3D view.
               uidoc.ActiveView = view3d;
            }
            else
            {
               tran.RollBack();
               throw new InvalidOperationException("Failed to generate the 3D view.");
            }
         }

         return result;
      }

      /// <summary>
      /// Find the viewport at a point on a sheet.
      /// </summary>
      /// <param name="viewSheet">The ViewSheet that was clicked</param>
      /// <param name="click">The click point</param>
      /// <returns>The viewport which was clicked, or null if no viewport was clicked.</returns>
      private static Viewport GetViewportAtClick(ViewSheet viewSheet, XYZ click)
      {
         if (null == viewSheet || null == click)
            return null;

         Document doc = viewSheet.Document;
         if (null == doc)
            return null;

         foreach (var vpId in viewSheet.GetAllViewports())
         {
            Viewport viewport = doc.GetElement(vpId) as Viewport;

            if (null != viewport && viewport.GetBoxOutline().Contains(click, CLICK_TOLERANCE))
            {
               // Click is within the viewport
               return viewport;
            }
         }

         // Click was not contained by any viewport
         return null;
      }

      /// <summary>
      /// Makes the sheet space --> 3D model space transform.
      /// </summary>
      /// <param name="trfModelToProjection">The 3D model space --> view projection space transform.</param>
      /// <param name="trfProjectionToSheet">The view projection space --> sheet space transform.</param>
      /// <returns>The sheet space --> 3D model space transform.</returns>
      private static Transform MakeSheetToModelTransform(Transform trfModelToProjection, Transform trfProjectionToSheet)
      {
         if (null == trfModelToProjection || null == trfProjectionToSheet)
            return null;

         Transform modelToSheetTrf = trfProjectionToSheet.Multiply(trfModelToProjection);
         return modelToSheetTrf.Inverse;
      }

      /// <summary>
      /// Projects a point on a plane.
      /// </summary>
      /// <param name="plane">The plane on which the point will be projected</param>
      /// <param name="point">The point to projected onto the plane.</param>
      /// <returns>The point projected onto the plane.</returns>
      private static XYZ ProjectPointOnPlane(Plane plane, XYZ point)
      {
         UV uv = new UV();
         double ignored;
         plane.Project(point, out uv, out ignored);
         return plane.Origin + (plane.XVec * uv.U) + (plane.YVec * uv.V);
      }

      private static double RANDOM_X_SCALE = 5631;
      private static double RANDOM_Y_SCALE = 4369;

      /// <summary>
      /// Tests if a point is within a curveloop.  The point wil be projected onto the 
      /// plane which holds the curveloop before the test is executed.
      /// </summary>
      /// <param name="point">The point to test.</param>
      /// <param name="curveloop">A curveloop that lies in a plane.</param>
      /// <returns>True, if the point was inside the curveloop after the 
      /// point was projected onto the curveloop's plane. False, otherwise.</returns>
      private static bool IsPointInsideCurveLoop(XYZ point, CurveLoop curveloop)
      {
         // Starting at the point, shoot an infinite ray in one direction and count how many
         // times the ray intersects the edges of the curveloop.  If the ray intersects
         // an odd number of edges, then the point was inside the curveloop.  If it 
         // intersects an even number of times, then the point was outside the curveloop.
         //
         // Note: Revit doesn't have an infinite ray class, so a very long Line is used instead.
         // This test can fail if the curveloop is wider than the very long line.

         // Calculate the plane on which the edges of the curveloop lie.
         Plane plane = Plane.CreateByThreePoints(curveloop.ElementAt(0).GetEndPoint(0),
                                                 curveloop.ElementAt(1).GetEndPoint(0),
                                                 curveloop.ElementAt(2).GetEndPoint(0));

         // Project the test point on the plane.
         XYZ projectedPoint = ProjectPointOnPlane(plane, point);

         // Create a very long bounded line that starts at projectedPoint and runs 
         // along the plane's surface.
         Line veryLongLine = Line.CreateBound(projectedPoint,
            projectedPoint + (RANDOM_X_SCALE * plane.XVec) + (RANDOM_Y_SCALE * plane.YVec));

         // Count how many edges of curveloop intersect veryLongLine.
         int intersectionCount = 0;
         foreach (var edge in curveloop)
         {
            try
            {
               CurveIntersectResult res = veryLongLine.Intersect(edge, CurveIntersectResultOption.Detailed);
               if (SetComparisonResult.Overlap == res?.Result)
               {
                  if (res.GetOverlaps() == null)
                  {
                     throw new ArgumentException("Bad Input.");
                  }

                  intersectionCount += res.GetOverlaps().Count;
               }
            }
            catch (Autodesk.Revit.Exceptions.ArgumentNullException)
            {
               Trace.WriteLine("An ArgumentNullException occured in veryLongLine.Intersect(edge)");
            }
         }

         // If the intersection count is ODD, then the point is inside the curveloop.
         return 1 == (intersectionCount % 2);
      }

      /// <summary>
      /// Starting with a click on a viewport on a sheet, this method calculates the corresponding
      /// ray through 3D model.
      /// </summary>
      /// <param name="viewport">The viewport on a sheet that was clicked.</param>
      /// <param name="click">The clicked point.</param>
      /// <returns>An XYZ that represents a ray through the model in the direction of the viewport view's
      /// view direction vector.</returns>
      private static XYZ CalculateClickAsModelRay(Viewport viewport, XYZ click)
      {
         if (null == viewport || null == click)
            return null;

         Document doc = viewport.Document;
         if (null == doc)
            return null;

         View view = doc.GetElement(viewport.ViewId) as View;
         if (null == view)
            return null;

         // Transform for view projection space --> sheet space
         Transform trfProjectionToSheet = new Transform(viewport.GetProjectionToSheetTransform());

         // Most views have just one model space --> view projection space transform. 
         // However, views whose view crops are broken into multiple regions
         // have more than one transform.
         //
         // Iterate all the model space --> view projection space transforms.  
         // Look for the region that contains the click as a model point.
         foreach (TransformWithBoundary trfWithBoundary in view.GetModelToProjectionTransforms())
         {
            // Make the sheet space --> 3D model space transform for the current crop region.
            Transform trfSheetToModel = MakeSheetToModelTransform(trfWithBoundary.GetModelToProjectionTransform(), trfProjectionToSheet);
            if (null == trfSheetToModel)
            {
               throw new InvalidOperationException("An error occured when calculating the sheet-to-model transforms.");
            }

            // Transform the click point into 3D model space.
            XYZ clickAsModelRay = trfSheetToModel.OfPoint(click);

            // Get the edges of the current crop region.
            CurveLoop modelCurveLoop = trfWithBoundary.GetBoundary();

            if (null == modelCurveLoop)
            {
               // Views that are uncropped will have just one TransformWithBoundary and its
               // curveloop will be null.  All sheet points will be subject to the transform
               // from this TransformWithBoundary.
               return clickAsModelRay;
            }
            else if (IsPointInsideCurveLoop(clickAsModelRay, modelCurveLoop))
            {
               return clickAsModelRay;
            }
         }

         // The clicked point on the sheet is outside of all of the TransformWithBoundary crop regions.
         // The model ray can't be calculated.
         return null;
      }

      /// <summary>
      /// Gets the cut plane from a plan view.
      /// </summary>
      /// <param name="plan">The plan view containing the cut plane.</param>
      /// <returns>A plane representing the plan view's cut plane.</returns>
      private static Plane GetViewPlanCutPlane(ViewPlan plan)
      {
         if (null == plan)
            return null;

         double levelElevation = 0.0;
         if (null != plan.GenLevel)
            levelElevation = plan.GenLevel.Elevation;
         double cutPlaneOffset = plan.GetViewRange().GetOffset(PlanViewPlane.CutPlane);
         double viewCutPlaneElevation = levelElevation + cutPlaneOffset;

         return Plane.CreateByNormalAndOrigin(plan.ViewDirection, new XYZ(0.0, 0.0, viewCutPlaneElevation));
      }

      /// <summary>
      /// Creates a perspective View3D.
      /// </summary>
      /// <param name="doc">The document.</param>
      /// <param name="eyePosition">The eye position in 3D model space for the new 3D view.</param>
      /// <param name="upDir">The up direction in 3D model space for the new 3D view.</param>
      /// <param name="forwardDir">The forward direction in 3D model space for the new 3D view.</param>
      /// <returns>The new View3D.</returns>
      private static View3D Create3DView(Document doc, XYZ eyePosition, XYZ upDir, XYZ forwardDir)
      {
         if (null == doc || null == eyePosition || null == upDir || null == forwardDir)
            return null;

         var vft = new FilteredElementCollector(doc)
            .OfClass(typeof(ViewFamilyType))
            .Cast<ViewFamilyType>()
            .FirstOrDefault(t => t.ViewFamily == ViewFamily.ThreeDimensional);

         View3D view3d = View3D.CreatePerspective(doc, vft.Id);
         if (null == view3d)
         {
            return null;
         }

         view3d.SetOrientation(new ViewOrientation3D(eyePosition, upDir, forwardDir));

         return view3d;
      }
   }
}

=== CODE_BLOCK_0151 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Autodesk.Revit.UI.UIApplication revit = commandData.Application;

            try
            {
                // function initialization and find out a slab's Level, Type name, and set the Span Direction properties.
                bool isInitialization = this.Initialize(revit);
                if (false == isInitialization)
                {
                    return Autodesk.Revit.UI.Result.Failed;
                }

                // show a displayForm to display the properties of the slab
                SlabPropertiesForm slabForm = new SlabPropertiesForm(this);
                if (DialogResult.OK != slabForm.ShowDialog())
                {
                    return Autodesk.Revit.UI.Result.Cancelled;
                }
            }
            catch (Exception displayProblem)
            {
                TaskDialog.Show("Revit", displayProblem.ToString());
                return Autodesk.Revit.UI.Result.Failed;
            }

            return Autodesk.Revit.UI.Result.Succeeded;
        }
        #endregion


        #region Class propertied
        /// <summary>
        /// Level property, read only.
        /// </summary>
        public string Level
        {
            get
            {
                return m_level;
            }
        }


        /// <summary>
        /// TypeName property, read only.
        /// </summary>
        public string TypeName
        {
            get
            {
                return m_typeName;
            }
        }


        /// <summary>
        /// SpanDirection property, read only.
        /// </summary>
        public string SpanDirection
        {
            get
            {
                return m_spanDirection;
            }
        }


        /// <summary>
        /// NumberOfLayers property, read only.
        /// </summary>
        public int NumberOfLayers
        {
            get
            {
                return m_numberOfLayers;
            }
        }


        /// <summary>
        /// LayerThickness property, read only.
        /// </summary>
        public string LayerThickness
        {
            get
            {
                return m_thickness;
            }
        }


        /// <summary>
        /// LayerMaterialName property, read only.
        /// </summary>
        public string LayerMaterialName
        {
            get
            {
                return m_materialName;
            }
        }


        /// <summary>
        /// LayerYoungModulusX property, read only.
        /// </summary>
        public string LayerYoungModulusX
        {
            get
            {
                return m_youngModulusX;
            }
        }


        /// <summary>
        /// LayerYoungModulusY property, read only.
        /// </summary>
        public string LayerYoungModulusY
        {
            get
            {
                return m_youngModulusY;
            }
        }


        /// <summary>
        /// LayerYoungModulusZ property, read only.
        /// </summary>
        public string LayerYoungModulusZ
        {
            get
            {
                return m_youngModulusZ;
            }
        }
        #endregion


        #region Public class method
        /// <summary>
        /// SetLayer method
        /// </summary>
        /// <param name="layerNumber">The layerNumber for the number of the layers</param>
        public void SetLayer(int layerNumber)
        {
            // Get each layer.
            // An individual layer can be accessed by Layers property and its thickness and material can then be reported.
            m_slabLayer = m_slabLayerCollection[layerNumber];

            // Get the Thickness property and change to the metric millimeter
            m_thickness = ((m_slabLayer.Width) * ToMetricThickness * ToMillimeter).ToString() + " mm";

            // Get the Material name property
            if (ElementId.InvalidElementId != m_slabLayer.MaterialId)
            {
                Material material = m_document.GetElement(m_slabLayer.MaterialId) as Material;
                m_materialName = material.Name;
            }
            else
            {
                m_materialName = "Null";
            }

            // The Young modulus can be found from the material by using the following generic parameters: 
            // PHY_MATERIAL_PARAM_YOUNG_MOD1, PHY_MATERIAL_PARAM_YOUNG_MOD2, PHY_MATERIAL_PARAM_YOUNG_MOD3
            if (ElementId.InvalidElementId != m_slabLayer.MaterialId)
            {
                Material material = m_document.GetElement(m_slabLayer.MaterialId) as Material;
                Parameter youngModuleAttribute = null;
                youngModuleAttribute = material.get_Parameter(BuiltInParameter.PHY_MATERIAL_PARAM_YOUNG_MOD1);
                if (null != youngModuleAttribute)
                {
                    m_youngModulusX = (youngModuleAttribute.AsDouble() / ToMetricYoungmodulus).ToString("F2") + " MPa";
                }
                youngModuleAttribute = material.get_Parameter(BuiltInParameter.PHY_MATERIAL_PARAM_YOUNG_MOD2);
                if (null != youngModuleAttribute)
                {
                    m_youngModulusY = (youngModuleAttribute.AsDouble() / ToMetricYoungmodulus).ToString("F2") + " MPa";
                }
                youngModuleAttribute = material.get_Parameter(BuiltInParameter.PHY_MATERIAL_PARAM_YOUNG_MOD3);
                if (null != youngModuleAttribute)
                {
                    m_youngModulusZ = (youngModuleAttribute.AsDouble() / ToMetricYoungmodulus).ToString("F2") + " MPa";
                }
            }
            else
            {
                m_youngModulusX = "Null";
                m_youngModulusY = "Null";
                m_youngModulusZ = "Null";
            }
        }
        #endregion


        #region Private class memeber methods
        /// <summary>
        /// Initialization and find out a slab's Level, Type name, and set the Span Direction properties.
        /// </summary>
        /// <param name="revit">The revit object for the active instance of Autodesk Revit.</param>
        /// <returns>A value that signifies if your initialization was successful for true or failed for false.</returns>
        private bool Initialize(Autodesk.Revit.UI.UIApplication revit)
        {
            m_slabComponent = new ElementSet();
            foreach (ElementId elementId in revit.ActiveUIDocument.Selection.GetElementIds())
            {
               m_slabComponent.Insert(revit.ActiveUIDocument.Document.GetElement(elementId));
            }
            m_document = revit.ActiveUIDocument.Document;

            // There must be exactly one slab selected
            if (m_slabComponent.IsEmpty)
            {
                // nothing selected
                TaskDialog.Show("Revit", "Please select a slab.");
                return false;
            }
            else if (1 != m_slabComponent.Size)
            {
                // too many things selected
                TaskDialog.Show("Revit", "Please select only one slab.");
                return false;
            }

            foreach (Element e in m_slabComponent)
            {
                // If the element isn't a slab, give the message and return failure. 
                // Else find out its Level, Type name, and set the Span Direction properties. 
                if ("Autodesk.Revit.DB.Floor" != e.GetType().ToString())
                {
                    TaskDialog.Show("Revit", "A slab should be selected.");
                    return false;
                }

                // Change the element type to floor type
                m_slabFloor = e as Floor;

                // Get the layer information from the type object by using the CompoundStructure property
                // The Layers property is then used to retrieve all the layers
                m_slabLayerCollection = m_slabFloor.FloorType.GetCompoundStructure().GetLayers();
                m_numberOfLayers = m_slabLayerCollection.Count;

                // Get the Level property by the floor's Level property
                m_level = (m_document.GetElement(m_slabFloor.LevelId) as Level).Name;

                // Get the Type name property by the floor's FloorType property
                m_typeName = m_slabFloor.FloorType.Name;

                // The span direction can be found using generic parameter access 
                // using the built in parameter FLOOR_PARAM_SPAN_DIRECTION
                Parameter spanDirectionAttribute;
                spanDirectionAttribute = m_slabFloor.get_Parameter(BuiltInParameter.FLOOR_PARAM_SPAN_DIRECTION);
                if (null != spanDirectionAttribute)
                {
                    // Set the Span Direction property
                    this.SetSpanDirection(spanDirectionAttribute.AsDouble());
                }
            }
            return true;
        }


        /// <summary>
        /// Set SpanDirection property to the class private member
        /// Because of the property retrieved from the parameter uses radian for unit, we should change it to degree.
        /// </summary>
        /// <param name="spanDirection">The value of span direction property</param>
        private void SetSpanDirection(double spanDirection)
        {
            double spanDirectionDegree;

            // Change "radian" to "degree".
            spanDirectionDegree = spanDirection / PI * Degree;

            // If the absolute value very small, we consider it to be zero
            if (Math.Abs(spanDirectionDegree) < 1E-12)
            {
                spanDirectionDegree = 0.0;
            }

            // The precision is 0.01, and unit is "degree".
            m_spanDirection = spanDirectionDegree.ToString("F2");
        }
        #endregion
    }
}

=== CODE_BLOCK_0153 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Floor selectFloor = GetSelectFloor(commandData);
            if (null == selectFloor)
            {
                message = "Make sure selected only one floor (Slab) in Revit.";
                return Autodesk.Revit.UI.Result.Failed;
            }

            SlabShapeEditingForm slabShapeEditingForm = 
                new SlabShapeEditingForm(selectFloor, commandData);
            slabShapeEditingForm.ShowDialog();

            return Autodesk.Revit.UI.Result.Succeeded;
        }

        /// <summary>
        /// get selected floor (slab)
        /// </summary>
        /// <param name="commandData">object which contains reference of Revit Application.</param>
        /// <returns>selected floor (slab)</returns>
        private Floor GetSelectFloor(ExternalCommandData commandData)
        {
           ElementSet eleSet = new ElementSet();
            foreach (ElementId elementId in commandData.Application.ActiveUIDocument.Selection.GetElementIds())
            {
               eleSet.Insert(commandData.Application.ActiveUIDocument.Document.GetElement(elementId));
            }
            if (eleSet.Size != 1) { return null; }

            IEnumerator iter = eleSet.GetEnumerator();
            iter.Reset();
            while (iter.MoveNext())
            {
                return iter.Current as Floor;
            }
            return null;
        }
        #endregion
    }
}

=== CODE_BLOCK_0155 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            // NOTES: Anything can be done in this method, such as the solid-solid cut operation.

            // Get the application and document from external command data.
            Application app = commandData.Application.Application;
            Document activeDoc = commandData.Application.ActiveUIDocument.Document;

            #region Demo how to use the SolidSolidCut API to make one solid cut another.

            long solidToBeCutElementId = 30481; //The cube
            long cuttingSolidElementId = 30809; //The sphere

            //Get element by ElementId
            Element solidToBeCut = activeDoc.GetElement(new ElementId(solidToBeCutElementId));
            Element cuttingSolid = activeDoc.GetElement(new ElementId(cuttingSolidElementId));

            //If the two elements do not exist, notify user to open the family file then try this command.
            if (solidToBeCut == null || cuttingSolid == null)
            {
                TaskDialog.Show("Notice", "Please open the family file SolidSolidCut.rfa, then try to run this command.");

                return Autodesk.Revit.UI.Result.Succeeded;
            }

            //Check whether the cuttingSolid can cut the solidToBeCut
            CutFailureReason cutFailureReason = new CutFailureReason();
            if (SolidSolidCutUtils.CanElementCutElement(cuttingSolid, solidToBeCut, out cutFailureReason))
            {
                //cuttingSolid can cut solidToBeCut

                //Do the solid-solid cut operation
                //Start a transaction
                Transaction transaction = new Transaction(activeDoc);
                transaction.Start("AddCutBetweenSolids(activeDoc, solidToBeCut, cuttingSolid)");

                //Let the cuttingSolid cut the solidToBeCut
                SolidSolidCutUtils.AddCutBetweenSolids(activeDoc, solidToBeCut, cuttingSolid);

                transaction.Commit();
            }

            #endregion

            return Autodesk.Revit.UI.Result.Succeeded;
        }
        #endregion
    }

    /// <summary>
    /// Demonstrate how to use the SolidSolidCut API to uncut two solids which have the cutting relationship.
    /// </summary>
    [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
    [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
    public class Uncut : IExternalCommand
    {
        #region IExternalCommand Members

        /// <summary>
        /// Implement this method as an external command for Revit.
        /// </summary>
        /// <param name="commandData">An object that is passed to the external application
        /// which contains data related to the command,
        /// such as the application object and active view.</param>
        /// <param name="message">A message that can be set by the external application
        /// which will be displayed if a failure or cancellation is returned by
        /// the external command.</param>
        /// <param name="elements">A set of elements to which the external application
        /// can add elements that are to be highlighted in case of failure or cancellation.</param>
        /// <returns>Return the status of the external command.
        /// A result of Succeeded means that the API external method functioned as expected.
        /// Cancelled can be used to signify that the user cancelled the external operation 
        /// at some point. Failure should be returned if the application is unable to proceed with
        /// the operation.</returns>
        public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            // NOTES: Anything can be done in this method, such as the solid-solid uncut operation.

            // Get the application and document from external command data.
            Application app = commandData.Application.Application;
            Document activeDoc = commandData.Application.ActiveUIDocument.Document;

            #region Demo how to use the SolidSolidCut API to uncut two solids which have the cutting relationship.

            long solidToBeCutElementId = 30481; //The cube
            long cuttingSolidElementId = 30809; //The sphere

            //Get element by ElementId
            Element solidToBeCut = activeDoc.GetElement(new ElementId(solidToBeCutElementId));
            Element cuttingSolid = activeDoc.GetElement(new ElementId(cuttingSolidElementId));

            //If the two elements do not exist, notify user to open the family file then try this command.
            if (solidToBeCut == null || cuttingSolid == null)
            {
                TaskDialog.Show("Notice", "Please open the family file SolidSolidCut.rfa, then try to run this command.");

                return Autodesk.Revit.UI.Result.Succeeded;
            }

            //Remove the solid-solid cut (Uncut)
            //Start a transaction
            Transaction transaction = new Transaction(activeDoc);
            transaction.Start("RemoveCutBetweenSolids(activeDoc, solidToBeCut, cuttingSolid)");

            //Remove the cutting relationship between solidToBeCut and cuttingSolid (Uncut)
            SolidSolidCutUtils.RemoveCutBetweenSolids(activeDoc, solidToBeCut, cuttingSolid);

            transaction.Commit();

            #endregion

            return Autodesk.Revit.UI.Result.Succeeded;
        }
        #endregion
    }
}

=== CODE_BLOCK_0157 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Autodesk.Revit.UI.UIApplication application = commandData.Application;
            m_docment = application.ActiveUIDocument.Document;
            try
            {
                // user should select one slab firstly. 
                if (application.ActiveUIDocument.Selection.GetElementIds().Count == 0)
                {
                    TaskDialog.Show("Revit", "Please select one slab firstly.", TaskDialogCommonButtons.Ok);
                    return Autodesk.Revit.UI.Result.Cancelled;
                }

                // get the selected slab and show its span direction
                ElementSet elementSet = new ElementSet();
                foreach (ElementId elementId in application.ActiveUIDocument.Selection.GetElementIds())
                {
                   elementSet.Insert(application.ActiveUIDocument.Document.GetElement(elementId));
                }
                ElementSetIterator elemIter = elementSet.ForwardIterator();
                elemIter.Reset();
                while (elemIter.MoveNext())
                {
                    Floor floor = elemIter.Current as Floor;
                    if (floor != null)
                    {
                        GetSpanDirectionAndSymobls(floor);
                    }
                }
            }
            catch (Exception ex)
            {
                message = ex.ToString();
                return Autodesk.Revit.UI.Result.Failed;
            }
            return Autodesk.Revit.UI.Result.Succeeded;
        }
        #endregion


        /// <summary>
        /// Get SpanDirection and SpanDirectionSymobols of Floor
        /// </summary>
        /// <param name="floor"></param>
        void GetSpanDirectionAndSymobls(Floor floor)
        {
            if (null != floor)
            {
                // get SpanDirection angle of Floor(Slab)
                // The angle returned is in radians. An exception will be thrown if the floor
                // is non structural.
                String spanDirAngle = "Span direction angle: " + floor.SpanDirectionAngle.ToString() + "\r\n";

                // get span direction symbols of Floor(Slab)
                String symbols = "Span direction symbols: \r\n\t";
                System.Collections.Generic.ICollection<ElementId> symbolArray = floor.GetSpanDirectionSymbolIds();
                //ElementArrayIterator symbolIter = symbolArray.ForwardIterator();
                //symbolIter.Reset();
                //while (symbolIter.MoveNext())
                foreach (ElementId eid in symbolArray)
                {
                    Element elem = m_docment.GetElement(eid);
                    if (elem != null)
                    {
                        symbols += (m_docment.GetElement(elem.GetTypeId()) as ElementType).Name + "\r\n";
                    }
                }

                TaskDialog.Show("Revit Direction", spanDirAngle + symbols, TaskDialogCommonButtons.Ok);
            }
            else
            {
                new Exception("Get Floor and SpanDirectionAngle and Symbols failed!");
            }
        }
    }
}

=== CODE_BLOCK_0159 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
                                               ref string message,
                                               ElementSet elements)
        {
            try
            {
                Transaction documentTransaction = new Transaction(commandData.Application.ActiveUIDocument.Document, "Document");
                documentTransaction.Start();
                using (SpotDimensionInfoDlg infoForm = new SpotDimensionInfoDlg(commandData))
                {
                    //Highlight the selected spotdimension
                    if (infoForm.ShowDialog() == System.Windows.Forms.DialogResult.OK 
                        && infoForm.SelectedSpotDimension != null)
                    {
                        elements.Insert(infoForm.SelectedSpotDimension);
                        message = "High light the selected SpotDimension";
                        return Autodesk.Revit.UI.Result.Failed;
                    }
                }
                documentTransaction.Commit();
                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception ex)
            {
               // If there are something wrong, give error information and return failed
               message = ex.Message;
               return Autodesk.Revit.UI.Result.Failed;
            }
        }
    }
}

=== CODE_BLOCK_0161 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref String message, Autodesk.Revit.DB.ElementSet elements)
      {
         try
         {
            Autodesk.Revit.UI.UIApplication rvtApp = commandData.Application;
            Autodesk.Revit.UI.UIDocument rvtDoc = rvtApp.ActiveUIDocument;
            ElementSet ss = new ElementSet();
            foreach (ElementId elementId in rvtDoc.Selection.GetElementIds())
            {
               ss.Insert(rvtDoc.Document.GetElement(elementId));
            }

            Transaction tran = new Transaction(rvtDoc.Document, "StructSample");
            tran.Start();

            ElementSet walls = rvtApp.Application.Create.NewElementSet();

            //  iterate through a selection set, and collect walls which are constrained at the top and the bottom.
            foreach (Autodesk.Revit.DB.Element elem in ss)
            {
               if (elem.GetType() == typeof(Autodesk.Revit.DB.Wall))
               {
                  if (elem.get_Parameter(Autodesk.Revit.DB.BuiltInParameter.WALL_HEIGHT_TYPE) != null
                      && elem.get_Parameter(Autodesk.Revit.DB.BuiltInParameter.WALL_BASE_CONSTRAINT) != null)
                  {
                     walls.Insert(elem);
                  }
               }
            }

            //  how many did we get? 
            TaskDialog.Show("Revit", "# of constrained walls in the selection set is " + walls.Size);
            if (walls.Size == 0)
            {
               message = "You must select some walls that are constrained top or bottom";
               return Autodesk.Revit.UI.Result.Failed;
            }

            //  next, we need a column symbol. For simplicity, the symbol name is hard-coded here. 
            Autodesk.Revit.DB.FamilySymbol colType = FindFamilySymbol(rvtDoc.Document, "M_Wood Timber Column", "191 x 292mm");
            if (colType == null)
            {
               TaskDialog.Show("Revit", "failed to got a symbol. Please load the M_Wood Timber Column : 191 x 292mm family");
               message = "Please load the M_Wood Timber Column : 191 x 292mm family";

               return Autodesk.Revit.UI.Result.Failed;
            }

            //  place columns.
            double spacing = 5;  //  Spacing in feet hard coded. Note: Revit's internal length unit is feet. 
            foreach (Autodesk.Revit.DB.Wall wall in walls)
            {
               FrameWall(rvtApp.Application, wall, spacing, colType);
            }
            tran.Commit();

            //  return succeeded info. 
            return Autodesk.Revit.UI.Result.Succeeded;
         }
         catch (Exception ex)
         {
            message = ex.ToString();
            return Autodesk.Revit.UI.Result.Failed;
         }
      }
      #endregion


      /// <summary>
      /// find Column which will be used to placed to Wall
      /// </summary>
      /// <param name="rvtDoc">Revit document</param>
      /// <param name="familyName">Family name of Column</param>
      /// <param name="symbolName">Symbol of Column</param>
      /// <returns></returns>
      private FamilySymbol FindFamilySymbol(Document rvtDoc, string familyName, string symbolName)
      {
         FilteredElementCollector collector = new FilteredElementCollector(rvtDoc);
         FilteredElementIterator itr = collector.OfClass(typeof(Family)).GetElementIterator();
         itr.Reset();
         while (itr.MoveNext())
         {
            Autodesk.Revit.DB.Element elem = (Autodesk.Revit.DB.Element)itr.Current;
            if (elem.GetType() == typeof(Autodesk.Revit.DB.Family))
            {
               if (elem.Name == familyName)
               {
                  Autodesk.Revit.DB.Family family = (Autodesk.Revit.DB.Family)elem;
                  foreach (Autodesk.Revit.DB.ElementId symbolId in family.GetFamilySymbolIds())
                  {
                     Autodesk.Revit.DB.FamilySymbol symbol = (Autodesk.Revit.DB.FamilySymbol)rvtDoc.GetElement(symbolId);
                     if (symbol.Name == symbolName)
                     {
                        return symbol;
                     }
                  }
               }
            }
         }
         return null;
      }


      /// <summary>
      /// Frame a Wall
      /// </summary>
      /// <param name="rvtApp">Revit application></param>
      /// <param name="wall">Wall as host to place column objects</param>
      /// <param name="spacing">spacing between two columns</param>
      /// <param name="columnType">column type</param>
      private void FrameWall(Autodesk.Revit.ApplicationServices.Application rvtApp, Autodesk.Revit.DB.Wall wall,
          double spacing, Autodesk.Revit.DB.FamilySymbol columnType)
      {
         Autodesk.Revit.DB.Document rvtDoc = wall.Document;

         // get wall location
         Autodesk.Revit.DB.LocationCurve loc = (Autodesk.Revit.DB.LocationCurve)wall.Location;
         Autodesk.Revit.DB.XYZ startPt = loc.Curve.GetEndPoint(0);
         Autodesk.Revit.DB.XYZ endPt = loc.Curve.GetEndPoint(1);

         // get wall's vector
         Autodesk.Revit.DB.UV wallVec = new Autodesk.Revit.DB.UV(
             endPt.X - startPt.X,
             endPt.Y - startPt.Y);

         // get the axis vector
         Autodesk.Revit.DB.UV axis = new Autodesk.Revit.DB.UV(1.0, 0.0);

         Autodesk.Revit.DB.ElementId baseLevelId = wall.get_Parameter(BuiltInParameter.WALL_BASE_CONSTRAINT).AsElementId();
         Autodesk.Revit.DB.ElementId topLevelId = wall.get_Parameter(BuiltInParameter.WALL_HEIGHT_TYPE).AsElementId();

         // get wall length and vector
         double wallLength = wallVec.GetLength();
         wallVec = wallVec.Normalize();

         // get # of column
         int nmax = (int)(wallLength / spacing);

         TaskDialog.Show("Revit", "wallLength = " + wallLength + "\r\nspacing = " + spacing.ToString() + "\r\nnmax = " + nmax.ToString());

         // get angle of wall and axis
         double angle = wallVec.AngleTo(axis);

         // place all column
         Autodesk.Revit.DB.XYZ loc2 = startPt;
         double dx = wallVec.U * spacing;
         double dy = wallVec.V * spacing;
         for (int i = 0; i < nmax; i++)
         {
            PlaceColumn(rvtApp, rvtDoc, loc2, angle, columnType, baseLevelId, topLevelId);

            loc2 = new XYZ(loc2.X + dx,
                loc2.Y + dy,
                loc2.Z);
         }

         // place column at end point of wall
         PlaceColumn(rvtApp, rvtDoc, endPt, angle, columnType, baseLevelId, topLevelId);
      }


      /// <summary>
      /// create a column instance and place it on the wall line.
      /// </summary>
      /// <param name="rvtApp">revit application</param>
      /// <param name="rvtDoc">revit document</param>
      /// <param name="point2">location for placing column</param>
      /// <param name="angle">column angle</param>
      /// <param name="columnType">column type placed in Wall</param>
      /// <param name="baseLevelId">level id for base level where column is placed</param>
      /// <param name="topLevelId">level id for top level where column is placed</param>
      private void PlaceColumn(Autodesk.Revit.ApplicationServices.Application rvtApp, Document rvtDoc, Autodesk.Revit.DB.XYZ point2,
          double angle, FamilySymbol columnType, Autodesk.Revit.DB.ElementId baseLevelId, Autodesk.Revit.DB.ElementId topLevelId)
      {
         Autodesk.Revit.DB.XYZ point = point2;

         // Note: Must use level-hosted NewFamilyInstance!
         Level instLevel = (Level)rvtDoc.GetElement(baseLevelId);
         if (!columnType.IsActive)
            columnType.Activate();
         Autodesk.Revit.DB.FamilyInstance column = rvtDoc.Create.NewFamilyInstance(point, columnType,
             instLevel, Autodesk.Revit.DB.Structure.StructuralType.Column);
         if (column == null)
         {
            TaskDialog.Show("Revit", "failed to create an instance of a column.");
            return;
         }

         // rotate column to place it to right location
         Autodesk.Revit.DB.XYZ zVec = new Autodesk.Revit.DB.XYZ(0, 0, 1);
         Autodesk.Revit.DB.Line axis = Line.CreateUnbound(point, zVec);
         column.Location.Rotate(axis, angle);

         // Set the level Ids
         Parameter baseLevelParameter = column.get_Parameter(Autodesk.Revit.DB.BuiltInParameter.FAMILY_BASE_LEVEL_PARAM);
         Parameter topLevelParameter = column.get_Parameter(Autodesk.Revit.DB.BuiltInParameter.FAMILY_TOP_LEVEL_PARAM); ;
         baseLevelParameter.Set(baseLevelId);
         topLevelParameter.Set(topLevelId);
      }
   }
}

=== CODE_BLOCK_0163 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,
                                                ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Autodesk.Revit.UI.UIApplication revit = commandData.Application;

            // Get the selected floor
            UIDocument project = revit.ActiveUIDocument;
            Selection choices = project.Selection;
            ElementSet collection = new ElementSet();
            foreach (ElementId elementId in choices.GetElementIds())
            {
               collection.Insert(project.Document.GetElement(elementId));
            }

            // Only allow to select one floor, or else report the failure
            if (1 != collection.Size)
            {
                message = "Please select a floor.";
                return Autodesk.Revit.UI.Result.Failed;
            }
            foreach (Element e in collection)
            {
                m_slab = e as Autodesk.Revit.DB.Floor;
                if (null == m_slab)
                {
                    message = "Please select a floor.";
                    return Autodesk.Revit.UI.Result.Failed;
                }
            }

            // Get the function of each of its structural layers
            foreach (CompoundStructureLayer e in m_slab.FloorType.GetCompoundStructure().GetLayers())
            {
                // With the selected floor, judge if the function of each of its structural layers
                // is exist, if it's not exist, there should be zero.
                if (0 == e.Function)
                {
                    m_functions.Add("No function");
                }
                else
                {
                    m_functions.Add(e.Function.ToString());
                }

            }

            // Display them in a form
            StructuralLayerFunctionForm displayForm = new StructuralLayerFunctionForm(this);
            displayForm.ShowDialog();

            return Autodesk.Revit.UI.Result.Succeeded;
        }
        #endregion
    }
}

=== CODE_BLOCK_0165 ===
public Autodesk.Revit.UI.Result Execute(
            ExternalCommandData commandData,
            ref string message,
            ElementSet elements)
        {
            try
            {
                //prepare data
                TagBeamData dataBuffer = new TagBeamData(commandData);

                // show UI
                using (TagBeamForm displayForm = new TagBeamForm(dataBuffer))
                {
                    DialogResult result = displayForm.ShowDialog();
                    if (DialogResult.OK != result)
                    {
                        return Autodesk.Revit.UI.Result.Cancelled;
                    }
                }

                return Autodesk.Revit.UI.Result.Succeeded;
            }
            catch (Exception e)
            {
                message = e.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
        #endregion IExternalCommand Members Implementation
    }

    [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
    public class TagRebar : IExternalCommand
    {
        public Autodesk.Revit.UI.Result Execute(
          ExternalCommandData commandData,
          ref string message,
          ElementSet elements)
        {
            try
            {
                // Get the active document and view
                UIDocument revitDoc = commandData.Application.ActiveUIDocument;
                Autodesk.Revit.DB.View view = revitDoc.Document.ActiveView;
                foreach (ElementId elemId in revitDoc.Selection.GetElementIds())
                {
                   Element elem = revitDoc.Document.GetElement(elemId);
                    if (elem.GetType() == typeof(Autodesk.Revit.DB.Structure.Rebar))
                    {
                        // cast to Rebar and get its first curve
                        Autodesk.Revit.DB.Structure.Rebar rebar = (Autodesk.Revit.DB.Structure.Rebar)elem;
                        Autodesk.Revit.DB.Curve curve = rebar.GetCenterlineCurves(false, false, false,MultiplanarOption.IncludeAllMultiplanarCurves,0)[0];
                        IList<Subelement> subelements = rebar.GetSubelements();  

                        // create a rebar tag at the first end point of the first curve
                        using( Transaction t = new Transaction(revitDoc.Document))
                        {
                           t.Start("Create new tag");
                           IndependentTag tag = IndependentTag.Create(revitDoc.Document, view.Id, subelements[0].GetReference(), true,
                               Autodesk.Revit.DB.TagMode.TM_ADDBY_CATEGORY,
                               Autodesk.Revit.DB.TagOrientation.Horizontal, curve.GetEndPoint(0));
                           t.Commit();
                        }
                        return Autodesk.Revit.UI.Result.Succeeded;
                    }
                }
                message = "No rebar selected!";
                return Autodesk.Revit.UI.Result.Failed;
            }
            catch (Exception e)
            {
                message = e.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
    }

    [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
    public class CreateText : IExternalCommand
    {
        public Autodesk.Revit.UI.Result Execute(
          ExternalCommandData commandData,
          ref string message,
          ElementSet elements)
        {
            try
            {
                // get the active document and view
                UIDocument revitDoc = commandData.Application.ActiveUIDocument;
                Autodesk.Revit.DB.View view = revitDoc.ActiveView;
                Document dbDoc = revitDoc.Document;
                ElementId currentTextTypeId = dbDoc.GetDefaultElementTypeId(ElementTypeGroup.TextNoteType);

                foreach (ElementId elemId in revitDoc.Selection.GetElementIds())
                {
                   Element elem = dbDoc.GetElement(elemId);
                    if (elem.GetType() == typeof(Autodesk.Revit.DB.Structure.Rebar))
                    {
                        // cast to Rebar and get its first curve
                        Autodesk.Revit.DB.Structure.Rebar rebar = (Autodesk.Revit.DB.Structure.Rebar)elem;
                        Autodesk.Revit.DB.Curve curve = rebar.GetCenterlineCurves(false, false, false, MultiplanarOption.IncludeAllMultiplanarCurves, 0)[0];

                        // calculate necessary arguments
                        Autodesk.Revit.DB.XYZ origin = new XYZ(
                            curve.GetEndPoint(0).X + curve.Length,
                            curve.GetEndPoint(0).Y,
                            curve.GetEndPoint(0).Z);
                        string strText = "This is " + rebar.Category.Name + " : " + rebar.Name;

                        // create the text
                        using( Transaction t = new Transaction(dbDoc))
                        {
                           t.Start("New text note");
                           TextNote.Create(dbDoc, view.Id, origin, strText, currentTextTypeId);
                           t.Commit();
                        }
                        return Autodesk.Revit.UI.Result.Succeeded;
                    }
                }
                message = "No rebar selected!";
                return Autodesk.Revit.UI.Result.Failed;
            }
            catch (Exception e)
            {
                message = e.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
        }
    }
}

=== CODE_BLOCK_0167 ===
public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         var uidoc = commandData.Application.ActiveUIDocument;
         var doc = uidoc.Document;
         var sel = uidoc.Selection;

         Autodesk.Revit.DB.Toposolid topo = doc.GetElement(sel.PickObject(ObjectType.Element, new ToposolidFilter())) as Autodesk.Revit.DB.Toposolid;

         List<Curve> curveList = new List<Curve>();
         sel.PickObjects(ObjectType.Element, new ModelCurveFilter()).ToList().ForEach(x => curveList.Add((doc.GetElement(x) as ModelCurve).GeometryCurve));
         CurveLoop cl = CurveLoop.Create(curveList);

         using (Transaction transaction = new Transaction(doc, "split"))
         {
            transaction.Start();
            topo.Split(new List<CurveLoop> { cl });
            transaction.Commit();
         }

         return Result.Succeeded;
      }
   }

   /// <summary>
   /// Simplify a toposolid by reducing its inner vertices.
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class SimplifyToposolid : IExternalCommand
   {
      /// <summary>
      /// Implement this method as an external command for Revit.
      /// </summary>
      /// <param name="commandData">An object that is passed to the external application 
      /// which contains data related to the command, 
      /// such as the application object and active view.</param>
      /// <param name="message">A message that can be set by the external application 
      /// which will be displayed if a failure or cancellation is returned by 
      /// the external command.</param>
      /// <param name="elements">A set of elements to which the external application 
      /// can add elements that are to be highlighted in case of failure or cancellation.</param>
      /// <returns>Return the status of the external command. 
      /// A result of Succeeded means that the API external method functioned as expected. 
      /// Cancelled can be used to signify that the user cancelled the external operation 
      /// at some point. Failure should be returned if the application is unable to proceed with 
      /// the operation.</returns>
      public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         var uidoc = commandData.Application.ActiveUIDocument;
         var doc = uidoc.Document;
         var sel = uidoc.Selection;

         Autodesk.Revit.DB.Toposolid topo = doc.GetElement(sel.PickObject(ObjectType.Element, new ToposolidFilter())) as Autodesk.Revit.DB.Toposolid;

         using (Transaction transaction = new Transaction(doc, "simplify"))
         {
            transaction.Start();
            topo.Simplify(0.6);
            transaction.Commit();
         }

         return Result.Succeeded;
      }
   }

   /// <summary>
   /// Toposolid max boolean stability factor sample
   /// </summary>
   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]
   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]
   public class ToposolidMaxBooleanStabilityFactor: IExternalCommand
   {
      /// <summary>
      /// Implement this method as an external command for Revit.
      /// </summary>
      /// <param name="commandData">An object that is passed to the external application 
      /// which contains data related to the command, 
      /// such as the application object and active view.</param>
      /// <param name="message">A message that can be set by the external application 
      /// which will be displayed if a failure or cancellation is returned by 
      /// the external command.</param>
      /// <param name="elements">A set of elements to which the external application 
      /// can add elements that are to be highlighted in case of failure or cancellation.</param>
      /// <returns>Return the status of the external command. 
      /// A result of Succeeded means that the API external method functioned as expected. 
      /// Cancelled can be used to signify that the user canceled the external operation 
      /// at some point. Failure should be returned if the application is unable to proceed with 
      /// the operation.</returns>
      public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)
      {
         var uidoc = commandData.Application.ActiveUIDocument;
         var doc = uidoc.Document;
         var sel = uidoc.Selection;
         using (Transaction transaction = new Transaction(doc, "ToposolidMaxBooleanStbilityFactor"))
         {
            transaction.Start();
            try
            {
               Autodesk.Revit.DB.Toposolid.SetCutVoidStability(doc, false);
            }
            catch(Autodesk.Revit.Exceptions.ArgumentOutOfRangeException ex)
            {
               ex.ToString();
            }


            Autodesk.Revit.DB.Toposolid.SetCutVoidStability(doc, false);
            bool isEnable = Autodesk.Revit.DB.Toposolid.IsCutVoidStabilityEnabled(doc);
            if (!isEnable)
            {
               transaction.RollBack();
               return Result.Failed;
            }   

            transaction.Commit();
         }

         return Result.Succeeded;
      }
   }

   /// <summary>
   /// ImportInstanceFilter
   /// </summary>
   public class ImportInstanceFilter : ISelectionFilter
   {
      /// <summary>
      /// Interface implementation
      /// </summary>
      /// <param name="elem"></param>
      /// <returns></returns>
      public bool AllowElement(Element elem)
      {
         return elem is ImportInstance;
      }

      /// <summary>
      /// Interface implementation
      /// </summary>
      /// <param name="reference"></param>
      /// <param name="position"></param>
      /// <returns></returns>
      public bool AllowReference(Reference reference, XYZ position)
      {
         return false;
      }
   }


   /// <summary>
   /// TopographySurfaceFilter
   /// </summary>
   public class TopographySurfaceFilter : ISelectionFilter
   {
      /// <summary>
      /// Interface implementation
      /// </summary>
      /// <param name="elem"></param>
      /// <returns></returns>
      public bool AllowElement(Element elem)
      {
         return elem is TopographySurface;
      }

      /// <summary>
      /// Interface implementation
      /// </summary>
      /// <param name="reference"></param>
      /// <param name="position"></param>
      /// <returns></returns>
      public bool AllowReference(Reference reference, XYZ position)
      {
         return false;
      }
   }

   /// <summary>
   /// ModelCurveFilter
   /// </summary>
   public class ModelCurveFilter : ISelectionFilter
   {
      /// <summary>
      /// Interface implementation
      /// </summary>
      /// <param name="elem"></param>
      /// <returns></returns>
      public bool AllowElement(Element elem)
      {
         return elem is ModelCurve;
      }

      /// <summary>
      /// Interface implementation
      /// </summary>
      /// <param name="reference"></param>
      /// <param name="position"></param>
      /// <returns></returns>
      public bool AllowReference(Reference reference, XYZ position)
      {
         return false;
      }
   }

   /// <summary>
   /// ToposolidFilter
   /// </summary>
   public class ToposolidFilter : ISelectionFilter
   {
      /// <summary>
      /// Interface implementation
      /// </summary>
      /// <param name="elem"></param>
      /// <returns></returns>
      public bool AllowElement(Element elem)
      {
         return elem is Autodesk.Revit.DB.Toposolid;
      }

      /// <summary>
      /// Interface implementation
      /// </summary>
      /// <param name="reference"></param>
      /// <param name="position"></param>
      /// <returns></returns>
      public bool AllowReference(Reference reference, XYZ position)
      {
         return false;
      }
   }
}

=== CODE_BLOCK_0169 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
        ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            try
            {
                // process data from Revit and show dialog
                using (TransactionForm transactionFrm = new TransactionForm(commandData))
                {
                    if (transactionFrm.ShowDialog() == DialogResult.OK)
                    {
                        return Autodesk.Revit.UI.Result.Succeeded;
                    }
                }
            }
            catch (Exception ex)
            {
                message = ex.Message;
                return Autodesk.Revit.UI.Result.Failed;
            }
            return Autodesk.Revit.UI.Result.Cancelled;
        }
    }
}

=== CODE_BLOCK_0171 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
            ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            TrussForm trussForm = new TrussForm(commandData);
            // The form is created successfully
            if (null != trussForm && false == trussForm.IsDisposed)
            {
                trussForm.ShowDialog();
            }

            return Autodesk.Revit.UI.Result.Succeeded;
        }

        #endregion
    }
}

=== CODE_BLOCK_0173 ===
public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,
        ref string message, Autodesk.Revit.DB.ElementSet elements)
        {
            Autodesk.Revit.DB.Transaction newTran = null;
            try
            {
                newTran = new Autodesk.Revit.DB.Transaction(commandData.Application.ActiveUIDocument.Document, "ViewPrinter");
                newTran.Start();

                PrintMgr pMgr = new PrintMgr(commandData);

                if (null == pMgr.InstalledPrinterNames)
                {
                    PrintMgr.MyMessageBox("No installed printer, the external command can't work.");
                    return Autodesk.Revit.UI.Result.Cancelled;
                }

                using (PrintMgrForm pmDlg = new PrintMgrForm(pMgr))
                {
                    if (pmDlg.ShowDialog() != DialogResult.Cancel)
                    {
                        newTran.Commit();
                        return Autodesk.Revit.UI.Result.Succeeded;
                    }
                    newTran.RollBack();
                }

            }
            catch (Exception ex)
            {
                if (null != newTran)
                    newTran.RollBack();
                message = ex.ToString();
                return Autodesk.Revit.UI.Result.Failed;
            }

            return Autodesk.Revit.UI.Result.Cancelled;
        }

    }
}

