[
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\AllViews\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n         ref string message, Autodesk.Revit.DB.ElementSet elements)\n       {\n           if (null == commandData)\n           {\n               throw new ArgumentNullException(\"commandData\");\n           }\n\n           Document doc = commandData.Application.ActiveUIDocument.Document;\n           ViewsMgr view = new ViewsMgr(doc);\n\n           AllViewsForm dlg = new AllViewsForm(view);\n\n           try\n           {\n               if (dlg.ShowDialog() == DialogResult.OK)\n               {\n                   return view.GenerateSheet(doc);\n               }\n           }\n           catch (Exception e)\n           {\n               message = e.Message;\n               return Autodesk.Revit.UI.Result.Failed;\n           }\n\n           return Autodesk.Revit.UI.Result.Succeeded;\n      }\n\n      #endregion IExternalCommand Members Implementation\n      }\n\n    /// <summary>\n    /// Generating a new sheet that has all the selected views placed in.\n    /// Updating and retrieving properties of a selected viewport.\n    /// </summary>\n    public class ViewsMgr : IDisposable\n    {\n      private TreeNode m_allViewsNames = new TreeNode(\"Views (all)\");\n      private ViewSet m_allViews = new ViewSet();\n      private ViewSet m_selectedViews = new ViewSet();\n      private FamilySymbol m_titleBlock;\n      private IList<Element> m_allTitleBlocks = new List<Element>();\n      private ArrayList m_allTitleBlocksNames = new ArrayList();\n      private string m_sheetName;\n      private double m_rows;\n\n      private double TITLEBAR = 0.2;\n      private double GOLDENSECTION = 0.618;\n\n      private Document m_doc;\n\n      private Viewport m_VP;\n\n      /// <summary>\n      /// Update Form data members bonded to UI controls.\n      /// </summary>\n      /// <param name=\"form\">The Form to be updated.</param>\n      public void UpdateViewportProperties(AllViewsForm form)\n      {\n         form.m_getMinBoxOutline = m_VP.GetBoxOutline().MinimumPoint;\n         form.m_getMaxBoxOutline = m_VP.GetBoxOutline().MaximumPoint;\n\n         form.m_getMinLabelOutline = m_VP.GetLabelOutline().MinimumPoint;\n         form.m_getMaxLabelOutline = m_VP.GetLabelOutline().MaximumPoint;\n\n         form.m_getLabelLineOffset = m_VP.LabelOffset;\n         form.m_getLabelLineLength = m_VP.LabelLineLength;\n\n         form.m_getBoxCenter = m_VP.GetBoxCenter();\n         form.m_getOrientation = m_VP.Rotation;\n      }\n\n      /// <summary>\n      /// Select a viewport by its associated view name and sheet name.\n      /// </summary>\n      /// <param name=\"form\">The Form to be updated.</param>\n      /// <param name=\"selectSheetName\"> Sheet name.</param>\n      /// <param name=\"selectAssociatedViewName\">Associated view name.</param>\n      public bool SelectViewport(AllViewsForm form, string selectSheetName, string selectAssociatedViewName)\n      {\n         m_VP = null;\n         form.invalidViewport = true;\n\n         FilteredElementCollector fec = new FilteredElementCollector(m_doc);\n         fec.OfClass(typeof(Autodesk.Revit.DB.View));\n         var viewSheets = fec.Cast<Autodesk.Revit.DB.View>().Where<Autodesk.Revit.DB.View>(vp => !vp.IsTemplate && vp.ViewType == ViewType.DrawingSheet);\n\n         foreach (var view in viewSheets)\n         {\n            if (view.Name.Equals(selectSheetName))\n            {\n               ViewSheet viewSheet = (ViewSheet)view;\n               foreach (var vp in viewSheet.GetAllViewports())\n               {\n                  Viewport VP = (Viewport)(m_doc.GetElement(vp));\n\n                  Autodesk.Revit.DB.View associatedView = m_doc.GetElement(VP.ViewId) as Autodesk.Revit.DB.View;\n\n                  if (associatedView.Name.Equals(selectAssociatedViewName))\n                  {\n                     m_VP = VP;\n                     break;\n                  }\n               }\n            }\n         }\n\n         if (m_VP == null)\n         {\n            throw new InvalidOperationException(\"Viewport not found.\");\n         }\n\n         form.invalidViewport = false;\n         UpdateViewportProperties(form);\n         return true;\n      }\n\n      /// <summary>\n      /// Change viewport label offset.\n      /// </summary>\n      /// <param name=\"form\">The Form to be updated.</param>\n      /// <param name=\"labelOffsetX\">Label offset X component.</param>\n      /// <param name=\"labelOffsetY\">Label offset Y component.</param>\n      public void SetLabelOffset(AllViewsForm form,\n         double labelOffsetX, double labelOffsetY)\n      {\n         using (Transaction t = new Transaction(m_doc, \"Change label offset\"))\n         {\n            t.Start();\n\n            m_VP.LabelOffset = new XYZ(labelOffsetX, labelOffsetY, 0.0);\n\n            t.Commit();\n\n            UpdateViewportProperties(form);\n         }\n      }\n\n      /// <summary>\n      /// Change viewport label length.\n      /// </summary>\n      /// <param name=\"form\">The Form to be updated.</param>\n      /// <param name=\"labelLineLength\">Label line length.</param>\n      public void SetLabelLength(AllViewsForm form, double labelLineLength)\n      {\n         using (Transaction t = new Transaction(m_doc, \"Change label length\"))\n         {\n            t.Start();\n\n            m_VP.LabelLineLength = labelLineLength;\n\n            t.Commit();\n\n            UpdateViewportProperties(form);\n         }\n      }\n\n      /// <summary>\n      /// Change viewport orientation.\n      /// </summary>\n      /// <param name=\"form\">The Form to be updated.</param>\n      /// <param name=\"rotation\">Label line rotation.</param>\n      public void SetRotation(AllViewsForm form, ViewportRotation rotation)\n      {\n         using (Transaction t = new Transaction(m_doc, \"Change label orientation\"))\n         {\n            t.Start();\n\n            m_VP.Rotation = rotation;\n\n            t.Commit();\n\n            UpdateViewportProperties(form);\n         }\n      }\n\n        /// <summary>\n        /// Tree node store all views' names.\n        /// </summary>\n        public TreeNode AllViewsNames\n        {\n            get\n            {\n                return m_allViewsNames;\n            }\n        }\n\n        /// <summary>\n        /// List of all title blocks' names.\n        /// </summary>\n        public ArrayList AllTitleBlocksNames\n        {\n            get\n            {\n                return m_allTitleBlocksNames;\n            }\n        }\n\n        /// <summary>\n        /// The selected sheet's name.\n        /// </summary>\n        public string SheetName\n        {\n            get\n            {\n                return m_sheetName;\n            }\n            set\n            {\n                m_sheetName = value;\n            }\n        }\n\n        /// <summary>\n        /// Constructor of views object.\n        /// </summary>\n        /// <param name=\"doc\">the active document</param>\n        public ViewsMgr(Document doc)\n        {\n            m_doc = doc;\n            GetAllViews(doc);\n            GetTitleBlocks(doc);\n        }\n\n        /// <summary>\n        /// Finds all the views in the active document.\n        /// </summary>\n        /// <param name=\"doc\">the active document</param>\n        private void GetAllViews(Document doc)\n        {\n            FilteredElementCollector collector = new FilteredElementCollector(doc);\n            FilteredElementIterator itor = collector.OfClass(typeof(Autodesk.Revit.DB.View)).GetElementIterator();\n            itor.Reset();\n            while (itor.MoveNext())\n            {\n                Autodesk.Revit.DB.View view = itor.Current as Autodesk.Revit.DB.View;\n                // skip view templates because they're invisible in project browser\n                if (null == view || view.IsTemplate)\n                {\n                    continue;\n                }\n                else\n                {\n                    ElementType objType = doc.GetElement(view.GetTypeId()) as ElementType;\n                    if (null == objType || objType.Name.Equals(\"Schedule\")\n                        || objType.Name.Equals(\"Drawing Sheet\"))\n                    {\n                        continue;\n                    }\n                    else\n                    {\n                        m_allViews.Insert(view);\n                        AssortViews(view.Name, objType.Name);\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Assort all views for tree view displaying.\n        /// </summary>\n        /// <param name=\"view\">The view assorting</param>\n        /// <param name=\"type\">The type of view</param>\n        private void AssortViews(string view, string type)\n        {\n            foreach (TreeNode t in AllViewsNames.Nodes)\n            {\n                if (t.Tag.Equals(type))\n                {\n                    t.Nodes.Add(new TreeNode(view));\n                    return;\n                }\n            }\n\n            TreeNode categoryNode = new TreeNode(type);\n            categoryNode.Tag = type;\n            if (type.Equals(\"Building Elevation\"))\n            {\n                categoryNode.Text = \"Elevations [\" + type + \"]\";\n            }\n            else\n            {\n                categoryNode.Text = type + \"s\";\n            }\n            categoryNode.Nodes.Add(new TreeNode(view));\n            AllViewsNames.Nodes.Add(categoryNode);\n        }\n\n        /// <summary>\n        /// Retrieve the checked view from tree view.\n        /// </summary>\n        public void SelectViews()\n        {\n            ArrayList names = new ArrayList();\n            foreach (TreeNode t in AllViewsNames.Nodes)\n            {\n                foreach (TreeNode n in t.Nodes)\n                {\n                    if (n.Checked && 0 == n.Nodes.Count)\n                    {\n                        names.Add(n.Text);\n                    }\n                }\n            }\n\n            foreach (Autodesk.Revit.DB.View v in m_allViews)\n            {\n                foreach (string s in names)\n                {\n                    if (s.Equals(v.Name))\n                    {\n                        m_selectedViews.Insert(v);\n                        break;\n                    }\n                }\n            }\n        }\n\n      /// <summary>\n      /// Generate sheet in active document.\n      /// </summary>\n      /// <param name=\"doc\">the currently active document</param>\n      public Autodesk.Revit.UI.Result GenerateSheet(Document doc)\n      {\n         if (null == doc)\n         {\n                throw new ArgumentNullException(\"doc\");\n         }\n\n         if (m_selectedViews.IsEmpty)\n         {\n                throw new InvalidOperationException(\"No view be selected, generate sheet be canceled.\");\n         }\n\n         Result result = Result.Succeeded;\n\n         using (Transaction newTran = new Transaction(doc, \"AllViews_Sample\"))\n         {\n            newTran.Start();\n\n            try\n            {\n                  ViewSheet sheet = ViewSheet.Create(doc, m_titleBlock.Id);\n                  sheet.Name = SheetName;\n                  PlaceViews(m_selectedViews, sheet);\n            }\n            catch(Exception)\n            {\n                  result = Result.Failed;\n            }\n\n            if (result == Result.Succeeded)\n            {\n                  newTran.Commit();\n            }\n            else\n            {\n                  newTran.RollBack();\n                  throw new InvalidOperationException(\"Failed to generate sheet view and/or its viewports.\");\n            }\n         }\n\n         return result;\n      }\n\n        /// <summary>\n        /// Retrieve the title block to be generate by its name.\n        /// </summary>\n        /// <param name=\"name\">The title block's name</param>\n        public void ChooseTitleBlock(string name)\n        {\n            if (string.IsNullOrEmpty(name))\n            {\n                throw new ArgumentNullException(\"name\");\n            }\n\n            foreach (FamilySymbol f in m_allTitleBlocks)\n            {\n               if (name.Equals(f.Family.Name + \":\" + f.Name))\n               {\n                  m_titleBlock = f;\n                  return;\n               }\n            }\n        }\n\n        /// <summary>\n        /// Retrieve all available title blocks in the currently active document.\n        /// </summary>\n        /// <param name=\"doc\">the currently active document</param>\n        private void GetTitleBlocks(Document doc)\n        {\n            FilteredElementCollector filteredElementCollector = new FilteredElementCollector(doc);\n            filteredElementCollector.OfClass(typeof(FamilySymbol));\n            filteredElementCollector.OfCategory(BuiltInCategory.OST_TitleBlocks);\n            m_allTitleBlocks = filteredElementCollector.ToElements();\n            if (0 == m_allTitleBlocks.Count)\n            {\n                throw new InvalidOperationException(\"There is no title block to generate sheet.\");\n            }\n\n            foreach (Element element in m_allTitleBlocks)\n            {\n                FamilySymbol f = element as FamilySymbol;\n                AllTitleBlocksNames.Add(f.Family.Name + \":\" + f.Name);\n                if (null == m_titleBlock)\n                {\n                   m_titleBlock = f;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Place all selected views on this sheet's appropriate location.\n        /// </summary>\n        /// <param name=\"views\">all selected views</param>\n        /// <param name=\"sheet\">all views located sheet</param>\n        private void PlaceViews(ViewSet views, ViewSheet sheet)\n        {\n            double xDistance = 0;\n            double yDistance = 0;\n            CalculateDistance(sheet.Outline, views.Size, ref xDistance, ref yDistance);\n\n            Autodesk.Revit.DB.UV origin = GetOffSet(sheet.Outline, xDistance, yDistance);\n            //Autodesk.Revit.DB.UV temp = new Autodesk.Revit.DB.UV (origin.U, origin.V);\n            double tempU = origin.U;\n            double tempV = origin.V;\n            int n = 1;\n            foreach (Autodesk.Revit.DB.View v in views)\n            {\n                Autodesk.Revit.DB.UV location = new Autodesk.Revit.DB.UV(tempU, tempV);\n                Autodesk.Revit.DB.View view = v;\n                Rescale(view, xDistance, yDistance);\n                try\n                {\n                    //sheet.AddView(view, location);\n                    Viewport.Create(view.Document, sheet.Id, view.Id, new XYZ(location.U, location.V, 0));\n                }\n                catch (ArgumentException /*ae*/)\n                {\n                    throw new InvalidOperationException(\"The view '\" + view.Name +\n                        \"' can't be added, it may have already been placed in another sheet.\");\n                }\n\n                if (0 != n++ % m_rows)\n                {\n                    tempU = tempU + xDistance * (1 - TITLEBAR);\n                }\n                else\n                {\n                    tempU = origin.U;\n                    tempV = tempV + yDistance;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Retrieve the appropriate origin.\n        /// </summary>\n        /// <param name=\"bBox\"></param>\n        /// <param name=\"x\"></param>\n        /// <param name=\"y\"></param>\n        /// <returns></returns>\n        private Autodesk.Revit.DB.UV GetOffSet(BoundingBoxUV bBox, double x, double y)\n        {\n            return new Autodesk.Revit.DB.UV(bBox.Min.U + x * GOLDENSECTION, bBox.Min.V + y * GOLDENSECTION);\n        }\n\n        /// <summary>\n        /// Calculate the appropriate distance between the views lay on the sheet.\n        /// </summary>\n        /// <param name=\"bBox\">The outline of sheet.</param>\n        /// <param name=\"amount\">Amount of views.</param>\n        /// <param name=\"x\">Distance in x axis between each view</param>\n        /// <param name=\"y\">Distance in y axis between each view</param>\n        private void CalculateDistance(BoundingBoxUV bBox, int amount, ref double x, ref double y)\n        {\n            double xLength = (bBox.Max.U - bBox.Min.U) * (1 - TITLEBAR);\n            double yLength = (bBox.Max.V - bBox.Min.V);\n\n            //calculate appropriate rows numbers.\n            double result = Math.Sqrt(amount);\n\n            while (0 < (result - (int)result))\n            {\n                amount = amount + 1;\n                result = Math.Sqrt(amount);\n            }\n            m_rows = result;\n            double area = xLength * yLength / amount;\n\n            //calculate appropriate distance between the views.\n            if (bBox.Max.U > bBox.Max.V)\n            {\n                x = Math.Sqrt(area / GOLDENSECTION);\n                y = GOLDENSECTION * x;\n            }\n            else\n            {\n                y = Math.Sqrt(area / GOLDENSECTION);\n                x = GOLDENSECTION * y;\n            }\n        }\n\n        /// <summary>\n        /// Rescale the view's Scale value for suitable.\n        /// </summary>\n        /// <param name=\"view\">The view to be located on sheet.</param>\n        /// <param name=\"x\">Distance in x axis between each view</param>\n        /// <param name=\"y\">Distance in y axis between each view</param>\n        static private void Rescale(Autodesk.Revit.DB.View view, double x, double y)\n        {\n            double Rescale = 2;\n            Autodesk.Revit.DB.UV outline = new Autodesk.Revit.DB.UV(view.Outline.Max.U - view.Outline.Min.U,\n                view.Outline.Max.V - view.Outline.Min.V);\n\n            if (outline.U > outline.V)\n            {\n                Rescale = outline.U / x * Rescale;\n            }\n            else\n            {\n                Rescale = outline.V / y * Rescale;\n            }\n\n            if (1 != view.Scale && 0 != Rescale)\n            {\n                view.Scale = (int)(view.Scale * Rescale);\n            }\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n                m_allViews.Dispose();\n                m_selectedViews.Dispose();\n            }\n\n            // TODO: free unmanaged resources (unmanaged objects) and override finalizer\n            // TODO: set large fields to null\n        }\n\n        public void Dispose()\n        {\n            // Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method\n            Dispose(disposing: true);\n            GC.SuppressFinalize(this);\n        }\n   }\n}"
    },
    "documentation": {
      "ReadMe_AllViews.rtf": "Summary: This sample demonstrates how to generate a new sheet that includes all the selected views. It also demonstrates how to access the properties of a viewport such as LabelLineOffset, LabelLength and Orientation. \n\nClasses: \nAutodesk.Revit.DB.View\nAutodesk.Revit.DB.ViewSet\nAutodesk.Revit.Creation.Document.NewViewSheet\n\nProject Files:\nAllViews.cs\nIt contains two classes:\n-\tThe class Command which implements interface IExternalCommand, it is the entry of this external command.\n-\tThe class ViewsMgr is responsible for generating a new sheet that has all the selected views placed and for getting and setting properties of a selected view.\n\nAllViewsForm.cs\nIt contains the class AllViewsForm which is a dialog. This dialog is a twofold-based UI: “Create new Sheet and Viewports” and “Viewport Properties”.\nFollowing are the contents for the “Create new Sheet and Viewports” part:\n-\tA tree view represents all the views which can be placed in sheet.\n-\tA list of all title blocks that users can select one to create sheet.\n-\tA text box for users to input the name of the sheet to be created.\nFollowing are the contents for the “Viewport Properties” part:\nA “Select Viewport” Group Box to select a viewport based on its sheet name and its associated view name. This applies to any viewport even if it was not created by “Generate Sheet” OK button.\nA set of Group Boxes (Rotation, Label Offset and Label Line Length) to set corresponding properties of the selected viewport.\nA set of Group Boxes to show the actual properties of the selected viewport.\n\nDescription: This sample demonstrates the following functionalities:\n-\tFinds all the views and title blocks in the current project and display the names in a tree view. The user can select several views. When OK button is clicked, a new sheet is generated that has all the selected views placed in.\n-\tThe most important class is ViewsMgr. It shows how to get all views from document, and how to generate a new sheet via RevitAPI. It shows also how to access and set a viewport properties.\n\nInstructions:\nUse case “Create new Sheet and Viewports”:\nRun this external command.\nSelect the title block for the sheet being generated.\nSelect views you want to place in the new sheet.\nClick OK button to generate new sheet.\n\nUse case “Viewport Properties”:\nRun this external command.\nIdentify and select a viewport using the name of the sheet it is contained in and its associated view name.\nAll its properties will be updated in the UI.\nChange its rotation, label offset or label line length using the corresponding Controls and Apply buttons.\nThe changes will be applied in the document and all the viewport properties will be updated in the UI.\n\nMixed Use case:\nCreate a sheet and its viewports (use case A)\nUpdate and get properties of a selected viewport (use case B)"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\AnalysisVisualizationFramework\\MultithreadedCalculation\\CS",
    "key_code": {
      "class_name": "MultithreadedCalculation",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)\n        {\n            UIApplication uiApp = commandData.Application;\n            UIDocument uiDoc = uiApp.ActiveUIDocument;\n            Document doc = uiDoc.Document;\n            s_docName = doc.PathName;\n\n            Element element = null;\n            try\n            {\n                element = doc.GetElement(uiDoc.Selection.PickObject(ObjectType.Element, \"Select an element for the AVF demonstration.\"));\n            }\n            catch (System.Exception)\n            {\n                message = \"User aborted the tool.\";\n                return Result.Cancelled;\n            }\n            \n            // Set up SpatialFieldManager to hold results\n            s_activeViewId = doc.ActiveView.Id; \n            SpatialFieldManager oldSfm = null; \n            View oldView = null;\n            if (s_oldViewId != null) oldView = doc.GetElement(s_oldViewId) as View;\n            if (oldView != null) oldSfm = SpatialFieldManager.GetSpatialFieldManager(oldView);\n            // If a previous SFM was being managed, delete it\n            if (oldSfm != null) oldSfm.RemoveSpatialFieldPrimitive(s_oldSpatialFieldId);\n\n            // Setup container object for executing the calculation\n            MultithreadedCalculationContainer container = CreateContainer(element);\n\n            // Register updater to watch for geometry changes\n            SpatialFieldUpdater updater = new SpatialFieldUpdater(container,uiApp.ActiveAddInId);\n            if (!UpdaterRegistry.IsUpdaterRegistered(updater.GetUpdaterId())) \n                UpdaterRegistry.RegisterUpdater(updater, doc);\n            IList<ElementId> idCollection = new List<ElementId>();\n            idCollection.Add(element.Id);\n            UpdaterRegistry.RemoveAllTriggers(s_updaterId);\n            UpdaterRegistry.AddTrigger(updater.GetUpdaterId(), doc, idCollection, Element.GetChangeTypeGeometry());\n\n            // Register idling event\n            uiApp.Idling += new EventHandler<IdlingEventArgs>(container.UpdateWhileIdling);\n\n            // Start new thread\n            Thread thread = new Thread(new ThreadStart(container.Run));\n            thread.Start();\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        /// <summary>\n        /// Prepares a container object that carries out the calculations without invoking Revit API calls.\n        /// </summary>\n        /// <param name=\"element\">The element for the calculations.</param>\n        /// <returns>The container.</returns>\n        public static MultithreadedCalculationContainer CreateContainer(Element element)\n        {\n            Document doc = element.Document;\n            View activeView = doc.GetElement(s_activeViewId) as View;\n\n            // Figure out which is the largest face facing the user\n            XYZ viewDirection = activeView.ViewDirection.Normalize();   \n            Face biggestFace = GetBiggestFaceFacingUser(element, viewDirection);\n                 \n            // Get or create SpatialFieldManager for AVF results\n            SpatialFieldManager sfm = SpatialFieldManager.GetSpatialFieldManager(activeView);\n            if (sfm == null) sfm = SpatialFieldManager.CreateSpatialFieldManager(activeView, 1);\n\n            // Reference the target face\n            s_spatialFieldId = sfm.AddSpatialFieldPrimitive(biggestFace.Reference);\n\n            // Compute the range of U and V for the calculation\n            BoundingBoxUV bbox = biggestFace.GetBoundingBox();\n\n            return new MultithreadedCalculationContainer(doc.PathName, bbox.Min, bbox.Max);\n       }\n\n        /// <summary>\n        /// Gets the biggest face which faces the user.  Assumes that the element is a wall, or floor, or other \"2-sided\" element, and that\n        /// one of the two biggest faces will be facing roughly towards the viewer.\n        /// </summary>\n        /// <param name=\"element\">The element.</param>\n        /// <param name=\"viewDirection\">The view direction.</param>\n        /// <returns>The face.  Face.Reference will also be populated.</returns>\n        private static Face GetBiggestFaceFacingUser(Element element, XYZ viewDirection)\n        {\n            \n            // Holds the faces sorted by area\n            SortedDictionary<double, List<Face>> faceAreas = new SortedDictionary<double, List<Face>>();\n\n            // Get the element geometry\n            Options options = new Options();\n            options.ComputeReferences = true;\n            GeometryElement geomElem = element.get_Geometry(options);\n            \n            // Look at the faces in each solid\n            foreach (GeometryObject geomObj in geomElem)\n            {\n                Solid solid = geomObj as Solid;\n                if (solid != null)\n                {\n                    foreach (Face face in solid.Faces)\n                    {\n                        double area = face.Area;\n                        // Save the face to the collection\n                        if (faceAreas.ContainsKey(area))\n                        {\n                            faceAreas[area].Add(face);\n                        }\n                        else\n                        {\n                            List<Face> faces = new List<Face>();\n                            faces.Add(face);\n                            faceAreas.Add(area, faces);\n                        }\n                    }\n                }\n            }\n\n            // Get biggest two faces.  There might be two faces in the last item, or one face in the last item.\n            int count = faceAreas.Count;\n            KeyValuePair<double, List<Face>> faceCollection1 = faceAreas.ElementAt<KeyValuePair<double, List<Face>>>(count - 1);\n            KeyValuePair<double, List<Face>> faceCollection2 = faceAreas.ElementAt<KeyValuePair<double, List<Face>>>(count - 2);\n\n            Face face1 = null;\n            Face face2 = null;\n            // Two or more equal faces.  Use the first two.\n            if (faceCollection1.Value.Count > 1)\n            {\n                face1 = faceCollection1.Value[0];\n                face2 = faceCollection1.Value[1];\n            }\n            // One largest face.  Use the first face from the next item for comparison.\n            else\n            {\n                face1 = faceCollection1.Value[0];\n                face2 = faceCollection2.Value[0];\n            }\n\n            // Compute face normal\n            BoundingBoxUV box = face1.GetBoundingBox();\n            UV faceCenter = (box.Max + box.Min) / 2;\n            XYZ faceNormal = face1.ComputeNormal(faceCenter).Normalize();\n\n            // Compute angle to the view direction.  If less than 90 degrees, keep this face.\n            double angle = viewDirection.AngleTo(faceNormal);\n\n            Face biggestFace = null;\n            if (Math.Abs(angle) < Math.PI / 2)\n                biggestFace = face1;\n            else\n                biggestFace = face2;\n\n            return biggestFace;\n        }\n\n        /// <summary>\n        /// Updater called when wall geometry changes, so analysis results can update.\n        /// </summary>\n        public class SpatialFieldUpdater : IUpdater\n        {\n            // The old container object.\n            MultithreadedCalculationContainer containerOld;\n\n            public SpatialFieldUpdater(MultithreadedCalculationContainer _container, AddInId addinId)\n            {\n                containerOld = _container;\n                s_updaterId = new UpdaterId(addinId, new Guid(\"FBF2F6B2-4C06-42d4-97C1-D1B4EB593EFF\"));\n            }\n\n            // Execution method for the updater\n            public void Execute(UpdaterData data)\n            {\n                // Remove old idling event callback\n                UIApplication uiApp = new UIApplication(data.GetDocument().Application);\n                uiApp.Idling -= containerOld.UpdateWhileIdling;\n                containerOld.Stop();\n\n                // Clear the current AVF results\n                Document doc = data.GetDocument();\n                View activeView = doc.GetElement(s_activeViewId) as View;\n                SpatialFieldManager sfm = SpatialFieldManager.GetSpatialFieldManager(activeView);\n                sfm.Clear();\n\n                // Restart the multithread calculation with a new container\n                Element modifiedElem = doc.GetElement(data.GetModifiedElementIds().First<ElementId>());\n                MultithreadedCalculationContainer container = MultithreadedCalculation.CreateContainer(modifiedElem);\n                containerOld = container;\n\n                // Setup the new idling callback\n                uiApp.Idling += new EventHandler<IdlingEventArgs>(container.UpdateWhileIdling);\n\n                // Start the thread\n                Thread threadNew = new Thread(new ThreadStart(container.Run));\n                threadNew.Start();\n            }\n\n            public string GetAdditionalInformation() { return \"AVF DMU Thread sample\"; }\n            public ChangePriority GetChangePriority() { return ChangePriority.FloorsRoofsStructuralWalls; }\n            public UpdaterId GetUpdaterId() { return s_updaterId; }\n            public string GetUpdaterName() { return \"AVF DMU Thread\"; }\n        }\n\n        /// <summary>\n        /// Container class that manages the multithreaded calculation and idling activity.\n        /// </summary>\n        public class MultithreadedCalculationContainer\n        {\n            private volatile bool m_stop = false;\n            UV m_min;\n            UV m_max;\n            \n            string m_docName;\n            IList<ResultsData> results = new List<ResultsData>();\n            IList<UV> m_uvToCalculate = new List<UV>();\n            int m_uvToCalculateCount;\n            IList<UV> uvPts = new List<UV>();\n            IList<ValueAtPoint> valList = new List<ValueAtPoint>();\n\n            public MultithreadedCalculationContainer(string _docName, UV _min, UV _max)\n            {\n                m_docName = _docName;\n                m_min = _min;\n                m_max = _max;\n            }\n\n            public void Run()\n            {\n                m_uvToCalculate = DetermineFacePoints();\n                m_uvToCalculateCount = m_uvToCalculate.Count;\n                Calculate();\n            }\n\n            /// <summary>\n            /// Stops the thread/calculation and application via idling.\n            /// </summary>\n            public void Stop()\n            {\n                m_stop = true;\n            }\n\n\n            /// <summary>\n            /// The idling callback which adds data to the AVF results.\n            /// </summary>\n            /// <param name=\"sender\"></param>\n            /// <param name=\"e\"></param>\n            public void UpdateWhileIdling(object sender, IdlingEventArgs e)\n            {\n                UIApplication uiApp = sender as UIApplication;\n\n                // Get SpatialFieldManager\n\n                AnalysisResultSchema resultSchema = new AnalysisResultSchema(\"Schema Name\", \"Description\");\n                SpatialFieldManager sfm = SpatialFieldManager.GetSpatialFieldManager(uiApp.ActiveUIDocument.Document.ActiveView);\n                \n                if (sfm == null) sfm = SpatialFieldManager.CreateSpatialFieldManager(uiApp.ActiveUIDocument.Document.ActiveView, 1);\n                int schemaIndex = sfm.RegisterResult(resultSchema);\n                // If stopping, clear results and unset event.\n                if (m_stop)\n                {\n                    lock (results)\n                    {\n                        results.Clear();\n                    }\n                    uiApp.Idling -= UpdateWhileIdling;\n                    return;\n                }\n\n                // If document was closed and new document opened, do not run the update.\n                if (uiApp.ActiveUIDocument.Document.PathName == m_docName) \n                {\n                    // Lock access to current calculated results\n                    lock (results)\n                    {\n                        if (results.Count == 0) return;\n\n                        // Turn each result to an AVF ValueAtPoint\n                        foreach (ResultsData rData in results)\n                        {\n                            uvPts.Add(new UV(rData.UV.U, rData.UV.V));\n                            IList<double> doubleList = new List<double>();\n                            doubleList.Add(rData.Value);\n                            valList.Add(new ValueAtPoint(doubleList));\n                        }\n                        FieldDomainPointsByUV pntsByUV = new FieldDomainPointsByUV(uvPts);\n                        FieldValues fieldValues = new FieldValues(valList);\n\n                        // Update with calculated values\n                        Transaction t = new Transaction(uiApp.ActiveUIDocument.Document);\n                        t.SetName(\"AVF\");\n                        t.Start();\n                        if (!m_stop)\n                            sfm.UpdateSpatialFieldPrimitive(s_spatialFieldId, pntsByUV, fieldValues, schemaIndex);\n                        t.Commit();  \n\n                        // Clear results already processed.\n                        results.Clear();\n\n                        // If no more results to process, remove the idling event\n                        if (m_uvToCalculateCount == 0)\n                        {\n                            uiApp.Idling -= UpdateWhileIdling;\n                            s_oldViewId = s_activeViewId;\n                            s_oldSpatialFieldId = s_spatialFieldId;\n                        }\n                    }\n                }\n            }\n\n            // Calculate the results in a loop \n            void Calculate()\n            {\n                foreach (UV uv in m_uvToCalculate)\n                {\n                    if (m_stop)\n                    {\n                        m_uvToCalculateCount = 0;\n                        return;\n                    }\n                    // Lock access to results while the data is added\n                    lock (results)\n                    {\n                        results.Add(new ResultsData(uv, 1000 * Math.Sin(Math.Abs(uv.U * uv.V))));\n                        Thread.Sleep(500); // to simulate the effect of a complex computation\n                        m_uvToCalculateCount--;\n                    }\n                }\n            }\n\n            private const int numberOfUPnts = 10;\n            private const int numberOfVPnts = 5;\n\n            // Setup the list of UV points to calculate results for\n            IList<UV> DetermineFacePoints()\n            {\n                IList<UV> uvList = new List<UV>();\n                double upnt = m_min.U;\n                double incrementU = (m_max.U - m_min.U) / (numberOfUPnts - 1);\n                double incrementV = (m_max.V - m_min.V) / (numberOfVPnts - 1);\n                while (upnt <= m_max.U)\n                {\n                    double vpnt = m_min.V;\n                    while (vpnt <= m_max.V)\n                    {\n                        uvList.Add(new UV(upnt,vpnt));\n                        vpnt = vpnt + incrementV;\n                    }\n                    upnt = upnt + incrementU;\n                }\n                return uvList;\n            }\n        }\n\n        // Represents a set of results for the calculation\n        public class ResultsData\n        {\n            public UV UV;\n            public double Value;\n            public ResultsData(UV uv, double value)\n            {\n                this.UV = uv;\n                Value = value;\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_MultithreadedCalculation.rtf": "Description: Prompt the user to select an element with Selection.PickObject\nFind the largest face of the element\nGet the active view’s SpatialFieldManager, or create a SpatialFieldManager if the active view does not have one.\nAdd the reference of the element’s largest face to the SpatialFieldManager.\nFind the minimum and maximum UV of the face’s bounding box\nThe myUV class is used because it can be safely passed to the external thread. myUV contains two double values. Native Revit classes (such as Autodesk.Revit.DB.UV) cannot be given to the thread.\nCreate and register an IUpdater (SpatialFieldUpdater) so that the command will be able to respond when the element selected in step 1 is changed or deleted.\nRegister an Idling event. Revit will use this event to alert the command that Revit is ready to receive and display additional results data.\nStart a new thread that will be used to compute and display the results\nPopulate an IList of myUV elements describing the locations on the surface where results will be calculated\nCompute results\nResults are stored by adding instances of the resultData class to the “results” IList. Each resultData instance contains a myUV and double value.\nThe results list is locked when it is being modified, to prevent it from being modified by multiple threads at the same time.\nFor the sake of simplicity in this example, the current second from the DateTime.Now property is used.\nThread.Sleep is used to create a ½ second pause, simulating the time that might be needed to perform a complex analysis, and to make the various features of this example more apparent.\n\nInstructions: \nOpen MultithreadedCalculation.rvt\nRun the external command\nSelect the mass, floor, or wall in the sample file\nRevit will be adding results data to the largest face of the selected element\nAt any time (while the calculation is running or after it is complete), modify the geometry of the element. The previous result data will be removed and new results data will be calculated."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\AnalysisVisualizationFramework\\SpatialFieldGradient\\CS",
    "key_code": {
      "class_name": "SpatialFieldGradient",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, ElementSet elements)\n      {\n         ExternalCommandData cdata = commandData;\n         Autodesk.Revit.ApplicationServices.Application app = commandData.Application.Application;\n         Document doc = commandData.Application.ActiveUIDocument.Document;\n         UIDocument uiDoc = commandData.Application.ActiveUIDocument;\n\n         Transaction trans = new Transaction(doc, \"Revit.SDK.Samples.AnalysisVisualizationFramework\");\n         trans.Start();\n\n         SpatialFieldManager sfm = SpatialFieldManager.GetSpatialFieldManager(doc.ActiveView);         \n         if (sfm == null) sfm = SpatialFieldManager.CreateSpatialFieldManager(doc.ActiveView, 1);\n\n         IList<Reference> refList = new List<Reference>();\n         refList = uiDoc.Selection.PickObjects(Autodesk.Revit.UI.Selection.ObjectType.Face);\n                 foreach (Reference reference in refList)\n                 {\n\n                         IList<UV> uvPts = new List<UV>();\n\n                         List<double> doubleList = new List<double>();\n                         IList<ValueAtPoint> valList = new List<ValueAtPoint>();\n                         Face face = doc.GetElement(reference).GetGeometryObjectFromReference(reference)as Face;\n                         BoundingBoxUV bb = face.GetBoundingBox();\n                         UV min = bb.Min;\n                         UV max = bb.Max;\n\n                         for (double u = min.U; u < max.U; u += (max.U - min.U) / 10)\n                         {\n                             for (double v = min.V; v < max.V; v += (max.V - min.V) / 10)\n                             {\n                                 UV uv = new UV(u, v);\n                                 if (face.IsInside(uv))\n                                 {\n                                     uvPts.Add(uv);\n                                     doubleList.Add(v + DateTime.Now.Second);\n                                     valList.Add(new ValueAtPoint(doubleList));\n                                     doubleList.Clear();\n                                 }\n                             }\n                         }\n\n                         FieldDomainPointsByUV pnts = new FieldDomainPointsByUV(uvPts);\n                         FieldValues vals = new FieldValues(valList);\n                         int idx = sfm.AddSpatialFieldPrimitive(reference);\n                         AnalysisResultSchema resultSchema = new AnalysisResultSchema(\"Schema 1\", \"Schema 1 Description\"); \n                         sfm.UpdateSpatialFieldPrimitive(idx, pnts, vals, sfm.RegisterResult(resultSchema));\n                 }\n\n\n\n         trans.Commit();\n         return Result.Succeeded;\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_SpatialFieldGradient.rtf": "Description: Create an AnalysisDisplayColoredSurfaceSettings object and set it to show gridlines on the surfaces\nCreate an AnalysisDisplayColorSettings object and set min and max colors\nCreate an AnalysisDisplayLegendSettings object and specify various legend settings\nCreate an Analysis Display Style using the settings created in the previous steps\nSet the active view to use this Analysis Display Style\nCreate a list (measureNames) so that each data point can store multiple values\nCreate lists (unitNames & multipliers) so that the data can be displayed in both feet and inches\nWhen a face is selected\nDivide the face’s U & V parameterization into 10 segments in each direction\nCreate three values based on the face’s U value at each point (U, U + 1, U * 10)\nUpdate the spatial field primitive to show this data on the face.\n\nInstructions: \nRun the external command\nSelect a face"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\AreaReinCurve\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, \"Revit.SDK.Samples.AreaReinCurve\");\n            trans.Start();\n            ElementSet selected = new ElementSet();\n            foreach (ElementId elementId in revit.Application.ActiveUIDocument.Selection.GetElementIds())\n            {\n               selected.Insert(revit.Application.ActiveUIDocument.Document.GetElement(elementId));\n            }\n\n            try\n            {\n                m_doc = revit.Application.ActiveUIDocument.Document;\n\n                //selected is not one rectangular AreaReinforcement\n                if (!PreData(selected))\n                {\n                    message = \"Please select only one rectangular AreaReinforcement.\";\n                    trans.RollBack();\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                //fail to turn off layers\n                if (!TurnOffLayers())\n                {\n                    message = \"Can't turn off layers as expected or can't find these layers.\";\n                    trans.RollBack();\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                //fail to remove hooks\n                if (!ChangeHookType())\n                {\n                    message = \"Can't remove HookTypes as expected.\";\n                    trans.RollBack();\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n            }\n            catch (ApplicationException appEx)\n            {\n                message = appEx.ToString();\n                trans.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            catch\n            {\n                message = \"Unexpected error happens.\";\n                trans.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            //command is successful\n            string msg = \"All layers but Major Direction Layer or Exterior Direction Layer \";\n            msg += \"have been turn off; \";\n            msg += \"Removed the Hooks from one boundary curve of the Major Direction Layer \";\n            msg += \"or Exterior Direction Layer.\";\n            TaskDialog.Show(\"Revit\", msg);\n            trans.Commit();\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        /// <summary>\n        /// check whether the selected is expected, prepare necessary data\n        /// </summary>\n        /// <param name=\"selected\">selected elements</param>\n        /// <returns>whether the selected AreaReinforcement is expected</returns>\n        private bool PreData(ElementSet selected)\n        {\n            //selected is not only one AreaReinforcement\n            if (selected.Size != 1)\n            {\n                return false;\n            }\n            foreach (Object o in selected)\n            {\n                m_areaRein = o as AreaReinforcement;\n                if (null == m_areaRein)\n                {\n                    return false;\n                }\n            }\n\n            //whether the selected AreaReinforcement is rectangular\n            CurveArray curves = new CurveArray();\n            m_areaReinCurves = new List<AreaReinforcementCurve>();\n            IList<ElementId> curveIds = m_areaRein.GetBoundaryCurveIds();\n            foreach (ElementId o in curveIds)\n            {\n                AreaReinforcementCurve areaCurve = m_doc.GetElement(o) as AreaReinforcementCurve;\n                if (null == areaCurve)\n                {\n                    ApplicationException appEx = new ApplicationException\n                        (\"There is unexpected error with selected AreaReinforcement.\");\n                    throw appEx;\n                }\n                m_areaReinCurves.Add(areaCurve);\n                curves.Append(areaCurve.Curve);\n            }\n            bool flag = GeomUtil.IsRectangular(curves);\n\n            return flag;\n        }\n\n        /// <summary>\n        /// turn off all layers but the Major Direction Layer or Exterior Direction Layer\n        /// </summary>\n        /// <returns>whether the command is successful</returns>\n        private bool TurnOffLayers()\n        {\n            //AreaReinforcement is on the floor or slab\n            bool flag = true;\n            flag = ParameterUtil.SetParaInt(m_areaRein,\n                BuiltInParameter.REBAR_SYSTEM_ACTIVE_BOTTOM_DIR_1, 0);\n            flag &= ParameterUtil.SetParaInt(m_areaRein,\n                BuiltInParameter.REBAR_SYSTEM_ACTIVE_BOTTOM_DIR_2, 0);\n            flag &= ParameterUtil.SetParaInt(m_areaRein,\n                BuiltInParameter.REBAR_SYSTEM_ACTIVE_TOP_DIR_2, 0);\n\n            //AreaReinforcement is on the wall\n            if (!flag)\n            {\n                flag = true;\n                flag &= ParameterUtil.SetParaInt(m_areaRein, \"Interior Major Direction\", 0);\n                flag &= ParameterUtil.SetParaInt(m_areaRein, \"Exterior Minor Direction\", 0);\n                flag &= ParameterUtil.SetParaInt(m_areaRein, \"Interior Minor Direction\", 0);\n            }\n\n            return flag;\n        }\n\n        /// <summary>\n        /// remove the hooks from one boundary curve of the Major Direction Layer \n        /// or Exterior Direction Layer\n        /// </summary>\n        /// <returns>whether the command is successful</returns>\n        private bool ChangeHookType()\n        {\n            //find two vertical AreaReinforcementCurve\n            Line line0 = m_areaReinCurves[0].Curve as Line;\n            Line line1 = m_areaReinCurves[1].Curve as Line;\n            Line line2 = m_areaReinCurves[2].Curve as Line;\n            AreaReinforcementCurve temp = null;\n            if (GeomUtil.IsVertical(line0, line1))\n            {\n                temp = m_areaReinCurves[1];\n            }\n            else\n            {\n                temp = m_areaReinCurves[2];\n            }\n\n            //remove hooks\n            ParameterUtil.SetParaInt(m_areaReinCurves[0],\n                BuiltInParameter.REBAR_SYSTEM_OVERRIDE, -1);\n            Parameter para = m_areaReinCurves[0].get_Parameter(\n                BuiltInParameter.REBAR_SYSTEM_HOOK_TYPE_TOP_DIR_1);\n            bool flag = ParameterUtil.SetParaNullId(para);\n\n            ParameterUtil.SetParaInt(temp, BuiltInParameter.REBAR_SYSTEM_OVERRIDE, -1);\n            para = temp.get_Parameter(\n                BuiltInParameter.REBAR_SYSTEM_HOOK_TYPE_TOP_DIR_1);\n            flag &= ParameterUtil.SetParaNullId(para);\n\n            return flag;\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_AreaReinCurve.rtf": "Summary: This sample shows user how to get AreaReinforcementCurve and change its parameters.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.ElementSet\nAutodesk.Revit.DB.Structure.AreaReinforcementCurve\nAutodesk.Revit.DB.BuiltInParameter\n\nProject Files: \nAreaReinCurve.cs\nImplement the IExternalCommand interface, and show user how to get AreaReinforcmentCurve and how to get parameter by BuildInPatameter.\n\nGeomUtil.cs\nThis file defines a class GeomUtil provides some common geometry estimate and calculates methods.\n\nParameterUtil.cs\nThis file defines a class ParameterUtil contains methods use to manage parameter. Such as find parameter by name and change value of parameter.\n\nDescription: This sample shows user how to get the AreaReinforcement and AreaReinforcementCurve, and show user how to get the parameter by Element.get_Parameter(Autodesk.Revit.Parameters.BuiltInParameter parameterId) method and change its value by Parameter.Set(…) method.\n\n\nInstructions: \n1.\tDraw AreaReinforcement (or open AreaReinCurve.rvt) and Select it.\n2.\tRun this command\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\AutoRoute\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message,\n            ElementSet elements)\n        {\n            // set out default result to Failed.\n            Autodesk.Revit.UI.Result retRes = Autodesk.Revit.UI.Result.Failed;\n\n            m_application = commandData.Application.Application;\n            m_document = commandData.Application.ActiveUIDocument.Document;\n            Trace.Listeners.Clear();\n            Trace.AutoFlush = true;\n\n            //get the system type id of the duct\n            ElementClassFilter systemTypeFilter = new ElementClassFilter(typeof(MEPSystemType));\n            FilteredElementCollector C = new FilteredElementCollector(m_document);\n            C.WherePasses(systemTypeFilter);\n            foreach (MEPSystemType type in C)\n            {\n                if (type.SystemClassification == MEPSystemClassification.SupplyAir)\n                {\n                    systemTypeId = type.Id;\n                    break;\n                }\n            }\n\n            string outputFileName = Path.Combine(Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location), \"AutoRoute.log\");\n            if (File.Exists(outputFileName))\n            {\n                File.Delete(outputFileName);\n            }\n            TextWriterTraceListener listener = new TextWriterTraceListener(outputFileName);\n            Trace.Listeners.Add(listener);\n\n            Transaction transaction = new Transaction(m_document, \"Sample_AutoRoute\");\n            try\n            {\n                transaction.Start();\n\n                //set the level of the duct            \n                lvl = Level.Create(m_document, 0.0);\n\n                //Lists to temporarily record the created elements\n                List<Duct> ducts = new List<Duct>();\n                List<GXYZ> points = new List<GXYZ>();\n                List<Connector> connectors = new List<Connector>();\n                List<Connector> baseConnectors = new List<Connector>();\n\n                //Get the connectors and bounding boxes\n                List<Autodesk.Revit.DB.ElementId> ids = new List<ElementId>();\n                ids.Add(new ElementId(378728L));\n                ids.Add(new ElementId(378707L));\n                ids.Add(new ElementId(378716L));\n\n                FamilyInstance[] instances = new FamilyInstance[3];\n                Autodesk.Revit.DB.BoundingBoxXYZ[] boxes = new Autodesk.Revit.DB.BoundingBoxXYZ[3];\n                Connector[] conns = new Connector[3];\n                ConnectorSetIterator csi = null;\n                for (int i = 0; i < ids.Count; ++i)\n                {\n                    Element element = m_document.GetElement(ids[i]);\n                    if (null == element)\n                    {\n                        message = \"Element \" + ids[i].ToString() + \" can't be found.\";\n                        return Autodesk.Revit.UI.Result.Failed;\n                    }\n                    instances[i] = element as FamilyInstance;\n                    csi = ConnectorInfo.GetConnectors(ids[i]).ForwardIterator();\n                    csi.MoveNext();\n                    conns[i] = csi.Current as Connector;\n                    boxes[i] = instances[i].get_BoundingBox(m_document.ActiveView);\n                }\n\n                //Find the \"Out\" and \"SupplyAir\" connector on the base equipment\n                csi = ConnectorInfo.GetConnectors(ids[0]).ForwardIterator();\n                while (csi.MoveNext())\n                {\n                    Connector conn = csi.Current as Connector;\n                    if (conn.Direction == FlowDirectionType.Out && conn.DuctSystemType == DuctSystemType.SupplyAir)\n                    {\n                        conns[0] = conn;\n                    }\n                }\n\n                //Create a mechanical system with a base air supply equipment and 2 terminals.\n                m_mechanicalSystem = CreateMechanicalSystem(\n                    //[378728][SupplyAir][Out][RectProfile][OST_MechanicalEquipment]\n                        new ConnectorInfo(new ElementId(378728L), conns[0].Origin.X, conns[0].Origin.Y, conns[0].Origin.Z),\n                    new ConnectorInfo[]{\n                        //[378707][SupplyAir][In][RectProfile]\n                        new ConnectorInfo(new ElementId(378707L), conns[1].Origin.X, conns[1].Origin.Y, conns[1].Origin.Z),\n                        //[378716][SupplyAir][In][RectProfile]\n                        new ConnectorInfo(new ElementId(378716L), conns[2].Origin.X, conns[2].Origin.Y, conns[2].Origin.Z)\n                    },\n                    DuctSystemType.SupplyAir\n                );\n\n                //Get the boundary of the system\n                double minX = conns[0].Origin.X;\n                double minY = conns[0].Origin.Y;\n                double maxX = conns[0].Origin.X;\n                double maxY = conns[0].Origin.Y;\n                double maxZ = conns[0].Origin.Z;\n                for (int i = 1; i < boxes.Length; ++i)\n                {\n                    if (conns[i].Origin.X < minX)\n                        minX = conns[i].Origin.X;\n                    if (conns[i].Origin.Y < minY)\n                        minY = conns[i].Origin.Y;\n                    if (conns[i].Origin.X > maxX)\n                        maxX = conns[i].Origin.X;\n                    if (conns[i].Origin.Y > maxY)\n                        maxY = conns[i].Origin.Y;\n                    if (conns[i].Origin.Z > maxZ)\n                        maxZ = conns[i].Origin.Z;\n                }\n\n                //Calculate the optional values for the trunk ducts\n                double midX = (minX + maxX) / 2;\n                double midY = (minY + maxY) / 2;\n                double[] baseXValues = new double[3] { midX, (minX + midX) / 2, (maxX + midX) / 2 };\n                double[] baseYValues = new double[3] { midY, (minY + midY) / 2, (maxY + midY) / 2 };\n\n                //Get the duct type for the ducts to be created\n                dtRectangle = m_document.GetElement(ductTypeId) as DuctType;\n\n\n                //Create the ducts and elbows that connect the base mechanical equipment\n                GXYZ connectorDirection = conns[0].CoordinateSystem.BasisZ;\n\n                if (0 == connectorDirection.DistanceTo(new GXYZ(-1, 0, 0)))\n                {\n                    points.Add(new GXYZ(conns[0].Origin.X - min1FittingLength, conns[0].Origin.Y, conns[0].Origin.Z));\n                    points.Add(new GXYZ(conns[0].Origin.X - min2FittingsLength, conns[0].Origin.Y, conns[0].Origin.Z + min1FittingLength));\n                    points.Add(new GXYZ(conns[0].Origin.X - min2FittingsLength, conns[0].Origin.Y, maxZ + verticalTrunkOffset - min1FittingLength));\n                }\n                else if (0 == connectorDirection.DistanceTo(new GXYZ(1, 0, 0)))\n                {\n                    points.Add(new GXYZ(conns[0].Origin.X + min1FittingLength, conns[0].Origin.Y, conns[0].Origin.Z));\n                    points.Add(new GXYZ(conns[0].Origin.X + min2FittingsLength, conns[0].Origin.Y, conns[0].Origin.Z + min1FittingLength));\n                    points.Add(new GXYZ(conns[0].Origin.X + min2FittingsLength, conns[0].Origin.Y, maxZ + verticalTrunkOffset - min1FittingLength));\n                }\n                else if (0 == connectorDirection.DistanceTo(new GXYZ(0, -1, 0)))\n                {\n                    points.Add(new GXYZ(conns[0].Origin.X, conns[0].Origin.Y - min1FittingLength, conns[0].Origin.Z));\n                    points.Add(new GXYZ(conns[0].Origin.X, conns[0].Origin.Y - min2FittingsLength, conns[0].Origin.Z + min1FittingLength));\n                    points.Add(new GXYZ(conns[0].Origin.X, conns[0].Origin.Y - min2FittingsLength, maxZ + verticalTrunkOffset - min1FittingLength));\n                }\n                else if (0 == connectorDirection.DistanceTo(new GXYZ(0, 1, 0)))\n                {\n                    points.Add(new GXYZ(conns[0].Origin.X, conns[0].Origin.Y + min1FittingLength, conns[0].Origin.Z));\n                    points.Add(new GXYZ(conns[0].Origin.X, conns[0].Origin.Y + min2FittingsLength, conns[0].Origin.Z + min1FittingLength));\n                    points.Add(new GXYZ(conns[0].Origin.X, conns[0].Origin.Y + min2FittingsLength, maxZ + verticalTrunkOffset - min1FittingLength));\n                }\n                ducts.Add(Duct.Create(m_document, ductTypeId, lvl.Id,conns[0], points[0]));\n\n\n                ducts.Add(Duct.Create(m_document, systemTypeId, ductTypeId, lvl.Id, points[1], points[2]));\n                connectors.Add(ConnectorInfo.GetConnector(ducts[0].Id, points[0]));\n                connectors.Add(ConnectorInfo.GetConnector(ducts[1].Id, points[1]));\n                connectors.Add(ConnectorInfo.GetConnector(ducts[1].Id, points[2]));\n                connectors[0].ConnectTo(connectors[1]);\n                m_document.Create.NewElbowFitting(connectors[0], connectors[1]);\n                baseConnectors.Add(connectors[2]);\n\n                //Create the vertical ducts for terminals\n                points.Clear();\n                ducts.Clear();\n\n                points.Add(new GXYZ(conns[1].Origin.X, conns[1].Origin.Y, maxZ + verticalTrunkOffset - min1FittingLength));\n                points.Add(new GXYZ(conns[2].Origin.X, conns[2].Origin.Y, maxZ + verticalTrunkOffset - min1FittingLength));\n                ducts.Add(Duct.Create(m_document, ductTypeId, lvl.Id, conns[1], points[0]));\n                ducts.Add(Duct.Create(m_document, ductTypeId, lvl.Id, conns[2], points[1]));\n                baseConnectors.Add(ConnectorInfo.GetConnector(ducts[0].Id, points[0]));\n                baseConnectors.Add(ConnectorInfo.GetConnector(ducts[1].Id, points[1]));\n\n                //Connect the system by creating the trunk line of ducts and connect them to the base connectors\n                SortConnectorsByX(baseConnectors);\n                for (int i = 0; i < baseYValues.Length; ++i)\n                {\n                    if (ConnectSystemOnXAxis(baseConnectors, baseYValues[i]))\n                    {\n                        LogUtility.WriteMechanicalSystem(m_mechanicalSystem);\n                        return Autodesk.Revit.UI.Result.Succeeded;\n                    }\n                }\n\n                SortConnectorsByY(baseConnectors);\n                for (int i = 0; i < baseXValues.Length; ++i)\n                {\n                    if (ConnectSystemOnYAxis(baseConnectors, baseXValues[i]))\n                    {\n                        LogUtility.WriteMechanicalSystem(m_mechanicalSystem);\n                        return Autodesk.Revit.UI.Result.Succeeded;\n                    }\n                }\n\n                //If all the cases fail to route the system, try the trunks out of the bounding box\n                SortConnectorsByX(baseConnectors);\n                if (ConnectSystemOnXAxis(baseConnectors, maxY + horizontalOptionalTrunkOffset))\n                {\n                    LogUtility.WriteMechanicalSystem(m_mechanicalSystem);\n                    return Autodesk.Revit.UI.Result.Succeeded;\n                }\n\n                SortConnectorsByY(baseConnectors);\n                if (ConnectSystemOnYAxis(baseConnectors, maxX + horizontalOptionalTrunkOffset))\n                {\n                    LogUtility.WriteMechanicalSystem(m_mechanicalSystem);\n                    return Autodesk.Revit.UI.Result.Succeeded;\n                }\n\n                //If there's no path for the connection, choose one path and let Revit report the error\n                connectors.Clear();\n                SortConnectorsByX(baseConnectors);\n                connectors.AddRange(CreateDuct(new GXYZ(baseConnectors[0].Origin.X + min1FittingLength, baseYValues[0], maxZ + verticalTrunkOffset), new GXYZ(baseConnectors[1].Origin.X - min1FittingLength, baseYValues[0], maxZ + verticalTrunkOffset)));\n                connectors.AddRange(CreateDuct(new GXYZ(baseConnectors[1].Origin.X + min1FittingLength, baseYValues[0], maxZ + verticalTrunkOffset), new GXYZ(baseConnectors[2].Origin.X - min1FittingLength, baseYValues[0], maxZ + verticalTrunkOffset)));\n                ConnectWithElbowFittingOnXAxis(baseConnectors[0], connectors[0]);\n                ConnectWithElbowFittingOnXAxis(baseConnectors[2], connectors[3]);\n                ConnectWithTeeFittingOnXAxis(baseConnectors[1], connectors[1], connectors[2], false);\n\n            }\n            catch (Exception ex)\n            {\n                Trace.WriteLine(ex.ToString());\n                message = ex.Message;\n                retRes = Autodesk.Revit.UI.Result.Failed;\n            }\n            finally\n            {\n                transaction.Commit();\n                Trace.Flush();\n                listener.Close();\n                Trace.Close();\n                Trace.Listeners.Remove(listener);\n            }\n            return retRes;\n        }\n        #endregion\n\n        /// <summary>\n        /// Connect the system with a trunk line of ducts on X axis\n        /// </summary>\n        /// <param name=\"baseConnectors\">the upper connectors of the vertical ducts that derived from the terminals and the base equipment</param>\n        /// <param name=\"baseY\">the y value of the trunk line</param>\n        /// <returns>\n        /// true if the system can be connected\n        /// false if the system cannot be connected\n        /// </returns>\n        private bool ConnectSystemOnXAxis(List<Connector> baseConnectors, double baseY)\n        {\n            //Check the count of the base connectors\n            if (null == baseConnectors || 3 != baseConnectors.Count)\n            {\n                return false;\n            }\n            for (int i = 0; i < baseConnectors.Count; ++i)\n            {\n                //Check the distance of the connector from the trunk\n                if (baseConnectors[i].Origin.Y != baseY && Math.Abs(baseConnectors[i].Origin.Y - baseY) < min1Duct2FittingsLength)\n                {\n                    return false;\n                }\n                //Check the distance of the connectors on X axis\n                for (int j = i + 1; j < baseConnectors.Count; ++j)\n                {\n                    if (baseConnectors[j].Origin.X != baseConnectors[i].Origin.X && baseConnectors[j].Origin.X - baseConnectors[i].Origin.X < min2FittingsLength)\n                    {\n                        return false;\n                    }\n                }\n            }\n            try\n            {\n                double baseZ = baseConnectors[0].Origin.Z + min1FittingLength;\n                //Create the ducts and elbow fittings to connect the vertical ducts and the trunk ducts\n                List<Connector> connectors = new List<Connector>();\n\n                if (baseConnectors[0].Origin.X == baseConnectors[1].Origin.X)\n                {\n                    //All 3 connectors are with the same X value\n                    if (baseConnectors[1].Origin.X == baseConnectors[2].Origin.X)\n                    {\n                        return false;\n                    }\n                    else\n                    {\n                        //The 1st and 2nd base connectors are on the same side of the trunk\n                        if (Math.Sign(baseConnectors[0].Origin.Y - baseY) * Math.Sign(baseConnectors[1].Origin.Y - baseY) == 1)\n                        {\n                            return false;\n                        }\n\n                        //Create the trunk\n                        connectors = CreateDuct(new GXYZ(baseConnectors[0].Origin.X + min1FittingLength, baseY, baseZ), new GXYZ(baseConnectors[2].Origin.X - min1FittingLength, baseY, baseZ));\n\n                        //Create a tee fitting connecting the 1st and 2nd base connectors to the trunk\n                        ConnectWithTeeFittingOnXAxis(baseConnectors[0], baseConnectors[1], connectors[0], true);\n\n                        //Create an elbow fitting connection the 3rd base connector to the trunk\n                        ConnectWithElbowFittingOnXAxis(baseConnectors[2], connectors[1]);\n                    }\n                }\n                else\n                {\n                    //Create the segment of duct on the trunk to be connected to the 1st base connector\n                    connectors = CreateDuct(new GXYZ(baseConnectors[0].Origin.X + min1FittingLength, baseY, baseZ), new GXYZ(baseConnectors[1].Origin.X - min1FittingLength, baseY, baseZ));\n\n                    //Create an elbow fitting connection the 1st base connector with the trunk\n                    ConnectWithElbowFittingOnXAxis(baseConnectors[0], connectors[0]);\n\n                    if (baseConnectors[1].Origin.X == baseConnectors[2].Origin.X)\n                    {\n                        //The 2nd and 3rd connectors are on the same side of the trunk\n                        if (Math.Sign(baseConnectors[1].Origin.Y - baseY) * Math.Sign(baseConnectors[2].Origin.Y - baseY) == 1)\n                        {\n                            return false;\n                        }\n                        //Create a tee fitting connecting the 2nd and 3rd base connectors to the trunk\n                        ConnectWithTeeFittingOnXAxis(baseConnectors[1], baseConnectors[2], connectors[1], true);\n                    }\n                    else\n                    {\n                        connectors.AddRange(CreateDuct(new GXYZ(baseConnectors[1].Origin.X + min1FittingLength, baseY, baseZ), new GXYZ(baseConnectors[2].Origin.X - min1FittingLength, baseY, baseZ)));\n                        //Create a tee fitting connecting the 2nd base connector to the trunk\n                        ConnectWithTeeFittingOnXAxis(baseConnectors[1], connectors[1], connectors[2], false);\n                        //Create an elbow fitting connection the 3rd base connector to the trunk\n                        ConnectWithElbowFittingOnXAxis(baseConnectors[2], connectors[3]);\n                    }\n                }\n\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Connect a base connector to a connector on the trunk with an elbow fitting\n        /// </summary>\n        /// <param name=\"baseConn\">the upper connector of the vertical duct that derived from a terminal or the base equipment</param>\n        /// <param name=\"conn\">the connector of a duct on the trunk</param>\n        private void ConnectWithElbowFittingOnXAxis(Connector baseConn, Connector conn)\n        {\n            double baseY = conn.Origin.Y;\n            double baseZ = conn.Origin.Z;\n            List<Connector> connectors = new List<Connector>();\n\n            //If the distance of the two connectors on the Y axis is greater than 2, create a duct on the Y axis and then connect it to the 2 connectors with elbow fittings\n            if (Math.Abs(baseConn.Origin.Y - baseY) > min1Duct2FittingsLength)\n            {\n                connectors.AddRange(CreateDuct(new GXYZ(baseConn.Origin.X, baseConn.Origin.Y - Math.Sign(baseConn.Origin.Y - baseY), baseZ), new GXYZ(baseConn.Origin.X, baseY + Math.Sign(baseConn.Origin.Y - baseY), baseZ)));\n                connectors[0].ConnectTo(baseConn);\n                m_document.Create.NewElbowFitting(connectors[0], baseConn);\n                connectors[1].ConnectTo(conn);\n                m_document.Create.NewElbowFitting(connectors[1], conn);\n            }\n            //If the distance of the two connectors on the Y axis is less than 2, connect them with an elbow fitting\n            else\n            {\n                baseConn.ConnectTo(conn);\n                m_document.Create.NewElbowFitting(baseConn, conn);\n            }\n        }\n\n        /// <summary>\n        /// Connect 3 connectors on the trunk with a tee fitting\n        /// </summary>\n        /// <param name=\"conn1\">the first connector</param>\n        /// <param name=\"conn2\">the second connector</param>\n        /// <param name=\"conn3\">the third connector</param>\n        /// <param name=\"flag\">a flag to indicate whether there are 2 base connectors or 1 base connector</param>\n        private void ConnectWithTeeFittingOnXAxis(Connector conn1, Connector conn2, Connector conn3, bool flag)\n        {\n            double baseY = conn3.Origin.Y;\n            double baseZ = conn3.Origin.Z;\n\n            List<GXYZ> points = new List<GXYZ>();\n            List<Duct> ducts = new List<Duct>();\n            List<Connector> connectors = new List<Connector>();\n\n            //Connect two base connectors to a connector on the trunk\n            if (true == flag)\n            {\n\n                Connector baseConn1 = conn1;\n                Connector baseConn2 = conn2;\n                Connector conn = conn3;\n\n                connectors.AddRange(CreateDuct(new GXYZ(baseConn1.Origin.X, baseConn1.Origin.Y - Math.Sign(baseConn1.Origin.Y - baseY), baseZ), new GXYZ(baseConn1.Origin.X, baseY + Math.Sign(baseConn1.Origin.Y - baseY), baseZ)));\n                connectors.AddRange(CreateDuct(new GXYZ(baseConn2.Origin.X, baseConn2.Origin.Y - Math.Sign(baseConn2.Origin.Y - baseY), baseZ), new GXYZ(baseConn2.Origin.X, baseY + Math.Sign(baseConn2.Origin.Y - baseY), baseZ)));\n\n                connectors[0].ConnectTo(baseConn1);\n                connectors[2].ConnectTo(baseConn2);\n                m_document.Create.NewElbowFitting(connectors[0], baseConn1);\n                m_document.Create.NewElbowFitting(connectors[2], baseConn2);\n\n                connectors[1].ConnectTo(connectors[3]);\n                connectors[1].ConnectTo(conn);\n                connectors[3].ConnectTo(conn);\n                m_document.Create.NewTeeFitting(connectors[1], connectors[3], conn);\n            }\n            //Connect a base connector to two connectors on the trunk\n            else\n            {\n                Connector baseConn = conn1;\n\n                if (Math.Abs(baseConn.Origin.Y - baseY) > min1Duct2FittingsLength)\n                {\n                    connectors.AddRange(CreateDuct(new GXYZ(baseConn.Origin.X, baseConn.Origin.Y - Math.Sign(baseConn.Origin.Y - baseY), baseZ), new GXYZ(baseConn.Origin.X, baseY + Math.Sign(baseConn.Origin.Y - baseY), baseZ)));\n                    baseConn.ConnectTo(connectors[0]);\n                    m_document.Create.NewElbowFitting(connectors[0], baseConn);\n\n                    connectors[1].ConnectTo(conn2);\n                    connectors[1].ConnectTo(conn3);\n                    conn2.ConnectTo(conn3);\n                    m_document.Create.NewTeeFitting(conn2, conn3, connectors[1]);\n                }\n                else\n                {\n                    baseConn.ConnectTo(conn2);\n                    baseConn.ConnectTo(conn3);\n                    conn2.ConnectTo(conn3);\n                    m_document.Create.NewTeeFitting(conn2, conn3, baseConn);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Sort the base connectors by their x values\n        /// </summary>\n        /// <param name=\"connectors\">the connectors to be sorted</param>\n        private void SortConnectorsByX(List<Connector> connectors)\n        {\n            for (int i = 0; i < connectors.Count; ++i)\n            {\n                double min = connectors[i].Origin.X;\n                int minIndex = i;\n                for (int j = i; j < connectors.Count; ++j)\n                {\n                    if (connectors[j].Origin.X < min)\n                    {\n                        min = connectors[j].Origin.X;\n                        minIndex = j;\n                    }\n                }\n                Connector t = connectors[i];\n                connectors[i] = connectors[minIndex];\n                connectors[minIndex] = t;\n            }\n        }\n\n        /// <summary>\n        /// Connect the system with a trunk line of ducts on Y axis\n        /// </summary>\n        /// <param name=\"baseConnectors\">the upper connectors of the vertical ducts that derived from the terminals and the base equipment</param>\n        /// <param name=\"baseX\">the x value of the trunk line</param>\n        /// <returns>\n        /// true if the system can be connected\n        /// false if the system cannot be connected\n        /// </returns>\n        private bool ConnectSystemOnYAxis(List<Connector> baseConnectors, double baseX)\n        {\n            //Check the count of the base connectors\n            if (null == baseConnectors || 3 != baseConnectors.Count)\n            {\n                return false;\n            }\n            for (int i = 0; i < baseConnectors.Count; ++i)\n            {\n                //Check the distance of the connector from the trunk\n                if (baseConnectors[i].Origin.X != baseX && Math.Abs(baseConnectors[i].Origin.X - baseX) < min1Duct2FittingsLength)\n                {\n                    return false;\n                }\n                //Check the distance of the connectors on Y axis\n                for (int j = i + 1; j < baseConnectors.Count; ++j)\n                {\n                    if (baseConnectors[j].Origin.Y != baseConnectors[i].Origin.Y && baseConnectors[j].Origin.Y - baseConnectors[i].Origin.Y < min2FittingsLength)\n                    {\n                        return false;\n                    }\n                }\n            }\n            try\n            {\n                double baseZ = baseConnectors[0].Origin.Z + min1FittingLength;\n                //Create the ducts and elbow fittings to connect the vertical ducts and the trunk ducts\n                List<Connector> connectors = new List<Connector>();\n\n                if (baseConnectors[0].Origin.Y == baseConnectors[1].Origin.Y)\n                {\n                    //All 3 connectors are with the same Y value\n                    if (baseConnectors[1].Origin.Y == baseConnectors[2].Origin.Y)\n                    {\n                        return false;\n                    }\n                    else\n                    {\n                        //The 1st and 2nd base connectors are on the same side of the trunk\n                        if (Math.Sign(baseConnectors[0].Origin.X - baseX) * Math.Sign(baseConnectors[1].Origin.X - baseX) == 1)\n                        {\n                            return false;\n                        }\n\n                        //Create the trunk\n                        connectors = CreateDuct(new GXYZ(baseX, baseConnectors[0].Origin.Y + min1FittingLength, baseZ), new GXYZ(baseX, baseConnectors[2].Origin.Y - min1FittingLength, baseZ));\n\n                        //Create a tee fitting connecting the 1st and 2nd base connectors to the trunk\n                        ConnectWithTeeFittingOnYAxis(baseConnectors[0], baseConnectors[1], connectors[0], true);\n\n                        //Create an elbow fitting connection the 3rd base connector to the trunk\n                        ConnectWithElbowFittingOnYAxis(baseConnectors[2], connectors[1]);\n                    }\n                }\n                else\n                {\n                    //Create the segment of duct on the trunk to be connected to the 1st base connector\n                    connectors = CreateDuct(new GXYZ(baseX, baseConnectors[0].Origin.Y + min1FittingLength, baseZ), new GXYZ(baseX, baseConnectors[1].Origin.Y - min1FittingLength, baseZ));\n\n                    //Create an elbow fitting connection the 1st base connector with the trunk\n                    ConnectWithElbowFittingOnYAxis(baseConnectors[0], connectors[0]);\n\n                    if (baseConnectors[1].Origin.Y == baseConnectors[2].Origin.Y)\n                    {\n                        //The 2nd and 3rd connectors are on the same side of the trunk\n                        if (Math.Sign(baseConnectors[1].Origin.X - baseX) * Math.Sign(baseConnectors[2].Origin.X - baseX) == 1)\n                        {\n                            return false;\n                        }\n                        //Create a tee fitting connecting the 2nd and 3rd base connectors to the trunk\n                        ConnectWithTeeFittingOnYAxis(baseConnectors[1], baseConnectors[2], connectors[1], true);\n                    }\n                    else\n                    {\n                        connectors.AddRange(CreateDuct(new GXYZ(baseX, baseConnectors[1].Origin.Y + min1FittingLength, baseZ), new GXYZ(baseX, baseConnectors[2].Origin.Y - min1FittingLength, baseZ)));\n                        //Create a tee fitting connecting the 2nd base connector to the trunk\n                        ConnectWithTeeFittingOnYAxis(baseConnectors[1], connectors[1], connectors[2], false);\n                        //Create an elbow fitting connection the 3rd base connector to the trunk\n                        ConnectWithElbowFittingOnYAxis(baseConnectors[2], connectors[3]);\n                    }\n                }\n\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Connect a base connector to a connector on the trunk with an elbow fitting\n        /// </summary>\n        /// <param name=\"baseConn\">the upper connector of the vertical duct that derived from a terminal or the base equipment</param>\n        /// <param name=\"conn\">the connector of a duct on the trunk</param>\n        private void ConnectWithElbowFittingOnYAxis(Connector baseConn, Connector conn)\n        {\n            double baseX = conn.Origin.X;\n            double baseZ = conn.Origin.Z;\n            List<Connector> connectors = new List<Connector>();\n\n            //If the distance of the two connectors on the X axis is greater than 2, create a duct on the X axis and then connect it to the 2 connectors with elbow fittings\n            if (Math.Abs(baseConn.Origin.X - baseX) > min1Duct2FittingsLength)\n            {\n                connectors.AddRange(CreateDuct(new GXYZ(baseConn.Origin.X - Math.Sign(baseConn.Origin.X - baseX), baseConn.Origin.Y, baseZ), new GXYZ(baseX + Math.Sign(baseConn.Origin.X - baseX), baseConn.Origin.Y, baseZ)));\n                connectors[0].ConnectTo(baseConn);\n                m_document.Create.NewElbowFitting(connectors[0], baseConn);\n                connectors[1].ConnectTo(conn);\n                m_document.Create.NewElbowFitting(connectors[1], conn);\n            }\n            //If the distance of the two connectors on the X axis is less than 2, connect them with an elbow fitting\n            else\n            {\n                baseConn.ConnectTo(conn);\n                m_document.Create.NewElbowFitting(baseConn, conn);\n            }\n        }\n\n        /// <summary>\n        /// Connect 3 connectors on the trunk with a tee fitting\n        /// </summary>\n        /// <param name=\"conn1\">the first connector</param>\n        /// <param name=\"conn2\">the second connector</param>\n        /// <param name=\"conn3\">the third connector</param>\n        /// <param name=\"flag\">a flag to indicate whether there are 2 base connectors or 1 base connector</param>\n        private void ConnectWithTeeFittingOnYAxis(Connector conn1, Connector conn2, Connector conn3, bool flag)\n        {\n            double baseX = conn3.Origin.X;\n            double baseZ = conn3.Origin.Z;\n\n            List<GXYZ> points = new List<GXYZ>();\n            List<Duct> ducts = new List<Duct>();\n            List<Connector> connectors = new List<Connector>();\n\n            //Connect two base connectors to a connector on the trunk\n            if (true == flag)\n            {\n\n                Connector baseConn1 = conn1;\n                Connector baseConn2 = conn2;\n                Connector conn = conn3;\n\n                connectors.AddRange(CreateDuct(new GXYZ(baseConn1.Origin.X - Math.Sign(baseConn1.Origin.X - baseX), baseConn1.Origin.Y, baseZ), new GXYZ(baseX + Math.Sign(baseConn1.Origin.X - baseX), baseConn1.Origin.Y, baseZ)));\n                connectors.AddRange(CreateDuct(new GXYZ(baseConn2.Origin.X - Math.Sign(baseConn2.Origin.X - baseX), baseConn2.Origin.Y, baseZ), new GXYZ(baseX + Math.Sign(baseConn2.Origin.X - baseX), baseConn2.Origin.Y, baseZ)));\n\n                connectors[0].ConnectTo(baseConn1);\n                connectors[2].ConnectTo(baseConn2);\n                m_document.Create.NewElbowFitting(connectors[0], baseConn1);\n                m_document.Create.NewElbowFitting(connectors[2], baseConn2);\n\n                connectors[1].ConnectTo(connectors[3]);\n                connectors[1].ConnectTo(conn);\n                connectors[3].ConnectTo(conn);\n                m_document.Create.NewTeeFitting(connectors[1], connectors[3], conn);\n            }\n            //Connect a base connector to two connectors on the trunk\n            else\n            {\n                Connector baseConn = conn1;\n\n                if (Math.Abs(baseConn.Origin.X - baseX) > min1Duct2FittingsLength)\n                {\n                    connectors.AddRange(CreateDuct(new GXYZ(baseConn.Origin.X - Math.Sign(baseConn.Origin.X - baseX), baseConn.Origin.Y, baseZ), new GXYZ(baseX + Math.Sign(baseConn.Origin.X - baseX), baseConn.Origin.Y, baseZ)));\n                    baseConn.ConnectTo(connectors[0]);\n                    m_document.Create.NewElbowFitting(connectors[0], baseConn);\n\n                    connectors[1].ConnectTo(conn2);\n                    connectors[1].ConnectTo(conn3);\n                    conn2.ConnectTo(conn3);\n                    m_document.Create.NewTeeFitting(conn2, conn3, connectors[1]);\n                }\n                else\n                {\n                    baseConn.ConnectTo(conn2);\n                    baseConn.ConnectTo(conn3);\n                    conn2.ConnectTo(conn3);\n                    m_document.Create.NewTeeFitting(conn2, conn3, baseConn);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Sort the base connectors by their y values\n        /// </summary>\n        /// <param name=\"connectors\">the connectors to be sorted</param>\n        private void SortConnectorsByY(List<Connector> connectors)\n        {\n            for (int i = 0; i < connectors.Count; ++i)\n            {\n                double min = connectors[i].Origin.Y;\n                int minIndex = i;\n                for (int j = i; j < connectors.Count; ++j)\n                {\n                    if (connectors[j].Origin.Y < min)\n                    {\n                        min = connectors[j].Origin.Y;\n                        minIndex = j;\n                    }\n                }\n                Connector t = connectors[i];\n                connectors[i] = connectors[minIndex];\n                connectors[minIndex] = t;\n            }\n        }\n\n        /// <summary>\n        /// Create a duct with two points\n        /// </summary>\n        /// <param name=\"point1\">the first point</param>\n        /// <param name=\"point2\">the second point</param>\n        /// <returns></returns>\n        private List<Connector> CreateDuct(GXYZ point1, GXYZ point2)\n        {\n            List<Connector> connectors = new List<Connector>();\n\n            Duct duct = Duct.Create(m_document, systemTypeId, ductTypeId, lvl.Id, point1, point2);\n\n            connectors.Add(ConnectorInfo.GetConnector(duct.Id, point1));\n            connectors.Add(ConnectorInfo.GetConnector(duct.Id, point2));\n\n            return connectors;\n        }\n\n        /// <summary>\n        /// Create a mechanical system\n        /// </summary>\n        /// <param name=\"baseConnector\">the base connector of the mechanical system</param>\n        /// <param name=\"connectors\">the connectors of the mechanical system</param>\n        /// <param name=\"systemType\">the system type of the mechanical system</param>\n        /// <returns>the created mechanical system</returns>\n        private MechanicalSystem CreateMechanicalSystem(ConnectorInfo baseConnector, ConnectorInfo[] connectors, DuctSystemType systemType)\n        {\n            ConnectorSet cset = null;\n            if (connectors != null)\n            {\n                cset = new ConnectorSet();\n                foreach (ConnectorInfo ci in connectors)\n                {\n                    cset.Insert(ci.Connector);\n                }\n            }\n            MechanicalSystem mechanicalSystem = m_document.Create.NewMechanicalSystem(baseConnector == null ? null : baseConnector.Connector, cset, systemType);\n            return mechanicalSystem;\n        }\n\n        /// <summary>\n        /// information of a connector\n        /// </summary>\n        public class ConnectorInfo\n        {\n            /// <summary>\n            /// The owner's element ID\n            /// </summary>\n            ElementId m_ownerId;\n\n            /// <summary>\n            /// The origin of the connector\n            /// </summary>\n            GXYZ m_origin;\n\n            /// <summary>\n            /// The Connector object\n            /// </summary>\n            Connector m_connector;\n\n            /// <summary>\n            /// The connector this object represents\n            /// </summary>\n            public Connector Connector\n            {\n                get { return m_connector; }\n                set { m_connector = value; }\n            }\n\n            /// <summary>\n            /// The owner ID of the connector\n            /// </summary>\n            public ElementId OwnerId\n            {\n                get { return m_ownerId; }\n                set { m_ownerId = value; }\n            }\n\n            /// <summary>\n            /// The origin of the connector\n            /// </summary>\n            public GXYZ Origin\n            {\n                get { return m_origin; }\n                set { m_origin = value; }\n            }\n\n            /// <summary>\n            /// The constructor that finds the connector with the owner ID and origin\n            /// </summary>\n            /// <param name=\"ownerId\">the ownerID of the connector</param>\n            /// <param name=\"origin\">the origin of the connector</param>\n            public ConnectorInfo(ElementId ownerId, GXYZ origin)\n            {\n                m_ownerId = ownerId;\n                m_origin = origin;\n                m_connector = ConnectorInfo.GetConnector(m_ownerId, origin);\n            }\n\n            /// <summary>\n            /// The constructor that finds the connector with the owner ID and the values of the origin\n            /// </summary>\n            /// <param name=\"ownerId\">the ownerID of the connector</param>\n            /// <param name=\"x\">the X value of the connector</param>\n            /// <param name=\"y\">the Y value of the connector</param>\n            /// <param name=\"z\">the Z value of the connector</param>\n            public ConnectorInfo(ElementId ownerId, double x, double y, double z)\n                : this(ownerId, new GXYZ(x, y, z))\n            {\n            }\n\n            /// <summary>\n            /// Get the connector of the owner at the specific origin\n            /// </summary>\n            /// <param name=\"ownerId\">the owner ID of the connector</param>\n            /// <param name=\"connectorOrigin\">the origin of the connector</param>\n            /// <returns>if found, return the connector, or else return null</returns>\n            public static Connector GetConnector(ElementId ownerId, GXYZ connectorOrigin)\n            {\n                ConnectorSet connectors = GetConnectors(ownerId);\n                foreach (Connector conn in connectors)\n                {\n                    if (conn.ConnectorType == ConnectorType.Logical)\n                        continue;\n                    if (conn.Origin.IsAlmostEqualTo(connectorOrigin))\n                        return conn;\n                }\n                return null;\n            }\n\n            /// <summary>\n            /// Get all the connectors of an element with a specific ID\n            /// </summary>\n            /// <param name=\"ownerId\">the owner ID of the connector</param>\n            /// <returns>the connector set which includes all the connectors found</returns>\n            public static ConnectorSet GetConnectors(ElementId ownerId)\n            {\n                Element element = m_document.GetElement(ownerId);\n                return GetConnectors(element);\n            }\n\n            /// <summary>\n            /// Get all the connectors of a specific element\n            /// </summary>\n            /// <param name=\"element\">the owner of the connector</param>\n            /// <returns>if found, return all the connectors found, or else return null</returns>\n            public static ConnectorSet GetConnectors(Autodesk.Revit.DB.Element element)\n            {\n                if (element == null) return null;\n                FamilyInstance fi = element as FamilyInstance;\n                if (fi != null && fi.MEPModel != null)\n                {\n                    return fi.MEPModel.ConnectorManager.Connectors;\n                }\n                MEPSystem system = element as MEPSystem;\n                if (system != null)\n                {\n                    return system.ConnectorManager.Connectors;\n                }\n\n                MEPCurve duct = element as MEPCurve;\n                if (duct != null)\n                {\n                    return duct.ConnectorManager.Connectors;\n                }\n                return null;\n            }\n\n            /// <summary>\n            /// Find the two connectors of the specific ConnectorManager at the two locations\n            /// </summary>\n            /// <param name=\"connMgr\">The ConnectorManager of the connectors to be found</param>\n            /// <param name=\"ptn1\">the location of the first connector</param>\n            /// <param name=\"ptn2\">the location of the second connector</param>\n            /// <returns>The two connectors found</returns>\n            public static Connector[] FindConnectors(ConnectorManager connMgr, GXYZ pnt1, GXYZ pnt2)\n            {\n                Connector[] result = new Connector[2];\n                ConnectorSet conns = connMgr.Connectors;\n                foreach (Connector conn in conns)\n                {\n                    if (conn.Origin.IsAlmostEqualTo(pnt1))\n                    {\n                        result[0] = conn;\n                    }\n                    else if (conn.Origin.IsAlmostEqualTo(pnt2))\n                    {\n                        result[1] = conn;\n                    }\n                }\n                return result;\n            }\n\n        };\n    }\n\n    public class LogUtility\n    {\n        /// <summary>\n        /// Invalid string.\n        /// </summary>\n        public const string InvalidString = \"[!]\";\n\n        /// <summary>\n        /// Write the information of an element to the log file\n        /// </summary>\n        /// <param name=\"element\">the element whose information is to be written</param>\n        public static void WriteElement(Element element)\n        {\n            WriteElement(element, true);\n        }\n        /// <summary>\n        /// Write the information of an element to the log file\n        /// </summary>\n        /// <param name=\"element\">the element whose information is to be written</param>\n        /// <param name=\"writeId\">whether the id will be outputted</param>\n        public static void WriteElement(Element element, bool writeId)\n        {\n            if (element == null)\n            {\n                Trace.WriteLine(\"null\"); return;\n            }\n            ElementId elementId = element.Id;\n            ElementId familyId = element.get_Parameter(BuiltInParameter.ELEM_FAMILY_PARAM).AsElementId();\n            string familyName = LogUtility.InvalidString;\n            Element objectType = GetElement<Element>(element.Document, familyId);\n            string elementName = LogUtility.InvalidString;\n            try { elementName = element.Name; }\n            catch { }\n            if (objectType != null)\n            {\n                Parameter familyNameParameter = objectType.get_Parameter(BuiltInParameter.ALL_MODEL_FAMILY_NAME);\n                if (familyNameParameter != null)\n                    familyName = familyNameParameter.AsString();\n            }\n            BuiltInCategory category = element.Category.BuiltInCategory;\n\n            Trace.WriteLine(\"Type: \" + element.GetType().FullName);\n            Trace.WriteLine(\"Name: \" + familyName + \":\" + elementName);\n            if (writeId) Trace.WriteLine(\"Id: \" + elementId.ToString());\n            Trace.WriteLine(\"Category: \" + category);\n            Trace.WriteLine(\"FamilyId: \" + familyId.ToString());\n        }\n\n        /// <summary>\n        /// Write the information of a mechanical system to the log file\n        /// </summary>\n        /// <param name=\"system\">the mechanical system whose information is to be written</param>\n        public static void WriteMechanicalSystem(MechanicalSystem system)\n        {\n            string flow = InvalidString;\n            try { flow = system.GetFlow().ToString(); }\n            catch (Exception) { }\n\n            Trace.WriteLine(\"Flow: \" + flow);\n            Trace.WriteLine(\"IsWellConnected: \" + system.IsWellConnected);\n            Trace.WriteLine(\"SystemType: \" + system.SystemType);\n            Trace.WriteLine(\"+DuctNetwork\");\n            Trace.Indent();\n            foreach (Element element in system.DuctNetwork)\n            {\n                LogUtility.WriteElement(element, false);\n                Trace.WriteLine(\"\");\n            }\n            Trace.Unindent();\n            WriteMEPSystem(system);\n        }\n\n        /// <summary>\n        /// Get element by its id and cast it to the specified type\n        /// </summary>\n        /// <param name=\"document\">the owner document of the element</param>\n        /// <param name=\"eid\">the id of the element</param>\n        /// <returns>the element of the specified type</returns>\n        public static T GetElement<T>(Document document, ElementId eid) where T : Autodesk.Revit.DB.Element\n        {\n            return document.GetElement(eid) as T;\n        }\n\n        /// <summary>\n        /// Write the information of a MEPSystem to the log file.\n        /// </summary>\n        /// <param name=\"system\">the MEP system whose information is to be written</param>\n        public static void WriteMEPSystem(MEPSystem system)\n        {\n            WriteElement(system.BaseEquipment);\n            Trace.Unindent();\n            Trace.WriteLine(\"+BaseEquipmentConnector\");\n            Trace.Indent();\n            WriteConnector(system.BaseEquipmentConnector);\n            Trace.Unindent();\n            Trace.WriteLine(\"+Elements\");\n            Trace.Indent();\n            foreach (Element element in system.Elements)\n            {\n                WriteElement(element);\n                Trace.WriteLine(\"\");\n            }\n            Trace.Unindent();\n            Trace.WriteLine(\"+ConnectorManager\");\n            Trace.Indent();\n            WriteConnectorManager(system.ConnectorManager);\n            Trace.Unindent();\n        }\n\n        /// <summary>\n        /// Write the information of a connector to the log file\n        /// </summary>\n        /// <param name=\"connector\">the connector whose information is to be written</param>\n        public static void WriteConnector(Connector connector)\n        {\n            if (connector == null)\n            {\n                Trace.WriteLine(\"null\"); return;\n            }\n            object connType = InvalidString;\n            object connDirection = InvalidString;\n            object connShape = InvalidString;\n            try { connShape = connector.Shape; }\n            catch { }\n            object connSize = InvalidString;\n            try { connSize = GetShapeInfo(connector); }\n            catch { }\n            object connLocation = GetLocation(connector);\n            object connAType = connector.ConnectorType;\n            object connIsConnected = InvalidString;\n            switch (connector.Domain)\n            {\n                case Domain.DomainElectrical:\n                    connType = connector.ElectricalSystemType;\n                    break;\n                case Domain.DomainHvac:\n                    connType = connector.DuctSystemType;\n                    connDirection = connector.Direction;\n                    connIsConnected = connector.IsConnected;\n                    break;\n                case Domain.DomainPiping:\n                    connType = connector.PipeSystemType;\n                    connDirection = connector.Direction;\n                    connIsConnected = connector.IsConnected;\n                    break;\n                case Domain.DomainUndefined:\n                default:\n                    connType = Domain.DomainUndefined;\n                    break;\n            }\n            Trace.WriteLine(\"Type: \" + connAType);\n            Trace.WriteLine(\"SystemType: \" + connType);\n            Trace.WriteLine(\"Direction: \" + connDirection);\n            Trace.WriteLine(\"Shape: \" + connShape);\n            Trace.WriteLine(\"Size: \" + connSize);\n            Trace.WriteLine(\"Location: \" + connLocation);\n            Trace.WriteLine(\"IsConnected: \" + connIsConnected);\n        }\n\n        /// <summary>\n        /// Write the information of a ConnectorManager to the log file\n        /// </summary>\n        /// <param name=\"connectorManager\">the ConnectorManager whose information is to be written</param>\n        public static void WriteConnectorManager(ConnectorManager connectorManager)\n        {\n            Trace.WriteLine(\"+Connectors\");\n            Trace.Indent();\n            WriteConnectorSet2(connectorManager.Connectors);\n            Trace.Unindent();\n            Trace.WriteLine(\"+UnusedConnectors\");\n            Trace.Indent();\n            WriteConnectorSet2(connectorManager.UnusedConnectors);\n            Trace.Unindent();\n        }\n\n        /// <summary>\n        /// Get the information string of a connector\n        /// </summary>\n        /// <param name=\"connector\">the connector to be read</param>\n        /// <returns>the information string of the connector</returns>\n        public static string GetConnectorId(Connector connector)\n        {\n            if (connector == null)\n            {\n                return \"null\";\n            }\n            ElementId ownerId = connector.Owner.Id;\n            string systemId = InvalidString;\n            try { systemId = connector.MEPSystem.Id.ToString(); }\n            catch { }\n            object connType = InvalidString;\n            object connDirection = InvalidString;\n            object connShape = InvalidString;\n            try { connShape = connector.Shape; }\n            catch { }\n            object connSize = InvalidString;\n            try { connSize = GetShapeInfo(connector); }\n            catch { }\n            object connLocation = GetLocation(connector);\n            object connAType = connector.ConnectorType;\n            object connIsConnected = InvalidString;\n            switch (connector.Domain)\n            {\n                case Domain.DomainElectrical:\n                    connType = connector.ElectricalSystemType;\n                    break;\n                case Domain.DomainHvac:\n                    connType = connector.DuctSystemType;\n                    connDirection = connector.Direction;\n                    connIsConnected = connector.IsConnected;\n                    break;\n                case Domain.DomainPiping:\n                    connType = connector.PipeSystemType;\n                    connDirection = connector.Direction;\n                    connIsConnected = connector.IsConnected;\n                    break;\n                case Domain.DomainUndefined:\n                default:\n                    connType = Domain.DomainUndefined;\n                    break;\n            }\n            return string.Format(\"[{0}]\\t[{1}]\\t[{2}]\\t[{3}]\\t[{4}]\\t[{5}]\\t[{6}]\\t[{7}]\\t[{8}]\\t\",\n                ownerId.ToString(), connType, connDirection, connShape, connSize, connLocation,\n                connAType, connIsConnected, systemId);\n        }\n\n        /// <summary>\n        /// Get the shape information string of a connector\n        /// </summary>\n        /// <param name=\"conn\">the element to be read</param>\n        /// <returns>the shape information string of the connector</returns>\n        private static string GetShapeInfo(Connector conn)\n        {\n            switch (conn.Shape)\n            {\n                case ConnectorProfileType.Invalid:\n                    break;\n                case ConnectorProfileType.Oval:\n                    break;\n                case ConnectorProfileType.Rectangular:\n                    return string.Format(\"{0}\\\" x {1}\\\"\", conn.Width, conn.Height);\n                case ConnectorProfileType.Round:\n                    return string.Format(\"{0}\\\"\", conn.Radius);\n                default:\n                    break;\n            }\n            return InvalidString;\n        }\n\n        /// <summary>\n        /// Get the location string of a connector\n        /// </summary>\n        /// <param name=\"conn\">the connector to be read</param>\n        /// <returns>the location information string of the connector</returns>\n        private static object GetLocation(Connector conn)\n        {\n            if (conn.ConnectorType == ConnectorType.Logical)\n            {\n                return InvalidString;\n            }\n            Autodesk.Revit.DB.XYZ origin = conn.Origin;\n            return string.Format(\"{0},{1},{2}\", origin.X, origin.Y, origin.Z);\n        }\n\n        /// <summary>\n        /// Write the information of a ConnectorSet to the log file.\n        /// </summary>\n        /// <param name=\"connectorSet\">the ConnectorSet whose information is to be written</param>\n        private static void WriteConnectorSet2(ConnectorSet connectorSet)\n        {\n            SortedDictionary<string, List<Connector>> connectors = new SortedDictionary<string, List<Connector>>();\n            foreach (Connector conn in connectorSet)\n            {\n                string connId = GetConnectorId(conn);\n                if (conn.ConnectorType == ConnectorType.Logical)\n                {\n                    foreach (Connector logLinkConn in conn.AllRefs)\n                    {\n                        connId += GetConnectorId(logLinkConn);\n                    }\n                }\n                if (!connectors.ContainsKey(connId))\n                {\n                    connectors.Add(connId, new List<Connector>());\n                }\n\n                connectors[connId].Add(conn);\n            }\n            foreach (string key in connectors.Keys)\n            {\n                foreach (Connector conn in connectors[key])\n                {\n                    WriteConnector(conn);\n                    Trace.WriteLine(\"+AllRefs\");\n                    Trace.Indent();\n                    WriteConnectorSet(conn.AllRefs);\n                    Trace.Unindent();\n                    Trace.WriteLine(\"\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Write the information of a ConnectorSet to the log file.\n        /// </summary>\n        /// <param name=\"connectorSet\">the mechanical system whose information is to be written</param>\n        private static void WriteConnectorSet(ConnectorSet connectorSet)\n        {\n            SortedDictionary<string, List<Connector>> connectors = new SortedDictionary<string, List<Connector>>();\n            foreach (Connector conn in connectorSet)\n            {\n                string connId = GetConnectorId(conn);\n                if (conn.ConnectorType == ConnectorType.Logical)\n                {\n                    foreach (Connector logLinkConn in conn.AllRefs)\n                    {\n                        connId += GetConnectorId(logLinkConn);\n                    }\n                }\n                if (!connectors.ContainsKey(connId))\n                {\n                    connectors.Add(connId, new List<Connector>());\n                }\n\n                connectors[connId].Add(conn);\n            }\n\n            foreach (string key in connectors.Keys)\n            {\n                foreach (Connector conn in connectors[key])\n                {\n                    WriteConnector(conn);\n                    Trace.WriteLine(\"\");\n                }\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_AutoRoute.rtf": "Summary: This sample demonstrates how to route a set of ducts and fittings between a base air supply equipment and 2 terminals.\n\nClasses: \nAutodesk.Revit.DB.Mechanical.MechanicalSystem\nAutodesk.Revit.DB.Mechanical.Duct\nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.Connector\nAutodesk.Revit.DB.Document\n\nProject Files: \nCommand.cs\nThis file contains the class Command which inherits from IExternalCommand. The function of it is to route a set of ducts and fittings between a base air supply equipment and 2 terminals.\n\nDescription: -\tTo create a mechanical system, use Document.Create.NewMechanicalSystem.\n-\tTo define the route, first find the bounding box that bounds all the three elements and then try the middle line, quarter lines on the X and Y axis as the trunk with a series of ducts that will be connected to the elements with fittings and ducts.\n-\tTo create duct, use Document.Create.NewDuct.\n-\tTo create fittings, use Document.Create.NewElbowFitting and Document.Create.NewTeeFitting.\n-\tTo make a connection between connectors, use Connector.ConnectTo\n\nInstructions: \n1.\tRun the command. (Before that, you can move the positions of terminals and equipment)\n2.\tA mechanical system and its duct work will be created automatically.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\AutoTagRooms\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n                                               ref string message,\n                                               ElementSet elements)\n        {\n            try\n            {\n                //Create a transaction\n                Transaction documentTransaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Document\");\n                documentTransaction.Start();\n                // Create a new instance of class RoomsData\n                RoomsData data = new RoomsData(commandData);\n\n                System.Windows.Forms.DialogResult result;\n\n                // Create a form to display the information of rooms\n                using (AutoTagRoomsForm roomsTagForm = new AutoTagRoomsForm(data))\n                {\n                    result = roomsTagForm.ShowDialog();\n                }\n\n                if (result == System.Windows.Forms.DialogResult.OK)\n                {\n                    documentTransaction.Commit();\n                    return Autodesk.Revit.UI.Result.Succeeded;\n                }\n                else\n                {\n                    documentTransaction.RollBack();\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n            }\n            catch (Exception ex)\n            {\n                // If there are something wrong, give error information and return failed\n                message = ex.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_AutoTagRooms.rtf": "Summary: This sample demonstrates three main features:\n1.\tHow to get all rooms in a specified level.\n2.\tHow to get all room tags in current document.\n3.\tHow to create new room tags with specified room tag type to auto tag all rooms in a specified level.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Architecture.Room\nAutodesk.Revit.DB.Architecture.RoomTag\nAutodesk.Revit.DB.Architecture.RoomTagType\nAutodesk.Revit.Creation.Document\n\n\nProject Files: \nCommand.cs\nThis file contains the class “Command” which inherits from “IExternalCommand” interface and implements the “Execute” method.\n\nRoomsData.cs\nIt contains a class named “RoomsData” which is used to get all rooms, get all room tags and create new room tags to auto tag all rooms in a level.\n\nDescription: Functionalities:\n-\tGet all rooms and room tags in active document and list all the rooms grouped by level with room tag count.\n-\tGet all available RoomTag types and Levels which have rooms in current project.\n-\tTag all rooms in a level with specified RoomTag type automatically.\n\nImplementations:\n-\tDocument.Plantopologies property can be used to get all Plan Topologies.\n-\tPlanTopology.Rooms property can be used to get all rooms in each PlanTopology. \n-\tAll the room tags can be retrieved by iterating all the elements in the active document.\n-\tTo tag a room, use the Document.Create.NewRoomTag method.\n\nInstructions: \n1.\tDraw some rooms in different levels. A sample project file AutoTagRooms.rvt is available in the sample’s folder.\n2.\tRun this command.\n3.\tA dialog will be shown to display all the levels that have rooms, all the room tag types, all rooms in the selected level and the count of room tags of each type.\n4.\tSelect a level and a room tag type. Click the “Auto Tag All” to auto tag the rooms in the level.\n5.\tClick “OK” button to accept the new created room tags or click “Cancel” button to abort them.\n\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\AvoidObstruction\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"External Tool\");\n            try\n            {\n                transaction.Start();\n            \n                Resolver resolver = new Resolver(commandData);\n                resolver.Resolve();                \n            }\n            catch (System.Exception e)\n            {\n                transaction.RollBack();\n                message += e.ToString();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            finally\n            {\n                transaction.Commit();\n            }\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        #endregion        \n    }\n}"
    },
    "documentation": {
      "ReadMe_AvoidObstruction.rtf": "Summary: This sample will demonstrate how to detect and resolve the obstructions of Pipe with Pipe, Pipe with Beam, or Pipe with Duct.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Document\nAutodesk.Revit.Creation.Document\nAutodesk.Revit.DB.Plumbing.Pipe\nAutodesk.Revit.DB.Mechanical.Duct\n\nProject Files: \nCommand.cs\nThis file contains a class Command and it implements interface IExternalCommand of Revit API.\n\nDetector.cs\nThis file contains a class Detector and it is used to detect the obstructions of a Line or a ray.\n\nResolver.cs\nThis file contains a class Resolver and it implements the algorithm to detect the obstruction and resolve it.\n\nSection.cs\nThis file contains a class Section and it presents an obstruction of a Pipe.\n\nDescription: This sample provides following functionalities.\n-\t It will detect and resolve the obstructions of pipes.\n-\tJust detect the obstructions of Pipe with Pipe, Pipe with Beam, or Pipe with Duct. Others such as Pipe with Wall (Stairs, Floor, etc) will be ignored.\n-\tWe just use pipe’s centerline to detect obstructions, and don’t consider the radius of the pipe.\n-\tJust re-route the pipes, don’t change the others (Beam, Duct).\n-\tHow to resolve the obstructions:\nn\tKeep the Pipe’s original direction not change.\nn\tSplit the Pipe’s line to some segments according to the obstructions detected.\nn\tRe-route the Pipes to avoid the obstructions.\n\nLimitation:\nØ\tThis sample can work well if all the elements (Pipes, Ducts, and Beams) located in the same plane (no need to be horizontal or vertical), it may not work well in other cases. \nØ\tIn order to simplify the problem, just use the pipe centerline to detect the obstruction, using pipe centerline to detect the obstruction will fail in following case:\n\nØ\tThe pipe’s length should be long enough to round the obstructions, otherwise, there will be error dialog when route the pipe. If the obstruction is too closer to the pipe’s ends, reroute the pipes to round the obstruction will show error dialog from Revit.\n\n\n\n\nInstructions: \n1.\tOpen Revit MEP application and then open the project file “AvoidObstruction.rvt” locates in sample directory. Then execute the command.\n2.\tAfter running this command, the result will be reflected to the current file."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\BeamAndSlabNewParameter\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData revit, \n                                               ref string message, \n                                               ElementSet elements)\n        {\n            // Set currently executable application to private variable m_revit\n            m_revit = revit.Application;           \n            m_elements = elements;\n\n            Transaction tran = new Transaction(m_revit.ActiveUIDocument.Document, \"BeamAndSlabNewParameter\");\n            tran.Start();\n\n            // Show UI\n            using (BeamAndSlabParametersForm displayForm = new BeamAndSlabParametersForm(this))\n            {\n                displayForm.ShowDialog();\n            }\n\n            tran.Commit();\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        /// <summary>\n        /// Add a new parameter, \"Unique ID\", to the beams and slabs\n        /// The following process should be followed: \n        /// Open the shared parameters file, via the Document.OpenSharedParameterFile method. \n        /// Access an existing group or create a new group, via the DefinitionFile.Groups property. \n        /// Access an existing or create a new external parameter definition, \n        /// via the DefinitionGroup.Definitions property. \n        /// Create a new Binding with the categories to which the parameter will be bound\n        /// using an InstanceBinding or a TypeBinding.\n        /// Finally add the binding and definition to the document\n        /// using the Document.ParameterBindings object.\n        /// </summary>\n        /// <returns>bool type, a value that signifies  if  add parameter was successful</returns>\n        public bool SetNewParameterToBeamsAndSlabs ()\n        {\n            //Open the shared parameters file \n            // via the private method AccessOrCreateExternalSharedParameterFile\n            DefinitionFile informationFile = AccessOrCreateExternalSharedParameterFile();\n\n            if (null == informationFile)\n            {\n                return false;\n            }\n    \n            // Access an existing or create a new group in the shared parameters file\n            DefinitionGroups informationCollections = informationFile.Groups;\n            DefinitionGroup  informationCollection  = null;\n\n            informationCollection = informationCollections.get_Item(\"MyParameters\");\n\n            if (null == informationCollection)\n            {\n                informationCollections.Create(\"MyParameters\");\n                informationCollection = informationCollections.get_Item(\"MyParameters\");\n            }\n\n            // Access an existing or create a new external parameter definition \n            // belongs to a specific group\n            Definition information = informationCollection.Definitions.get_Item(\"Unique ID\");\n                \n            if (null == information)\n            {\n               ExternalDefinitionCreationOptions ExternalDefinitionCreationOptions = new ExternalDefinitionCreationOptions(\"Unique ID\", Autodesk.Revit.DB.SpecTypeId.String.Text);\n               informationCollection.Definitions.Create(ExternalDefinitionCreationOptions);\n                information = informationCollection.Definitions.get_Item(\"Unique ID\");\n            }\n\n            // Create a new Binding object with the categories to which the parameter will be bound\n            CategorySet categories              = m_revit.Application.Create.NewCategorySet();\n            Category structuralFramingCategorie = null;\n            Category floorsClassification       = null;\n\n            // use category in instead of the string name to get category \n            structuralFramingCategorie = m_revit.ActiveUIDocument.Document.Settings.Categories.get_Item(BuiltInCategory.OST_StructuralFraming);\n            floorsClassification = m_revit.ActiveUIDocument.Document.Settings.Categories.get_Item(BuiltInCategory.OST_Floors);\n            categories.Insert(structuralFramingCategorie);\n            categories.Insert(floorsClassification);\n\n            InstanceBinding caseTying = m_revit.Application.Create.NewInstanceBinding(categories);\n            \n            // Add the binding and definition to the document\n            bool boundResult = m_revit.ActiveUIDocument.Document.ParameterBindings.Insert(information, caseTying);        \n\n            return boundResult;\n        }\n\n        /// <summary>\n        /// Set value(uuid) to Unique ID parameter\n        /// </summary>\n        public void SetValueToUniqueIDParameter()\n        {\n            ElementClassFilter beamClassFilter = new ElementClassFilter(typeof(FamilyInstance));\n            ElementClassFilter slabClassFilter = new ElementClassFilter(typeof(Floor));\n            ElementCategoryFilter beamTypeFilter = new ElementCategoryFilter(BuiltInCategory.OST_StructuralFraming);\n            ElementCategoryFilter slabTypeFilter = new ElementCategoryFilter(BuiltInCategory.OST_Floors);\n\n            LogicalAndFilter beamFilter = new LogicalAndFilter(beamClassFilter,beamTypeFilter);\n            LogicalAndFilter slabFilter = new LogicalAndFilter(slabClassFilter,slabTypeFilter);\n\n            LogicalOrFilter beamandslabFilter = new LogicalOrFilter(beamFilter, slabFilter);\n            IEnumerable<Element> elems = from elem in\n                                             new FilteredElementCollector(m_revit.ActiveUIDocument.Document).WherePasses(beamandslabFilter).ToElements()\n\n            select elem;\n\n            foreach (Element elem in elems)\n            {\n                // Find the parameter which is named \"Unique ID\" \n                // belongs to a specifically beam or slab\n                ParameterSet attributes = elem.Parameters;\n                IEnumerator iter = attributes.GetEnumerator();\n\n                iter.Reset();\n                while (iter.MoveNext())\n                {\n                    Parameter attribute = iter.Current as Autodesk.Revit.DB.Parameter;\n                    Definition information = attribute.Definition;\n\n                    if ((null != information)&&(\"Unique ID\" == information.Name) && (null == attribute.AsString()) )\n                    {\n                        // The shared parameter \"Unique ID\" then be set to a UUID\n                        Guid uuid = Guid.NewGuid();\n                        attribute.Set(uuid.ToString());\n                    }\n                }\n            }\n\n        }\n\n        /// <summary>\n        /// Display the value of Unique ID parameter in a list box\n        /// </summary>\n        /// <returns></returns>\n        public System.Collections.ArrayList SendValueToListBox()\n        {\n           ElementSet elements = new ElementSet();\n            foreach (ElementId elementId in m_revit.ActiveUIDocument.Selection.GetElementIds())\n            {\n               elements.Insert(m_revit.ActiveUIDocument.Document.GetElement(elementId));\n            }\n\n            // all the elements of current document\n            IEnumerator i = elements.GetEnumerator();  \n\n            ArrayList parameterValueArrangeBox = new ArrayList();\n\n            // if the selections include beams and slabs, find out their Unique ID's value for display\n            i.Reset();\n            bool moreElements = i.MoveNext();\n\n            while (moreElements)\n            {\n                // Get beams and slabs from selections\n                Element component = i.Current as Autodesk.Revit.DB.Element;\n\n                if (null == component)\n                {\n                    moreElements = i.MoveNext();\n                    continue;\n                }\n\n                if (null == component.Category)\n                {\n                    moreElements = i.MoveNext();\n                    continue;\n                }\n\n                if ((\"Structural Framing\" != component.Category.Name) &&\n                    (\"Floors\" != component.Category.Name))\n                {\n                    moreElements = i.MoveNext();\n                    continue;\n                }\n\n                // Get \"Unique ID\" parameter and display its value in a list box \n                ParameterSet attributes = component.Parameters;\n\n                foreach(object o in attributes) \n                {\n                    Parameter attribute = o as Parameter;\n\n                    if (\"Unique ID\" == attribute.Definition.Name)\n                    {    \n                        if (null == attribute.AsString())\n                        {\n                            break;\n                        }\n\n                        parameterValueArrangeBox.Add(attribute.AsString());\n                        break;\n                    }            \n                }\n                moreElements = i.MoveNext();\n            }    \n            return parameterValueArrangeBox;\n        }\n\n        /// <summary>\n        /// found the element which using the GUID \n        /// that was assigned to the shared parameter in the shared parameters file.\n        /// </summary>\n        /// <param name=\"UniqueIdValue\"></param>\n        public void FindElement(string UniqueIdValue)\n        {\n           ElementSet seleElements = new ElementSet();\n            foreach (ElementId elementId in m_revit.ActiveUIDocument.Selection.GetElementIds())\n            {\n               seleElements.Insert(m_revit.ActiveUIDocument.Document.GetElement(elementId));\n            }\n\n            // all the elements of current document\n            IEnumerator i = seleElements.GetEnumerator();\n\n\n            // if the selections include beams and slabs, \n            // find out the element using the select value for display\n            i.Reset();\n            bool moreElements = i.MoveNext();\n\n            while (moreElements)\n            {\n                // Get beams and slabs from selections\n                Element component = i.Current as Autodesk.Revit.DB.Element;\n\n                if (null == component)\n                {\n                    moreElements = i.MoveNext();\n                    continue;\n                }\n\n                if (null == component.Category)\n                {\n                    moreElements = i.MoveNext();\n                    continue;\n                }\n\n                if ((\"Structural Framing\" != component.Category.Name) &&\n                    (\"Floors\" != component.Category.Name))\n                {\n                    moreElements = i.MoveNext();\n                    continue;\n                }\n\n                // Get \"Unique ID\" parameter\n                ParameterSet attributes = component.Parameters;\n\n                foreach (object o in attributes)\n                {\n                    Parameter attribute = o as Parameter;\n\n                    if (\"Unique ID\" == attribute.Definition.Name)\n                    {\n                        if (null == attribute.AsString())\n                        {\n                            break;\n                        }\n\n                        // compare if the parameter's value is the same as the selected value.\n                        // Clear the SelElementSet and add the found element into it. \n                        // So this element will highlight in Revit UI\n                        if (UniqueIdValue == attribute.AsString())\n                        {\n                            seleElements.Clear();\n                            seleElements.Insert(component);\n                            return;\n                        }\n\n                        break;\n                    }\n                }\n\n                moreElements = i.MoveNext();\n            }\n\n        }\n\n        /// <summary>\n        /// Access an existing or create a new shared parameters file\n        /// </summary>\n        /// <returns>a shared parameters file </returns>\n        private DefinitionFile  AccessOrCreateExternalSharedParameterFile()\n        {    \n            // The Path of Revit.exe\n            string currentExecutablePath = System.Windows.Forms.Application.ExecutablePath;\n \n            // The path of ourselves shared parameters file\n            string sharedParameterFile = Path.GetDirectoryName(currentExecutablePath);\n\n            sharedParameterFile = sharedParameterFile + \"\\\\MySharedParameters.txt\";\n            \n            //Method's return\n            DefinitionFile informationFile = null; \n\n            // Check if the file is exit\n            System.IO.FileInfo documentMessage = new FileInfo(sharedParameterFile);\n            bool fileExist = documentMessage.Exists;\n\n            // Create file for external shared parameter since it does not exist\n            if (!fileExist)\n            {\n                FileStream fileFlow = File.Create(sharedParameterFile);\n                fileFlow.Close();    \n            }\n            \n            // Set  ourselves file to  the externalSharedParameterFile \n            m_revit.Application.SharedParametersFilename = sharedParameterFile;\n            informationFile = m_revit.Application.OpenSharedParameterFile();\n\n            return informationFile;\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_BeamAndSlabNewParameter.rtf": "Summary: This sample demonstrates how to add a shared instance parameter to beams and slabs, and uses GUID as the parameter’s value. Users also can use the value of the parameter to find the special element.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.DB.DefinitionFile \nAutodesk.Revit.DB.DefinitionGroups\nAutodesk.Revit.DB.DefinitionGroup\nAutodesk.Revit.DB.Definitions\nAutodesk.Revit.DB.Definition \nAutodesk.Revit.DB.CategorySet \nAutodesk.Revit.DB.InstanceBinding\nAutodesk.Revit.DB.Parameter\nAutodesk.Revit.UI.Selection.SelElementSet\n\nProject Files: \nBeamAndSlabNewParameter.cs\nThis is the main DLL source file. It contains the class Command which implements the interface IExternalCommand and implements adding shared parameter, storing GUID values and finding element functionality.\n\nBeamAndSlabNewParameterForm.cs\nThis file contains a class BeamAndSlabNewParameterForm that provides the user alternant UI.\n\nDescription: -\tThe adding shared parameter functionality in this sample is corresponding to “Manage->Project Parameters...->Add->Shared parameter (Radio button) ->Select” in Revit main program. If you want more detailed information about Shared parameter please refer to “Setting up Shared Parameters” topic in Revit help document.\n-\tThe shared parameter named Unique ID should be added to the Structural Framing and the Floor categories, so it can cover both beams and slabs. And then the Unique id should be set to a system generated UUID.\n-\tThe shared parameter should reside in a file named MySharedParameters.txt and in a parameter group named MyParameters. If the file does not exist it should be created. If it does exist then it should be reused.\n-\tDisplay, in a list box, the value of the Unique ID parameter if present for all the selected elements. \n-\tThe element should be found by the GUID which was listed in the list box. And in this sample we add the found element into the SelElementSet (Document.Selection.Elements) to let it highlight.\n\nInstructions: \n1.\tDraw a beam and a slab in the Revit and then run the command.\n2.\tFirst click the Add button in this sample UI.\n3.\tAfter return to Revit select some beams and slabs.\n4.\tThen run this command again and click Display Value button.\n5.\tSelect one item in left ListBox then click Find button. \n6.\tExpected result: return to Revit main program. The corresponding element whose Unique ID is same to the selected item will be highlighted.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\BoundaryConditions\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                               ref string message,\n                                               ElementSet elements)\n        {\n            try\n            {\n                //Retrieves the currently active project.\n                UIDocument doc = commandData.Application.ActiveUIDocument;\n\n                // must select a element first\n                ElementSet elementSet = new ElementSet();\n                foreach (ElementId elementId in doc.Selection.GetElementIds())\n                {\n                   elementSet.Insert(doc.Document.GetElement(elementId));\n                }\n                if (1 != elementSet.Size)\n                {\n                    message = \"Please select one structural element which is listed as follows: \\r\\n\" +\n                              \"Columns/braces/Beams/Walls/Wall Foundations/Slabs/Foundation Slabs\";\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n\n\n                Transaction tran = new Transaction(doc.Document, \"BoundaryConditions\");\n                tran.Start();\n\n                // deal with the selected element\n                foreach (Element element in elementSet)\n                {\n                    // the selected element must be a structural element\n                    if (!IsExpectedElement(element))\n                    {\n                        message = \"Please select one structural element which is listed as follows: \\r\\n\" +\n                                  \"Columns/braces/Beams/Walls/Wall Foundations/ \\r\\n\" +\n                                  \"Slabs/Foundation Slabs\";\n                        return Autodesk.Revit.UI.Result.Cancelled;\n                    }\n\n                    // prepare the relative data\n                    BoundaryConditionsData dataBuffer = new BoundaryConditionsData(element);\n\n                    // show UI\n                    using (BoundaryConditionsForm displayForm = new BoundaryConditionsForm(dataBuffer))\n                    {\n                        DialogResult result = displayForm.ShowDialog();\n                        if (DialogResult.OK == result)\n                        {\n                            tran.Commit();\n                            return Autodesk.Revit.UI.Result.Succeeded;\n                        }\n                        else if (DialogResult.Retry == result)\n                        {\n                            message = \"failed to create BoundaryConditions.\";\n                            tran.RollBack();\n                            return Autodesk.Revit.UI.Result.Failed;\n                        }\n                    }    \n                }\n\n                tran.RollBack();\n                // user cancel the operation\n                return Autodesk.Revit.UI.Result.Cancelled;                \n            }\n            catch (Exception e)\n            {\n                message = e.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n\n      /// <summary>\n      /// the selected element must be a structural Column/brace/Beam/Wall/Wall Foundation/Slab/Foundation Slab.\n      /// </summary>\n      /// <returns></returns>\n      private bool IsExpectedElement(Element element)\n      {\n         // judge the element's type. If it is any type of FamilyInstance, Wall, Floor or \n         // WallFoundation, then get judge if it has a AnalyticalModel.\n         AnalyticalToPhysicalAssociationManager assocManager = AnalyticalToPhysicalAssociationManager.GetAnalyticalToPhysicalAssociationManager(element.Document);\n         AnalyticalElement elemAnalytical = null;\n         if (assocManager != null)\n         {\n            ElementId associatedElementId = assocManager.GetAssociatedElementId(element.Id);\n            if (associatedElementId != ElementId.InvalidElementId)\n            {\n               Element associatedElement = element.Document.GetElement(associatedElementId);\n               if (associatedElement != null && associatedElement is AnalyticalElement)\n               {\n                  elemAnalytical = associatedElement as AnalyticalElement;\n               }\n            }\n         }\n         if (null == elemAnalytical)\n         {\n            return false;\n         }\n         FamilyInstance familyInstance = element as FamilyInstance;\n         if ((null != familyInstance) && (StructuralType.Footing == familyInstance.StructuralType))\n         {\n            return false; // if selected a isolated foundation not create BC\n         }\n\n         if (element is FamilyInstance || element is Wall || element is Floor || element is WallFoundation)\n         {\n            return true;\n         }\n\n         return false;\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_BoundaryConditions.rtf": "Summary: This sample shows to get BoundaryConditions’ parameters or create BoundaryConditons.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.BoundaryConditions\n\nProject Files: \nCommand.cs\nThis is the main DLL source file. It contains the class Command which implements interface IExternalCommand.\n\nBoundaryConditionsData.cs\nThis file contains class BoundaryConditionsData which prepares the needed data (the selected element type and its BC information) and creates BoundaryConditions.\n\nBCProperties.cs\nThis file contains three enumerations (BCType, BCState and BCTranslationRotation) and two classes (BCTypeAttribute, BCProperties). They prepare data for the PropertyGrid which is contained in BoundaryConditionsForm.\n\nUnitConversion.cs\nThis file contains a structure ConversionValue and a class ConversionValue. The structure defines the conversion rule between display value and internal value. The class is a value conversion dictionary, which stores some units and their corresponding ConversionValue.\n\nDescription: -\tOnly select one structure element.\n-\tIf the selected element has boundary conditions the parameters of the boundary conditions (BC) are presented. And users are also allowed to set these parameters with other valid values.\n-\tList all the Ids of BC whose host is the selected element in a list box.\n-\tAccording to the selected BC Id, the relevant BC Type, State and X, Y, Z translation/rotation will be displayed.\n-\tUser is not allowed to change the BC Type.\n-\tUser can set the State of BC to Fixed, Pinned, Roller or User (When different values are selected the X, Y or Z translation/rotation should do corresponding changes according to the Revit main program UI). \n-\tIf the User is selected as the current State, then X, Y or Z translation/rotation can be set to Fixed, Released or Spring.\n-\tIf Spring is selected for X, Y or Z translation/rotation, positive values can be inputted as the Spring Modulus (Show the unit of the value for users).\n-\tIf the selected element does not have a BC then create one.\n-\tSet the BC Type to Point, Line or Area according to the selected element. (Beams/Walls/ Wall Foundations have line BC; Columns/ braces have point BC; Slabs/Foundation Slabs have area BC)\n-\tOther initial parameters are set to be fixed.\n-\tThe user can change all the parameters values except the BC Type (refer to the details of last point)\n-\tWhen the user clicks the OK button the existing BC is updated or the new BC is created.\n-\tWe should use NewPointBoundaryConditions, NewLineBoundaryConditions and NewAreaBoundaryConditions methods of Autodesk.Revit.Creation.Document to create BC\n\nInstructions: \n1.\tOpen Revit Structure and draw a beam.\n2.\tSelect the beam and run the sample.\n3.\tSelect the property value in the PropertyGrid control in Form.\n4.\tIn sample’s main UI click the OK button.\n5.\tReturn to Revit main program you can see a line BoundaryConditions is created on the selected beam.\n\nOthers:\n-\tWe provide four additional files (Boundary Conditions Pinned.rfa, Boundary Conditions Fixed.rfa, Boundary Conditions Roller.rfa, and Boundary Conditions User.rfa). They are family files of Boundary Conditions. If you cannot draw any Boundary Conditions, pleas load these families first. And then setting the Family symbol for Boundary Conditions in Setting menu->Structural Settings->Boundary Conditions Settings.\n-\tOnly The following structural elements can have BC:\nColumns/braces/Isolated Foundations/ Beams/Walls/ Wall Foundations/ Slabs/Foundation Slabs\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\CreateBeamsColumnsBraces\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData revit, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            m_revit = revit.Application;\n            Transaction tran = new Transaction(m_revit.ActiveUIDocument.Document, \"CreateBeamsColumnsBraces\");\n            tran.Start();\n\n            try\n            {\n                //if initialize failed return Result.Failed\n                bool initializeOK = Initialize();\n                if (!initializeOK)\n                {\n                    tran.RollBack();\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                using (CreateBeamsColumnsBracesForm displayForm = new CreateBeamsColumnsBracesForm(this))\n                {\n                    if (displayForm.ShowDialog() != DialogResult.OK)\n                    {\n                        tran.RollBack();\n                        return Autodesk.Revit.UI.Result.Cancelled;\n                    }\n                }\n\n                tran.Commit();\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception ex)\n            {\n                message = ex.Message;\n                tran.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n\n        /// <summary>\n        /// check the number of floors is less than the number of levels\n        /// create beams, columns and braces according to selected types\n        /// </summary>\n        /// <param name=\"columnObject\">type of column</param>\n        /// <param name=\"beamObject\">type of beam</param>\n        /// <param name=\"braceObject\">type of brace</param>\n        /// <param name=\"floorNumber\">number of floor</param>\n        /// <returns>number of floors is less than the number of levels and create successfully then return true</returns>\n        public bool AddInstance(object columnObject, object beamObject, object braceObject, int floorNumber)\n        {\n            //whether floor number less than levels number\n            if (floorNumber >= levels.Count)\n            {\n                TaskDialog.Show(\"Revit\", \"The number of levels must be added.\");\n                return false;\n            }\n\n            FamilySymbol columnSymbol = columnObject as FamilySymbol;\n            FamilySymbol beamSymbol = beamObject as FamilySymbol;\n            FamilySymbol braceSymbol = braceObject as FamilySymbol;\n\n            //any symbol is null then the command failed\n            if (null == columnSymbol || null == beamSymbol || null == braceSymbol)\n            {\n                return false;\n            }\n\n            try\n            {\n                for (int k = 0; k < floorNumber; k++)    //iterate levels from lower one to higher\n                {\n                    Level baseLevel = levels.GetByIndex(k) as Level;\n                    Level topLevel = levels.GetByIndex(k + 1) as Level;\n\n                    int matrixXSize = m_matrixUV.GetLength(0);    //length of matrix's x range\n                    int matrixYSize = m_matrixUV.GetLength(1);    //length of matrix's y range\n\n                    //iterate coordinate both in x direction and y direction and create beams and braces\n                    for (int j = 0; j < matrixYSize; j++)\n                    {\n                        for (int i = 0; i < matrixXSize; i++)\n                        {\n                            //create beams and braces in x direction\n                            if (i != (matrixXSize - 1))\n                            {\n                                PlaceBrace(m_matrixUV[i, j], m_matrixUV[i + 1, j], baseLevel, topLevel, braceSymbol, true);\n                            }\n                            //create beams and braces in y direction\n                            if (j != (matrixYSize - 1))\n                            {\n                                PlaceBrace(m_matrixUV[i, j], m_matrixUV[i, j + 1], baseLevel, topLevel, braceSymbol, false);\n                            }\n                        }\n                    }\n                    for (int j = 0; j < matrixYSize; j++)\n                    {\n                        for (int i = 0; i < matrixXSize; i++)\n                        {\n                            //create beams and braces in x direction\n                            if (i != (matrixXSize - 1))\n                            {\n                                PlaceBeam(m_matrixUV[i, j], m_matrixUV[i + 1, j], baseLevel, topLevel, beamSymbol);\n                            }\n                            //create beams and braces in y direction\n                            if (j != (matrixYSize - 1))\n                            {\n                                PlaceBeam(m_matrixUV[i, j], m_matrixUV[i, j + 1], baseLevel, topLevel, beamSymbol);\n                            }\n                        }\n                    }\n                    //place column of this level\n                    foreach (Autodesk.Revit.DB.UV point2D in m_matrixUV)\n                    {\n                        PlaceColumn(point2D, columnSymbol, baseLevel, topLevel);\n                    }\n                }\n            }\n            catch\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// generate 2D coordinates of matrix according to parameters\n        /// </summary>\n        /// <param name=\"xNumber\">Number of Columns in the X direction</param>\n        /// <param name=\"yNumber\">Number of Columns in the Y direction</param>\n        /// <param name=\"distance\">Distance between columns</param>\n        public void CreateMatrix(int xNumber, int yNumber, double distance)\n        {\n            m_matrixUV = new Autodesk.Revit.DB.UV[xNumber, yNumber];\n\n            for (int i = 0; i < xNumber; i++)\n            {\n                for (int j = 0; j < yNumber; j++)\n                {\n                    m_matrixUV[i, j] = new Autodesk.Revit.DB.UV(i * distance, j * distance);\n                }\n            }\n        }\n\n        /// <summary>\n        /// iterate all the symbols of levels, columns, beams and braces\n        /// </summary>\n        /// <returns>A value that signifies if the initialization was successful for true or failed for false</returns>\n        private bool Initialize()\n        {\n            try\n            {\n\n                FilteredElementIterator i = new FilteredElementCollector(m_revit.ActiveUIDocument.Document).OfClass(typeof(Level)).GetElementIterator();\n                i.Reset();\n                while (i.MoveNext())\n                {\n                    //add level to list\n                    Level level = i.Current as Level;\n                    if (null != level)\n                    {\n                        levels.Add(level.Elevation, level);\n\n                    }\n                }\n\n                i = new FilteredElementCollector(m_revit.ActiveUIDocument.Document).OfClass(typeof(Family)).GetElementIterator();\n                while (i.MoveNext())\n                {\n                    Family f = i.Current as Family;\n                    if (f != null)\n                    {\n                        foreach (ElementId elementId in f.GetFamilySymbolIds())\n                        {\n                           object symbol = m_revit.ActiveUIDocument.Document.GetElement(elementId);\n                            FamilySymbol familyType = symbol as FamilySymbol;\n                            if (null == familyType)\n                            {\n                                continue;\n                            }\n                            if (null == familyType.Category)\n                            {\n                                continue;\n                            }\n\n                            //add symbols of beams and braces to lists \n                            string categoryName = familyType.Category.Name;\n                            if (\"Structural Framing\" == categoryName)\n                            {\n                                m_beamMaps.Add(new SymbolMap(familyType));\n                                m_braceMaps.Add(new SymbolMap(familyType));\n                            }\n                            else if (\"Structural Columns\" == categoryName)\n                            {\n                                m_columnMaps.Add(new SymbolMap(familyType));\n                            }\n                        }\n                    }\n                }\n\n\n\n\n            }\n            catch\n            {\n                return false;\n            }\n            return true;\n        }\n\n        /// <summary>\n        /// create column of certain type in certain position\n        /// </summary>\n        /// <param name=\"point2D\">2D coordinate of the column</param>\n        /// <param name=\"columnType\">type of column</param>\n        /// <param name=\"baseLevel\">the base level of the column</param>\n        /// <param name=\"topLevel\">the top level of the column</param>\n        private void PlaceColumn(Autodesk.Revit.DB.UV point2D, FamilySymbol columnType, Level baseLevel, Level topLevel)\n        {\n            //create column of certain type in certain level and start point \n            Autodesk.Revit.DB.XYZ point = new Autodesk.Revit.DB.XYZ(point2D.U, point2D.V, 0);\n            STRUCTURALTYPE structuralType;\n            structuralType = Autodesk.Revit.DB.Structure.StructuralType.Column;\n            if (!columnType.IsActive)\n               columnType.Activate();\n            FamilyInstance column = m_revit.ActiveUIDocument.Document.Create.NewFamilyInstance(point, columnType, topLevel, structuralType);\n\n            //set base level & top level of the column\n            if (null != column)\n            {\n                Parameter baseLevelParameter = column.get_Parameter(Autodesk.Revit.DB.BuiltInParameter.FAMILY_BASE_LEVEL_PARAM);\n                Parameter topLevelParameter = column.get_Parameter(Autodesk.Revit.DB.BuiltInParameter.FAMILY_TOP_LEVEL_PARAM);\n                Parameter topOffsetParameter = column.get_Parameter(BuiltInParameter.FAMILY_TOP_LEVEL_OFFSET_PARAM);\n                Parameter baseOffsetParameter = column.get_Parameter(BuiltInParameter.FAMILY_BASE_LEVEL_OFFSET_PARAM);\n\n                if (null != baseLevelParameter)\n                {\n                    Autodesk.Revit.DB.ElementId baseLevelId;\n                    baseLevelId = baseLevel.Id;\n                    baseLevelParameter.Set(baseLevelId);\n                }\n\n                if (null != topLevelParameter)\n                {\n                    Autodesk.Revit.DB.ElementId topLevelId;\n                    topLevelId = topLevel.Id;\n                    topLevelParameter.Set(topLevelId);\n                }\n\n                if (null != topOffsetParameter)\n                {\n                    topOffsetParameter.Set(0.0);\n                }\n\n                if (null != baseOffsetParameter)\n                {\n                    baseOffsetParameter.Set(0.0);\n                }\n            }\n        }\n\n        /// <summary>\n        /// create beam of certain type in certain position\n        /// </summary>\n        /// <param name=\"point2D1\">one point of the location line in 2D</param>\n        /// <param name=\"point2D2\">another point of the location line in 2D</param>\n        /// <param name=\"baseLevel\">the base level of the beam</param>\n        /// <param name=\"topLevel\">the top level of the beam</param>\n        /// <param name=\"beamType\">type of beam</param>\n        /// <returns>nothing</returns>\n        private void PlaceBeam(Autodesk.Revit.DB.UV point2D1, Autodesk.Revit.DB.UV point2D2, Level baseLevel, Level topLevel, FamilySymbol beamType)\n        {\n            double height = topLevel.Elevation;\n            Autodesk.Revit.DB.XYZ startPoint = new Autodesk.Revit.DB.XYZ(point2D1.U, point2D1.V, height);\n            Autodesk.Revit.DB.XYZ endPoint = new Autodesk.Revit.DB.XYZ(point2D2.U, point2D2.V, height);\n            Autodesk.Revit.DB.ElementId topLevelId = topLevel.Id;\n\n            Line line = Line.CreateBound(startPoint, endPoint);\n            STRUCTURALTYPE structuralType = Autodesk.Revit.DB.Structure.StructuralType.Beam;\n            if (!beamType.IsActive)\n               beamType.Activate();\n            m_revit.ActiveUIDocument.Document.Create.NewFamilyInstance(line, beamType, topLevel, structuralType);\n        }\n\n        /// <summary>\n        /// create brace of certain type in certain position between two adjacent columns\n        /// </summary>\n        /// <param name=\"point2D1\">one point of the location line in 2D</param>\n        /// <param name=\"point2D2\">another point of the location line in 2D</param>\n        /// <param name=\"baseLevel\">the base level of the brace</param>\n        /// <param name=\"topLevel\">the top level of the brace</param>\n        /// <param name=\"braceType\">type of beam</param>\n        /// <param name=\"isXDirection\">whether the location line is in x direction</param>\n        private void PlaceBrace(Autodesk.Revit.DB.UV point2D1, Autodesk.Revit.DB.UV point2D2, Level baseLevel, Level topLevel, FamilySymbol braceType, bool isXDirection)\n        {\n            //get the start points and end points of location lines of two braces\n            double topHeight = topLevel.Elevation;\n            double baseHeight = baseLevel.Elevation;\n            double middleElevation = (topHeight + baseHeight) / 2;\n            double middleHeight = (topHeight - baseHeight) / 2;\n            Autodesk.Revit.DB.XYZ startPoint = new Autodesk.Revit.DB.XYZ(point2D1.U, point2D1.V, middleElevation);\n            Autodesk.Revit.DB.XYZ endPoint = new Autodesk.Revit.DB.XYZ(point2D2.U, point2D2.V, middleElevation);\n            Autodesk.Revit.DB.XYZ middlePoint;\n\n            if (isXDirection)\n            {\n                middlePoint = new Autodesk.Revit.DB.XYZ((point2D1.U + point2D2.U) / 2, point2D2.V, topHeight);\n            }\n            else\n            {\n                middlePoint = new Autodesk.Revit.DB.XYZ(point2D2.U, (point2D1.V + point2D2.V) / 2, topHeight);\n            }\n\n            //create two brace and set their location line\n            STRUCTURALTYPE structuralType = Autodesk.Revit.DB.Structure.StructuralType.Brace;\n            Autodesk.Revit.DB.ElementId levelId = topLevel.Id;\n            Autodesk.Revit.DB.ElementId startLevelId = baseLevel.Id;\n            Autodesk.Revit.DB.ElementId endLevelId = topLevel.Id;\n\n            Line line1 = Line.CreateBound(startPoint, middlePoint);\n            if (!braceType.IsActive)\n               braceType.Activate();\n            FamilyInstance firstBrace = m_revit.ActiveUIDocument.Document.Create.NewFamilyInstance(line1, braceType, baseLevel, structuralType);\n\n            Parameter referenceLevel1 = firstBrace.get_Parameter(BuiltInParameter.INSTANCE_REFERENCE_LEVEL_PARAM);\n            if (null != referenceLevel1)\n            {\n                referenceLevel1.Set(levelId);\n            }\n\n            Line line2 = Line.CreateBound(endPoint, middlePoint);\n            FamilyInstance secondBrace = m_revit.ActiveUIDocument.Document.Create.NewFamilyInstance(line2, braceType, baseLevel, structuralType);\n\n            Parameter referenceLevel2 = secondBrace.get_Parameter(BuiltInParameter.INSTANCE_REFERENCE_LEVEL_PARAM);\n            if (null != referenceLevel2)\n            {\n                referenceLevel2.Set(levelId);\n            }\n        }\n    }\n\n    /// <summary>\n    /// assistant class contains the symbol and its name.\n    /// </summary>\n    public class SymbolMap\n    {\n        string m_symbolName = \"\";\n        FamilySymbol m_symbol = null;\n\n        /// <summary>\n        /// constructor without parameter is forbidden\n        /// </summary>\n        private SymbolMap()\n        {\n        }\n\n        /// <summary>\n        /// constructor\n        /// </summary>\n        /// <param name=\"symbol\">family symbol</param>\n        public SymbolMap(FamilySymbol symbol)\n        {\n            m_symbol = symbol;\n            string familyName = \"\";\n            if (null != symbol.Family)\n            {\n                familyName = symbol.Family.Name;\n            }\n            m_symbolName = familyName + \" : \" + symbol.Name;\n        }\n\n        /// <summary>\n        /// SymbolName property\n        /// </summary>\n        public string SymbolName\n        {\n            get\n            {\n                return m_symbolName;\n            }\n        }\n        /// <summary>\n        /// ElementType property\n        /// </summary>\n        public FamilySymbol ElementType\n        {\n            get\n            {\n                return m_symbol;\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_CreateBeamsColumnsBraces.rtf": "Summary: This sample demonstrates how to create a truss model which composes of columns, beams and braces automatically according to the user’s input.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.FamilySymbol\nAutodesk.Revit.Creation.Document.NewFamilyInstance(…) method\n\nProject Files: \nCreateBeamsColumnsBraces.vb\nThis is the main DLL source file. It contains the class Command which implements the interface IExternalCommand. Command class also collects all the symbols of levels, columns, beams & braces in current document and takes charge of creating a truss model.\n\nCreateBeamsColumnsBracesForm.vb\nThis file contains the CreateBeamsColumnsBracesForm class which is the sample’s UI to collect user’s input.\n\nDescription: -\tPresents a dialog to ask the user for the following information, and create truss model according to these information.\n-\tDistance between columns\n-\tNumber of Columns in the X direction\n-\tNumber of Columns in the Y direction\n-\tThe type of the columns\n-\tThe type of the beams\n-\tThe type of the braces\n-\tNumber of Floors\n-\tThe code should verify whether the number of floors is less than the number of levels since columns will be inserted from the level below to the level above. If there are not enough levels, notify the user the number of levels that must be added and exit the command with a failure message.\n-\tLevels can be retrieved by iterating through the document elements. \n-\tThe types that can be used for the beams, columns and braces can be located by searching the database for FamilySymbol objects that have material type of something other than undefined.\n-\tAll inserted beams, columns and braces must be specified as structural during creation.\n-\tTo insert a beam use the NewFamilyInstance method that takes a location and a reference direction. Location point should be the start of the beam and the reference direction should be a vector along the direction of the beam. Specify the structural type as beam.\n-\tTo insert a brace do the same as for a beam but specify brace as the structural type.\n\t\nInstructions: \n1.\tNo context to execute this sample, please directly run this command.\n2.\tUsers can input or select valid values in the sample UI (certainly, we can use the default values).\n3.\tThen click OK button.\n4.\tExpected result: return to Revit main program after run this sample, a Columns Beams and Braces truss model will present.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\CreateBeamSystem\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n\n            Transaction tran = new Transaction(commandData.Application.ActiveUIDocument.Document, \"CreateBeamSystem\");\n            tran.Start();\n\n            try\n            {\n                GeometryUtil.CreApp = commandData.Application.Application.Create;\n\n                // initialize precondition data of the program\n                BeamSystemData data = new BeamSystemData(commandData);\n                // display form to collect user's setting for beam system\n                using (BeamSystemForm form = new BeamSystemForm(data))\n                {\n                    if (form.ShowDialog() != DialogResult.OK)\n                    {\n                        tran.RollBack();\n                        return Autodesk.Revit.UI.Result.Cancelled;\n                    }\n                }\n\n                // create beam system using the parameters saved in BeamSystemData\n                BeamSystemBuilder builder = new BeamSystemBuilder(data);\n                builder.CreateBeamSystem();\n            }\n            catch (ErrorMessageException errorEx)\n            {\n                // checked exception need to show in error messagebox\n                message = errorEx.Message;\n                tran.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            catch(Exception ex)\n            {\n                // unchecked exception cause command failed\n                message = \"Command is failed for unexpected reason.\";\n                Trace.WriteLine(ex.ToString());\n                tran.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            tran.Commit();\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_CreateBeamSystem.rtf": "Summary: This sample demonstrates how to generate a beam system with the horizontal linear beams selection’s profile.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.BeamSystem\nAutodesk.Revit.DB.BeamSystem.LayoutRule\nAutodesk.Revit.DB.FamilySymbol\n\nProject Files: \nCommand.cs\nThis is the main DLL source file. It contains the class Command which implements interface IExternalCommand.\n\nBeamSystemBuilder.cs\nThis file contains a class BeamSystemBuilder which is used to create new instance of beam system.\n\nBeamSystemData.cs\nThis file contains a class BeamSystemData which is a mixed data class (save the data showed in UI and the data used to create beam system).\n\nDescription: -\tUser selects some linear beams which make a horizontal profile first, and create a beam system with this profile. Allow user change the layout method and beam type of the created beam system.\n-\tThe command displays a dialog with a preview window on the left and generic properties grid on the right. \n-\tThe generic property grid allows user to change the Layout method (clear spacing, fixed distance, fixed number and maximum spacing) and Beam type.\n-\tThe preview window displays the profile of the beam system and its direction. \n-\tBeam system’s direction is decided by the first line in the CurveArray that is taken as the parameter of profile in NewBeamSystem method.\n-\tBeam system’s layout method and beam type can be retrieved and modified through BeamType and LayoutRule properties of BeamSystem.\n-\tUse Autodesk.Revit.Creation.Document.NewBeamSystem(CurveArray) method to create BeamSystem.\n\nInstructions: \n1.\tDraw some horizontal linear beams with a closed profile.\n2.\tSelect these beams and run this command.\n3.\tOn the sample UI if you want change the beam system direction displayed in the picture box, please click the “Change Direction” button.\n4.\tUser can select Layout method and Beam type which listed in the right property grid in the sample UI.\n5.\tExpected result: return to Revit after run this sample a beam system will present in the Revit main program view.\n\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\CreateComplexAreaRein\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, \"Revit.SDK.Samples.CreateComplexAreaRein\");\n            trans.Start();\n            //initialize members\n            m_revit = revit;\n            m_currentDoc = revit.Application.ActiveUIDocument;\n            m_data = new AreaReinData(revit.Application.ActiveUIDocument.Document);\n\n            try\n            {\n                //check precondition and prepare necessary data to create AreaReinforcement.\n                Reference refer = null;\n                IList<Curve> curves = new List<Curve>();\n                Floor floor = InitFloor(ref refer, ref curves);\n\n                //ask for user's input\n                AreaReinData dataOnFloor = new AreaReinData(revit.Application.ActiveUIDocument.Document);\n                CreateComplexAreaReinForm createForm = new\n                    CreateComplexAreaReinForm(dataOnFloor);\n                if (createForm.ShowDialog() == DialogResult.OK)\n                {\n                    //define the Major Direction of AreaReinforcement,\n                    //we get direction of first Line on the Floor as the Major Direction\n                    Line firstLine = (Line)(curves[0]);\n                    Autodesk.Revit.DB.XYZ majorDirection = new Autodesk.Revit.DB.XYZ(\n                        firstLine.GetEndPoint(1).X - firstLine.GetEndPoint(0).X,\n                        firstLine.GetEndPoint(1).Y - firstLine.GetEndPoint(0).Y,\n                        firstLine.GetEndPoint(1).Z - firstLine.GetEndPoint(0).Z);\n\n                    //create AreaReinforcement by AreaReinforcement.Create() function\n                    DocCreator creator = m_revit.Application.ActiveUIDocument.Document.Create;\n                    ElementId areaReinforcementTypeId = AreaReinforcementType.CreateDefaultAreaReinforcementType(revit.Application.ActiveUIDocument.Document);\n                    ElementId rebarBarTypeId = RebarBarType.CreateDefaultRebarBarType(revit.Application.ActiveUIDocument.Document);\n                    ElementId rebarHookTypeId = RebarHookType.CreateDefaultRebarHookType(revit.Application.ActiveUIDocument.Document);\n                    AreaReinforcement areaRein = AreaReinforcement.Create(revit.Application.ActiveUIDocument.Document, floor, curves, majorDirection, areaReinforcementTypeId, rebarBarTypeId, rebarHookTypeId);\n\n                    //set AreaReinforcement and it's AreaReinforcementCurves parameters\n                    dataOnFloor.FillIn(areaRein);\n                    trans.Commit();\n                    return Autodesk.Revit.UI.Result.Succeeded;\n                }\n            }\n            catch (ApplicationException appEx)\n            {\n                message = appEx.Message;\n                trans.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            catch\n            {\n                message = \"Unknow Errors.\";\n                trans.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            trans.RollBack();\n            return Autodesk.Revit.UI.Result.Cancelled;\n        }\n\n        /// <summary>\n        /// ExternalCommandData\n        /// </summary>\n        public static ExternalCommandData CommandData\n        {\n            get\n            {\n                return m_revit;\n            }\n        }\n\n        /// <summary>\n        /// initialize member data, judge simple precondition\n        /// </summary>\n        private Floor InitFloor(ref Reference refer, ref IList<Curve> curves)\n        {\n           ElementSet elems = new ElementSet();\n            foreach (ElementId elementId in m_currentDoc.Selection.GetElementIds())\n            {\n               elems.Insert(m_currentDoc.Document.GetElement(elementId));\n            }\n            //selected 0 or more than 1 element\n            if (elems.Size != 1)\n            {\n                string msg = \"Please select exactly one slab.\";\n                ApplicationException appEx = new ApplicationException(msg);\n                throw appEx;\n            }\n            Floor floor = null;\n            foreach (object o in elems)\n            {\n                //selected one floor\n                floor = o as Floor;\n                if (null == floor)\n                {\n                    string msg = \"Please select exactly one slab.\";\n                    ApplicationException appEx = new ApplicationException(msg);\n                    throw appEx;\n                }\n            }\n            //check the shape is rectangular and get its edges\n            GeomHelper helper = new GeomHelper();\n            if (!helper.GetFloorGeom(floor, ref refer, ref curves))\n            {\n                ApplicationException appEx = new\n                    ApplicationException(\n                    \"Your selection is not a structural rectangular horizontal slab.\");\n                throw appEx;\n            }\n\n            return floor;\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_CreateComplexAreaRein.rtf": "Summary: This sample demonstrates how to create AreaReinforcement by Revit API and change its parameters.\n\nClasses: \nAutodesk.Revit.DB.Structural.AnalyticalModel\nAutodesk.Revit.DB.CurveArray\nAutodesk.Revit.DB.Line\nAutodesk.Revit.DB.Structural.AreaReinforcementType\nAutodesk.Revit.DB.ElementIterator\nAutodesk.Revit.DB.Solid\n\nProject Files:\nCreateComplexAreaRein.cs\nImplement the IExternalCommand interface, and show user how to create AreaReinforcment and change its parameters.\n\nAreaReinData.cs\nData and data manager of the AreaReinforcement. Store all kinds of AreaReinforcementType in current project and contain method use to change value of parameter.\n\nGeomUtil.cs\nThis file defines a class GeomUtil provides some common geometry estimate and calculates methods.\n\nParameterUtil.cs\nThis file defines a class ParameterUtil contains methods use to manage parameter. Such as find parameter by name and change value of parameter.\n\nDescription: -\tThis sample shows how to create AreaReinforcement by Revit API and set the parameter.\n-\tCreate slab reinforcement with all four layers, and with two rectangular curve loops, nested, so that we have a rectangular opening.\n-\tOn the interior 4 curves, set the override flag and flip the hooks on the top 2 layers to “up”.\n-\tThe type used for creating Area Reinforcement can be found in the project if user has loaded an AreaReinformentType in the project.\n-\tThe slab/wall’s geometry information is available as Geometry property of the Floor/Wall object.\n-\tThe property ‘layout rule’ can be found from the Area Reinforcement by using the following generic parameters: REBAR_SYSTEM_LAYOUT_RULE\n-\tThe properties of the AreaReinforcement Curve can be obtained by following generic parameters:\nName|Build in Parameter|\nOverride Area Reinforcement Settings|REBAR_SYSTEM_OVERRIDE|\nTop Major Hook Orientation|REBAR_SYSTEM_HOOK_ORIENT_TOP_DIR_1|\nTop Minor Hook Orientation|REBAR_SYSTEM_HOOK_ORIENT_TOP_DIR_2|\n\nInstructions: \n1.\tDraw a rectangular Slab (or open CreateComplexAreaRein.rvt) and Select it. \n2.\tRun this command.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\CreateDimensions\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            try\n            {\n                m_revit = revit;\n                Autodesk.Revit.DB.View view = m_revit.Application.ActiveUIDocument.Document.ActiveView;\n                View3D view3D = view as View3D;\n                if (null != view3D)\n                {\n                    message += \"Only create dimensions in 2D\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                ViewSheet viewSheet = view as ViewSheet;\n                if (null != viewSheet)\n                {\n                    message += \"Only create dimensions in 2D\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                //try too adds a dimension from the start of the wall to the end of the wall into the project\n                if (!AddDimension())\n                {\n                    message = m_errorMessage;\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception e)\n            {\n                message = e.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n\n        /// <summary>\n        /// find out the wall, insert it into a array list\n        /// </summary>\n        bool initialize()\n        {\n           ElementSet selections = new ElementSet();\n            foreach (ElementId elementId in m_revit.Application.ActiveUIDocument.Selection.GetElementIds())\n            {\n               selections.Insert(m_revit.Application.ActiveUIDocument.Document.GetElement(elementId));\n            }\n            //nothing was selected\n            if (0 == selections.Size)\n            {\n                m_errorMessage += \"Please select Basic walls\";\n                return false;\n            }\n\n            //find out wall\n            foreach (Autodesk.Revit.DB.Element e in selections)\n            {\n                Wall wall = e as Wall;\n                if (null != wall)\n                {\n                    if (\"Basic\" != wall.WallType.Kind.ToString())\n                    {\n                        continue;\n                    }\n                    m_walls.Add(wall);\n                }\n            }\n\n            //no wall was selected\n            if (0 == m_walls.Count)\n            {\n                m_errorMessage += \"Please select Basic walls\";\n                return false;\n            }\n            return true;\n        }\n\n      /// <summary>\n      /// find out every wall in the selection and add a dimension from the start of the wall to its end\n      /// </summary>\n      /// <returns>if add successfully, true will be returned, else false will be returned</returns>\n      public bool AddDimension()\n      {\n         if (!initialize())\n         {\n            return false;\n         }\n\n         Transaction transaction = new Transaction(m_revit.Application.ActiveUIDocument.Document, \"Add Dimensions\");\n         transaction.Start();\n         //get out all the walls in this array, and create a dimension from its start to its end\n         for (int i = 0; i < m_walls.Count; i++)\n         {\n            Wall wallTemp = m_walls[i] as Wall;\n            if (null == wallTemp)\n            {\n               continue;\n            }\n\n            //get location curve\n            Location location = wallTemp.Location;\n            LocationCurve locationline = location as LocationCurve;\n            if (null == locationline)\n            {\n               continue;\n            }\n\n            //New Line\n\n            Line newLine = null;\n\n            //get reference\n            ReferenceArray referenceArray = new ReferenceArray();\n\n            AnalyticalPanel analyticalModel = null;\n            Document document = wallTemp.Document;\n            AnalyticalToPhysicalAssociationManager assocManager = AnalyticalToPhysicalAssociationManager.GetAnalyticalToPhysicalAssociationManager(document);\n            if (assocManager != null)\n            {\n               ElementId associatedElementId = assocManager.GetAssociatedElementId(wallTemp.Id);\n               if (associatedElementId != ElementId.InvalidElementId)\n               {\n                  Element associatedElement = document.GetElement(associatedElementId);\n                  if (associatedElement != null && associatedElement is AnalyticalPanel)\n                  {\n                     analyticalModel = associatedElement as AnalyticalPanel;\n                  }\n               }\n            }\n            IList<Curve> activeCurveList = analyticalModel.GetOuterContour().ToList();\n            foreach (Curve aCurve in activeCurveList)\n            {\n               // find non-vertical curve from analytical model\n               if (aCurve.GetEndPoint(0).Z == aCurve.GetEndPoint(1).Z)\n                  newLine = aCurve as Line;\n               if (aCurve.GetEndPoint(0).Z != aCurve.GetEndPoint(1).Z)\n               {\n                  AnalyticalModelSelector amSelector = new AnalyticalModelSelector(aCurve);\n                  amSelector.CurveSelector = AnalyticalCurveSelector.StartPoint;\n\n                  referenceArray.Append(analyticalModel.GetReference(amSelector));\n               }\n               if (2 == referenceArray.Size)\n                  break;\n            }\n            if (referenceArray.Size != 2)\n            {\n               m_errorMessage += \"Did not find two references\";\n               return false;\n            }\n            try\n            {\n               //try to add new a dimension\n               Autodesk.Revit.UI.UIApplication app = m_revit.Application;\n               Document doc = app.ActiveUIDocument.Document;\n\n               Autodesk.Revit.DB.XYZ p1 = new XYZ(\n                   newLine.GetEndPoint(0).X + 5,\n                   newLine.GetEndPoint(0).Y + 5,\n                   newLine.GetEndPoint(0).Z);\n               Autodesk.Revit.DB.XYZ p2 = new XYZ(\n                   newLine.GetEndPoint(1).X + 5,\n                   newLine.GetEndPoint(1).Y + 5,\n                   newLine.GetEndPoint(1).Z);\n\n               Line newLine2 = Line.CreateBound(p1, p2);\n               Dimension newDimension = doc.Create.NewDimension(\n                 doc.ActiveView, newLine2, referenceArray);\n            }\n            // catch the exceptions\n            catch (Exception ex)\n            {\n               m_errorMessage += ex.ToString();\n               return false;\n            }\n         }\n         transaction.Commit();\n         return true;\n      }\n\n   }\n}"
    },
    "documentation": {
      "ReadMe_CreateDimensions.rtf": "Summary: This sample shows how to add a dimension to a selected structure wall from its start to its end.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.View\nAutodesk.Revit.DB.Wall\nAutodesk.Revit.DB.Dimension\nAutodesk.Revit.DB.CategorySet \nAutodesk.Revit.DB.Category \nAutodesk.Revit.UI.Selection.SelElementSet \nAutodesk.Revit.DB.Location \nAutodesk.Revit.DB.LocationCurve \nAutodesk.Revit.DB.Curve \nAutodesk.Revit.DB.Line\nAutodesk.Revit.DB.ReferenceArray\nAutodesk.Revit.DB.Options\nAutodesk.Revit.DB.Element\nAutodesk.Revit.DB.GeometryObjectArray\nAutodesk.Revit.DB.GeometryObject\n\nProject Files: \nCommand.vb\nIt contains the class Command which implements interface IExternalCommand. It also provides the function of adding a dimension to a selected wall from its start point to its end point.\n\nDescription: This sample provides following functionalities.\n-\tTo get one element by using its Id, use Docment.Element(ElementId) method.\n-\tRetrieve all the walls in the current project.\n-\tLoop to get every wall and perform following actions\n-\tGet the wall’s local curve and create a new bound line with its start point and end point\n-\tLoop the wall’s geometry elements and find the two upright lines beside the line   created in step 1. Create a reference array contains the references of the two lines\n-\tCreate a new bound line which is close and parallel to the line in step 1\n-\tCreate a dimension for the wall using the reference array as its bounds and the parallel line as its place\n\nInstructions: \n1.\tOpen Revit Structure.\n2.\tDraw some walls which have analytical model lines and select them\n3.\tMake sure that the active view is not a View3D or ViewSheet. \n4.\tExecute the external Command."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\CreateDuctworkStiffener\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message,\n            ElementSet elements)\n      {\n         m_document = commandData.Application.ActiveUIDocument.Document;\n         if (m_document.IsFamilyDocument)\n         {\n            message = \"Cannot create ductwork stiffener in family document\";\n            return Result.Failed;\n         }\n\n         //Get the ductwork in current project\n         FilteredElementCollector ductCollector = new FilteredElementCollector(m_document);\n         ductCollector.OfCategory(BuiltInCategory.OST_FabricationDuctwork).OfClass(typeof(FabricationPart));\n         if (ductCollector.GetElementCount() == 0)\n         {\n            message = \"The document does not contain fabrication ductwork\";\n            return Result.Failed;\n         }\n         m_ductwork = ductCollector.FirstElement() as FabricationPart;\n\n         //Get the ductwork stiffener type\n         FilteredElementCollector stiffenerTypeCollector = new FilteredElementCollector(m_document);\n         stiffenerTypeCollector.OfCategory(BuiltInCategory.OST_FabricationDuctworkStiffeners).OfClass(typeof(FamilySymbol));\n         if (stiffenerTypeCollector.GetElementCount() == 0)\n         {\n            message = \"The document does not contain stiffener family symbol\";\n            return Result.Failed;\n         }\n         IList<Element> allStiffenerTypes = stiffenerTypeCollector.ToElements();\n         String stiffenerTypeName = \"Duct Stiffener - External Rectangular Angle Iron: L Angle\";\n         foreach (Element element in allStiffenerTypes)\n         {\n            FamilySymbol f = element as FamilySymbol;\n            String name = f.Family.Name + \": \" + f.Name;\n            if (name == stiffenerTypeName)\n            {\n               m_stiffenerType = f;\n               break;\n            }\n         }\n         if (m_stiffenerType == null)\n         {\n            message = \"The stiffener type cannot be found in this document\";\n            return Result.Failed;\n         }\n\n         //Place the stiffener at ductwork middle point\n         m_distanceToHostEnd = 0.5 * m_ductwork.CenterlineLength;\n\n         try\n         {\n            using (Transaction transaction = new Transaction(m_document, \"Sample_CreateDuctworkStiffener\"))\n            {\n               transaction.Start();\n               if (!m_stiffenerType.IsActive)\n               {\n                  m_stiffenerType.Activate();\n                  m_document.Regenerate();\n               }\n               FamilyInstance stiffener = MEPSupportUtils.CreateDuctworkStiffener(m_document, m_stiffenerType.Id, m_ductwork.Id, m_distanceToHostEnd);\n               transaction.Commit();\n            }\n            return Result.Succeeded;\n         }\n         catch (Exception ex)\n         {\n            message = ex.Message;\n            return Result.Failed;\n         }\n      }\n\n      #endregion\n   }\n}"
    },
    "documentation": {
      "ReadMe_CreateDuctworkStiffener.rtf": "Summary: This sample demonstrates how to create ductwork stiffener.\n\nClasses: \nAutodesk.Revit.DB\nAutodesk.Revit.UI.IExternalCommand\n\nProject Files: \nCommand.cs\nIt contains the class Command which inherits from interface IExternalCommand and implements the Execute method.\n\nDescription: The sample implements IExternalCommand interface and utilizes the method CreateDuctworkStiffener to create stiffeners on ductwork.\n\nInstructions: \nOpen Revit application.\nLoad CreateStiffenerSample.rvt\nExecute the command.\nExpected result: A external stiffener is created at the midpoint of ductwork, and the stiffener size should match size of ductwork."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\CreateSimpleAreaRein\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, \"Revit.SDK.Samples.CreateSimpleAreaRein\");\n            trans.Start();\n            //initialize necessary data\n            m_revit = revit;\n            m_currentDoc = revit.Application.ActiveUIDocument;\n\n            //create AreaReinforcement\n            try\n            {\n                if (Create())\n                {\n                    trans.Start();\n                    return Autodesk.Revit.UI.Result.Succeeded;\n                }\n            }\n            catch (ApplicationException appEx)\n            {\n                TaskDialog.Show(\"Revit\", appEx.Message);\n                trans.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            catch\n            {\n                TaskDialog.Show(\"Revit\", \"Unknow Errors.\");\n                trans.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            trans.RollBack();\n            return Autodesk.Revit.UI.Result.Cancelled;\n        }\n\n        /// <summary>\n        /// ExternalCommandData\n        /// </summary>\n        public static ExternalCommandData CommandData\n        {\n            get\n            {\n                return m_revit;\n            }\n        }\n\n        /// <summary>\n        /// create simple AreaReinforcement on selected wall or floor\n        /// </summary>\n        /// <returns></returns>\n        private bool Create()\n        {\n           ElementSet elems = new ElementSet();\n            foreach (ElementId elementId in m_currentDoc.Selection.GetElementIds())\n            {\n               elems.Insert(m_currentDoc.Document.GetElement(elementId));\n            }\n\n            //selected 0 or more than 1 element\n            if (elems.Size != 1)\n            {\n                TaskDialog.Show(\"Error\", \"Please select exactly one wall or floor.\");\n                return false;\n            }\n            foreach (object o in elems)\n            {\n                //create on floor\n                Floor floor = o as Floor;\n                if (null != floor)\n                {\n                    bool flag = CreateAreaReinOnFloor(floor);\n                    return flag;\n                }\n\n                //create on wall\n                Wall wall = o as Wall;\n                if (null != wall)\n                {\n                    bool flag = CreateAreaReinOnWall(wall);\n                    return flag;\n                }\n\n                //selected element is neither wall nor floor\n                TaskDialog.Show(\"Error\", \"Please select exactly one wall or floor.\");\n            }\n            return false;\n        }\n\n        /// <summary>\n        /// create simple AreaReinforcement on horizontal floor\n        /// </summary>\n        /// <param name=\"floor\"></param>\n        /// <returns>is successful</returns>\n        private bool CreateAreaReinOnFloor(Floor floor)\n        {\n            GeomHelper helper = new GeomHelper();\n            Reference refer = null;\n            IList<Curve> curves = new List<Curve>();\n\n            //check whether floor is horizontal rectangular \n            //and prepare necessary to create AreaReinforcement\n            if (!helper.GetFloorGeom(floor, ref refer, ref curves))\n            {\n                ApplicationException appEx = new ApplicationException(\n                    \"Your selection is not a horizontal rectangular slab.\");\n                throw appEx;\n            }\n\n            AreaReinDataOnFloor dataOnFloor = new AreaReinDataOnFloor();\n            CreateSimpleAreaReinForm createForm =\n                new CreateSimpleAreaReinForm(dataOnFloor);\n\n            //allow use select parameters to create\n            if (createForm.ShowDialog() == DialogResult.OK)\n            {\n                //define the Major Direction of AreaReinforcement,\n                //we get direction of first Line on the Floor as the Major Direction\n                Line firstLine = (Line)(curves[0]);\n                Autodesk.Revit.DB.XYZ majorDirection = new Autodesk.Revit.DB.XYZ(\n                    firstLine.GetEndPoint(1).X - firstLine.GetEndPoint(0).X,\n                    firstLine.GetEndPoint(1).Y - firstLine.GetEndPoint(0).Y,\n                    firstLine.GetEndPoint(1).Z - firstLine.GetEndPoint(0).Z);\n\n                //Create AreaReinforcement\n                ElementId areaReinforcementTypeId = AreaReinforcementType.CreateDefaultAreaReinforcementType(m_revit.Application.ActiveUIDocument.Document);\n                ElementId rebarBarTypeId = RebarBarType.CreateDefaultRebarBarType(m_revit.Application.ActiveUIDocument.Document);\n                ElementId rebarHookTypeId = RebarHookType.CreateDefaultRebarHookType(m_revit.Application.ActiveUIDocument.Document);\n                AreaReinforcement areaRein = AreaReinforcement.Create(m_revit.Application.ActiveUIDocument.Document, floor, curves, majorDirection, areaReinforcementTypeId, rebarBarTypeId, rebarHookTypeId);\n\n                //set AreaReinforcement and it's AreaReinforcementCurves parameters\n                dataOnFloor.FillIn(areaRein);\n                return true;\n            }\n            return false;\n        }\n\n        /// <summary>\n        /// create simple AreaReinforcement on vertical straight rectangular wall\n        /// </summary>\n        /// <param name=\"wall\"></param>\n        /// <returns>is successful</returns>\n        private bool CreateAreaReinOnWall(Wall wall)\n        {\n            //make sure selected is basic wall\n            if (wall.WallType.Kind != WallKind.Basic)\n            {\n                TaskDialog.Show(\"Revit\", \"Selected wall is not a basic wall.\");\n                return false;\n            }\n\n            GeomHelper helper = new GeomHelper();\n            Reference refer = null;\n            IList<Curve> curves = new List<Curve>();\n            //check whether wall is vertical rectangular and analytical model shape is line\n            if (!helper.GetWallGeom(wall, ref refer, ref curves))\n            {\n                ApplicationException appEx = new ApplicationException(\n                    \"Your selection is not a structural straight rectangular wall.\");\n                throw appEx;\n            }\n\n            AreaReinDataOnWall dataOnWall = new AreaReinDataOnWall();\n            CreateSimpleAreaReinForm createForm = new\n                CreateSimpleAreaReinForm(dataOnWall);\n\n            //allow use select parameters to create\n            if (createForm.ShowDialog() == DialogResult.OK)\n            {\n                DocCreator creator = m_revit.Application.ActiveUIDocument.Document.Create;\n\n                //define the Major Direction of AreaReinforcement,\n                //we get direction of first Line on the Floor as the Major Direction\n                Line firstLine = (Line)(curves[0]);\n                Autodesk.Revit.DB.XYZ majorDirection = new Autodesk.Revit.DB.XYZ(\n                    firstLine.GetEndPoint(1).X - firstLine.GetEndPoint(0).X,\n                    firstLine.GetEndPoint(1).Y - firstLine.GetEndPoint(0).Y,\n                    firstLine.GetEndPoint(1).Z - firstLine.GetEndPoint(0).Z);\n\n                //create AreaReinforcement\n                IList<Curve> curveList = new List<Curve>();\n                foreach (Curve curve in curves)\n                {\n                    curveList.Add(curve);\n                }\n                ElementId areaReinforcementTypeId = AreaReinforcementType.CreateDefaultAreaReinforcementType(m_revit.Application.ActiveUIDocument.Document);\n                ElementId rebarBarTypeId = RebarBarType.CreateDefaultRebarBarType(m_revit.Application.ActiveUIDocument.Document);\n                ElementId rebarHookTypeId = RebarHookType.CreateDefaultRebarHookType(m_revit.Application.ActiveUIDocument.Document);\n                AreaReinforcement areaRein = AreaReinforcement.Create(m_revit.Application.ActiveUIDocument.Document, wall, curveList, majorDirection, areaReinforcementTypeId, rebarBarTypeId, rebarHookTypeId);\n                dataOnWall.FillIn(areaRein);\n                return true;\n            }\n            return false;\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_CreateSimpleAreaRein.rtf": "Summary: This sample uses to show how to create AreaReinforcement and change its parameters by Revit API.\n\nClasses: \nAutodesk.Revit.DB.Structure.AreaReinforcement\nAutodesk.Revit.DB.Floor\nAutodesk.Revit.DB.Wall\nAutodesk.Revit.DB.CurveArray\nAutodesk.Revit.DB.Structure.AreaReinforcementType\nAutodesk.Revit.DB.Parameter\n\nProject Files:\nCreateSimpleAreaRein.cs\nImplement the IExternalCommand interface, and show user how to create AreaReinforcment and change its parameters.\n\nAreaReinData.cs\nData and data manager of the AreaReinforcement. Store all kinds of AreaReinforcementType in current project and contain method use to change value of parameter.\n\nParameterUtil.cs\nThis file defines a class ParameterUtil contains methods use to manage parameter. Such as find parameter by name and change value of parameter.\n\nGeomHelper.cs\nThis file defines a class GeomHelper provides methods to get geometry data use to create AreaReinforcement on wall or slab.\n\nGeomUtil.cs\nThis file defines a class GeomUtil provides some common geometry estimate and calculates methods.\n\nDescription: This sample will provide the following functionality:\n-\tCreate an Area Reinforcement in a rectangular shape on the selected slab or wall (except Curtain-Wall and Stacked-Wall). The boundary would be the same as the slab/wall boundaries. The application can verify the boundary of the selected slab/wall is rectangular.\n-\tA dialog to the user asking for the following information:\n-\t Select type of Reinforcement which you want to create\n-\t Select “Layout Rule” in the “Construction” Parameter Group\n-\t All the Layers are listed in the “Layer” Parameter Group. There are four layers. Each layer should include “True” or “False” selection, select “True” means you can change the property of rebar on this layer, otherwise you can not change them.\n-\tThe type used for creating Area Reinforcement can be found in the project if user have loaded an AreaReinformentType in the project or have drawn an AreaReinforcement in current project.\n-\tThe slab/wall’s geometry information is available as Geometry property of the Floor/Wall object.\n-\tThe Parameters in “Layer” Parameter Group can be found from the Area Reinforcement by using the following generic parameters:\n-\tREBAR_SYSTEM_ACTIVE_BOTTOM_DIR_2, \n-\tREBAR_SYSTEM_ACTIVE_BOTTOM_DIR_1, \n-\tREBAR_SYSTEM_ACTIVE_TOP_DIR_2, \n-\tREBAR_SYSTEM_ACTIVE_TOP_DIR_1, \n-\tREBAR_SYSTEM_LAYOUT_RULE\n\nInstructions: \n1.\tDraw a structural horizontal rectangular Slab or a structural vertical rectangular Wall and Select it. (Or open RVT file for “CreateComplexAreaRein” sample)\n2.\tRun this command.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\CreateViewSection\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                                    ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            try\n            {\n                m_project = commandData.Application.ActiveUIDocument;\n\n                // Get the selected element and store it to data member.\n                if (!GetSelectedElement())\n                {\n                    message = m_errorInformation;\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                // Create a BoundingBoxXYZ instance which used in NewViewSection() method\n                if (!GenerateBoundingBoxXYZ())\n                {\n                    message = m_errorInformation;\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                // Create a section view. \n                Transaction transaction = new Transaction(m_project.Document, \"CreateSectionView\");\n                transaction.Start();\n                //ViewSection section = m_project.Document.Create.NewViewSection(m_box);\n                ElementId DetailViewId = ElementId.InvalidElementId;\n                IList<Element> elems = new FilteredElementCollector(m_project.Document).OfClass(typeof(ViewFamilyType)).ToElements();\n                foreach (Element e in elems)\n                {\n                    ViewFamilyType v = e as ViewFamilyType;\n\n                    if (v != null && v.ViewFamily == ViewFamily.Detail)\n                    {\n                        DetailViewId = e.Id;\n                        break;\n                    }\n                }\n                ViewSection section = ViewSection.CreateDetail(m_project.Document, DetailViewId, m_box);\n                if (null == section)\n                {\n                    message = \"Can't create the ViewSection.\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                // Modify some parameters to make it look better.\n                section.get_Parameter(BuiltInParameter.VIEW_DETAIL_LEVEL).Set(2);\n                transaction.Commit();\n\n                // If everything goes right, give successful information and return succeeded.\n                TaskDialog.Show(\"Revit\", \"Create view section succeeded.\");\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception e)\n            {\n                message = e.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n\n\n        /// <summary>\n        /// Get the selected element, and check whether it is a wall, a floor or a beam.\n        /// </summary>\n        /// <returns>true if the process succeed; otherwise, false.</returns>\n        Boolean GetSelectedElement()\n        {\n            // First get the selection, and make sure only one element in it.\n           ElementSet collection = new ElementSet();\n            foreach (ElementId elementId in m_project.Selection.GetElementIds())\n            {\n               collection.Insert(m_project.Document.GetElement(elementId));\n            }\n            if (1 != collection.Size)\n            {\n                m_errorInformation =\n                    \"Please select only one element, such as a wall, a beam or a floor.\";\n                return false;\n            }\n\n            // Get the selected element.\n            foreach (Autodesk.Revit.DB.Element e in collection)\n            {\n                m_currentComponent = e;\n            }\n\n            // Make sure the element to be a wall, beam or a floor.\n            if (m_currentComponent is Wall)\n            {\n                // Check whether the wall is a linear wall\n                LocationCurve location = m_currentComponent.Location as LocationCurve;\n                if (null == location)\n                {\n                    m_errorInformation = \"The selected wall should be linear.\";\n                    return false;\n                }\n                if (location.Curve is Line)\n                {\n                    m_type = SelectType.WALL;   // when the element is a linear wall\n                    return true;\n                }\n                else\n                {\n                    m_errorInformation = \"The selected wall should be linear.\";\n                    return false;\n                }\n            }\n\n            FamilyInstance beam = m_currentComponent as FamilyInstance;\n            if (null != beam && StructuralType.Beam == beam.StructuralType)\n            {\n                m_type = SelectType.BEAM;       // when the element is a beam\n                return true;\n            }\n\n            if (m_currentComponent is Floor)\n            {\n                m_type = SelectType.FLOOR;      // when the element is a floor.\n                return true;\n            }\n\n            // If it is not a wall, a beam or a floor, give error information.\n            m_errorInformation = \"Please select an element, such as a wall, a beam or a floor.\";\n            return false;\n        }\n\n\n        /// <summary>\n        /// Generate a BoundingBoxXYZ instance which used in NewViewSection() method\n        /// </summary>\n        /// <returns>true if the instance can be created; otherwise, false.</returns>\n        Boolean GenerateBoundingBoxXYZ()\n        {\n            Transaction transaction = new Transaction(m_project.Document, \"GenerateBoundingBox\");\n            transaction.Start();\n            // First new a BoundingBoxXYZ, and set the MAX and Min property.\n            m_box = new BoundingBoxXYZ();\n            m_box.Enabled = true;\n            Autodesk.Revit.DB.XYZ maxPoint = new Autodesk.Revit.DB.XYZ(LENGTH, LENGTH, 0);\n            Autodesk.Revit.DB.XYZ minPoint = new Autodesk.Revit.DB.XYZ(-LENGTH, -LENGTH, -HEIGHT);\n            m_box.Max = maxPoint;\n            m_box.Min = minPoint;\n\n            // Set Transform property is the most important thing.\n            // It define the Orgin and the directions(include RightDirection, \n            // UpDirection and ViewDirection) of the created view.\n            Transform transform = GenerateTransform();\n            if (null == transform)\n            {\n                return false;\n            }\n            m_box.Transform = transform;\n            transaction.Commit();\n\n            // If all went well, return true.\n            return true;\n        }\n\n\n        /// <summary>\n        /// Generate a Transform instance which as Transform property of BoundingBoxXYZ\n        /// </summary>\n        /// <returns>the reference of Transform, return null if it can't be generated</returns>\n        Transform GenerateTransform()\n        {\n            // Because different element have different ways to create Transform.\n            // So, this method just call corresponding method.\n            if (SelectType.WALL == m_type)\n            {\n                return GenerateWallTransform();\n            }\n            else if (SelectType.BEAM == m_type)\n            {\n                return GenerateBeamTransform();\n            }\n            else if (SelectType.FLOOR == m_type)\n            {\n                return GenerateFloorTransform();\n            }\n            else\n            {\n                m_errorInformation = \"The program should never go here.\";\n                return null;\n            }\n        }\n\n\n        /// <summary>\n        /// Generate a Transform instance which as Transform property of BoundingBoxXYZ, \n        /// when the user select a wall, this method will be called\n        /// </summary>\n        /// <returns>the reference of Transform, return null if it can't be generated</returns>\n        Transform GenerateWallTransform()\n        {\n            Transform transform = null;\n            Wall wall = m_currentComponent as Wall;\n\n            // Because the architecture wall and curtain wall don't have analytical Model lines.\n            // So Use Location property of wall object is better choice.\n            // First get the location line of the wall\n            LocationCurve location = wall.Location as LocationCurve;\n            Line locationLine = location.Curve as Line;\n            transform = Transform.Identity;\n\n            // Second find the middle point of the wall and set it as Origin property.\n            XYZ mPoint = XYZMath.FindMidPoint(locationLine.GetEndPoint(0), locationLine.GetEndPoint(1));\n            // midPoint is mid point of the wall location, but not the wall's.\n            // The different is the elevation of the point. Then change it.\n\n            Autodesk.Revit.DB.XYZ midPoint = new XYZ(mPoint.X, mPoint.Y, mPoint.Z + GetWallMidOffsetFromLocation(wall));\n\n            transform.Origin = midPoint;\n\n            // At last find out the directions of the created view, and set it as Basis property.\n            Autodesk.Revit.DB.XYZ basisZ = XYZMath.FindDirection(locationLine.GetEndPoint(0), locationLine.GetEndPoint(1));\n            Autodesk.Revit.DB.XYZ basisX = XYZMath.FindRightDirection(basisZ);\n            Autodesk.Revit.DB.XYZ basisY = XYZMath.FindUpDirection(basisZ);\n\n            transform.set_Basis(0, basisX);\n            transform.set_Basis(1, basisY);\n            transform.set_Basis(2, basisZ);\n            return transform;\n        }\n\n\n      /// <summary>\n      /// Generate a Transform instance which as Transform property of BoundingBoxXYZ, \n      /// when the user select a beam, this method will be called\n      /// </summary>\n      /// <returns>the reference of Transform, return null if it can't be generated</returns>\n      Transform GenerateBeamTransform()\n      {\n         Transform transform = null;\n         FamilyInstance instance = m_currentComponent as FamilyInstance;\n\n         // First check whether the beam is horizontal.\n         // In order to predigest the calculation, only allow it to be horizontal\n         double startOffset = instance.get_Parameter(BuiltInParameter.STRUCTURAL_BEAM_END0_ELEVATION).AsDouble();\n         double endOffset = instance.get_Parameter(BuiltInParameter.STRUCTURAL_BEAM_END1_ELEVATION).AsDouble();\n         if (-PRECISION > startOffset - endOffset || PRECISION < startOffset - endOffset)\n         {\n            m_errorInformation = \"Please select a horizontal beam.\";\n            return transform;\n         }\n\n         if (!(instance.Location is LocationCurve))\n         {\n            m_errorInformation = \"The program should never go here.\";\n            return transform;\n         }\n         Curve curve = (instance.Location as LocationCurve).Curve;\n         if (null == curve)\n         {\n            m_errorInformation = \"The program should never go here.\";\n            return transform;\n         }\n\n         // Now I am sure I can create a transform instance.\n         transform = Transform.Identity;\n\n         // Third find the middle point of the line and set it as Origin property.\n         Autodesk.Revit.DB.XYZ startPoint = curve.GetEndPoint(0);\n         Autodesk.Revit.DB.XYZ endPoint = curve.GetEndPoint(1);\n         Autodesk.Revit.DB.XYZ midPoint = XYZMath.FindMidPoint(startPoint, endPoint);\n         transform.Origin = midPoint;\n\n         // At last find out the directions of the created view, and set it as Basis property.   \n         Autodesk.Revit.DB.XYZ basisZ = XYZMath.FindDirection(startPoint, endPoint);\n         Autodesk.Revit.DB.XYZ basisX = XYZMath.FindRightDirection(basisZ);\n         Autodesk.Revit.DB.XYZ basisY = XYZMath.FindUpDirection(basisZ);\n\n         transform.set_Basis(0, basisX);\n         transform.set_Basis(1, basisY);\n         transform.set_Basis(2, basisZ);\n         return transform;\n      }\n\n\n      /// <summary>\n      /// Generate a Transform instance which as Transform property of BoundingBoxXYZ, \n      /// when the user select a floor, this method will be called\n      /// </summary>\n      /// <returns>the reference of Transform, return null if it can't be generated</returns>\n      Transform GenerateFloorTransform()\n      {\n         Transform transform = null;\n         Floor floor = m_currentComponent as Floor;\n\n         // First get the Analytical Model lines\n         AnalyticalPanel model = null;\n         Document document = floor.Document;\n         AnalyticalToPhysicalAssociationManager assocManager = AnalyticalToPhysicalAssociationManager.GetAnalyticalToPhysicalAssociationManager(document);\n         if (assocManager != null)\n         {\n            ElementId associatedElementId = assocManager.GetAssociatedElementId(floor.Id);\n            if (associatedElementId != ElementId.InvalidElementId)\n            {\n               Element associatedElement = document.GetElement(associatedElementId);\n               if (associatedElement != null && associatedElement is AnalyticalPanel)\n               {\n                  model = associatedElement as AnalyticalPanel;\n               }\n            }\n         }\n         if (null == model)\n         {\n            m_errorInformation = \"Please select a structural floor.\";\n            return transform;\n         }\n\n         CurveArray curves = m_project.Document.Application.Create.NewCurveArray();\n         IList<Curve> curveList = model.GetOuterContour().ToList();\n         foreach (Curve curve in curveList)\n         {\n            curves.Append(curve);\n         }\n\n         if (null == curves || true == curves.IsEmpty)\n         {\n            m_errorInformation = \"The program should never go here.\";\n            return transform;\n         }\n\n         // Now I am sure I can create a transform instance.\n         transform = Transform.Identity;\n\n         // Third find the middle point of the floor and set it as Origin property.\n         Autodesk.Revit.DB.XYZ midPoint = XYZMath.FindMiddlePoint(curves);\n         transform.Origin = midPoint;\n\n         // At last find out the directions of the created view, and set it as Basis property.\n         Autodesk.Revit.DB.XYZ basisZ = XYZMath.FindFloorViewDirection(curves);\n         Autodesk.Revit.DB.XYZ basisX = XYZMath.FindRightDirection(basisZ);\n         Autodesk.Revit.DB.XYZ basisY = XYZMath.FindUpDirection(basisZ);\n\n         transform.set_Basis(0, basisX);\n         transform.set_Basis(1, basisY);\n         transform.set_Basis(2, basisZ);\n         return transform;\n      }\n\n      Double GetWallMidOffsetFromLocation(Wall wall)\n        {\n            // First get the \"Base Offset\" property.\n            Double baseOffset = wall.get_Parameter(BuiltInParameter.WALL_BASE_OFFSET).AsDouble();\n\n            // Second get the \"Unconnected Height\" property. \n            Double height = wall.get_Parameter(BuiltInParameter.WALL_USER_HEIGHT_PARAM).AsDouble();\n\n            // Get the middle of of wall elevation from the wall location.\n            // The elevation of wall location equals the elevation of \"Base Constraint\" level\n            Double midOffset = baseOffset + height / 2;\n            return midOffset;\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposing)\n            {\n               (m_box as IDisposable)?.Dispose();\n            }\n        }\n        \n        public void Dispose()\n        {\n            Dispose(disposing: true);\n            GC.SuppressFinalize(this);\n        }\n    }\n\n    /// <summary>\n    /// Create a drafting view. \n    /// </summary>\n    [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n    [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n    public class CreateDraftingView : IExternalCommand\n    {\n        public Autodesk.Revit.UI.Result Execute(\n          ExternalCommandData commandData,\n          ref string message,\n          ElementSet elements)\n        {\n            try\n            {\n                Autodesk.Revit.DB.Document doc = commandData.Application.ActiveUIDocument.Document;\n                Transaction transaction = new Transaction(doc, \"CreateDraftingView\");\n                transaction.Start();\n\n                ViewFamilyType viewFamilyType = null;\n                FilteredElementCollector collector = new FilteredElementCollector(doc);\n                var viewFamilyTypes = collector.OfClass(typeof(ViewFamilyType)).ToElements();\n                foreach (Element e in viewFamilyTypes)\n                {\n                   ViewFamilyType v = e as ViewFamilyType;\n                   if (v.ViewFamily == ViewFamily.Drafting)\n                   {\n                      viewFamilyType = v;\n                      break;\n                   }\n                }\n                ViewDrafting drafting = ViewDrafting.Create(doc, viewFamilyType.Id);\n                if (null == drafting)\n                {\n                    message = \"Can't create the ViewDrafting.\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n                transaction.Commit();\n                TaskDialog.Show(\"Revit\", \"Create view drafting succeeded.\");\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception e)\n            {\n                message = e.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_CreateViewSection.rtf": "Summary: This sample shows how to generate a section view across the mid point of a linear element, such as a wall, floor or beam\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Document \nAutodesk.Revit.DB.BoundingBoxXYZ \nAutodesk.Revit.DB.Element\nAutodesk.Revit.DB.ElementSet\nAutodesk.Revit.DB.Wall\nAutodesk.Revit.DB.LocationCurve\nAutodesk.Revit.DB.Line\nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.Transform\nAutodesk.Revit.DB.Structural.AnalyticalModel\nAutodesk.Revit.DB.Structural.AnalyticalModelFrame\nAutodesk.Revit.DB.Curve\nAutodesk.Revit.DB.Floor\nAutodesk.Revit.DB.Structural.AnalyticalModelFloor\n\nProject Files: \nCommand.vb\nIt contains the class Command which implements interface IExternalCommand and the generating process of the section view across the mid point of a linear element. It also contains a class CreateDraftingView to create a drafting view.\n\nXYZMath.cs\nIt gives operations about point and vector presented by XYZ structure.\n\nDescription: This sample provides following functionalities.\n-\tRetrieve the selected linear element.\n-\tGenerate a BoundingBoxXYZ instance which will be used in NewViewSection() method\n-\tset its Max and Min property\n-\tGenerate a Transform instance as the Transform property of BoundingBoxXYZ which defines the Origin and the directions (including RightDirection, UpDirection and ViewDirection) of the created view\n-\tCreate the section view using the BoundingBoxXYZ.\n\nInstructions: \n1.\tOpen Revit Structure.\n2.\tDraw a linear element (wall, structural floor or structural beam).\n3.\tSelect the element and execute the external command Command.\nOr\n1.\tOpen Revit Structure.\n2.\tExecute the external command CreateDraftingView."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\CreateWallinBeamProfile\\CS",
    "key_code": {
      "class_name": "CreateWallinBeamProfile",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                                    ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Autodesk.Revit.UI.UIApplication revit = commandData.Application;\n            UIDocument project = revit.ActiveUIDocument;\n\n            // Get necessary data from revit.such as selected beams and level information\n            if (!PrepareData(project))\n            {\n                message = m_errorInformation;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            // Check whether the selected beams can make a a vertical profile\n            if (!IsVerticalProfile())\n            {\n                message = m_errorInformation;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            // Show the dialog for the user select the wall style\n            using (CreateWallinBeamProfileForm displayForm = new CreateWallinBeamProfileForm(this))\n            {\n                if (DialogResult.OK != displayForm.ShowDialog())\n                {\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n            }\n\n            // Create the walls using the outline generated by the beams.\n            if (!BeginCreate(project.Document))\n            {\n                message = m_errorInformation;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            // If everything goes right, return succeeded.\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n        #endregion IExternalCommand Members Implementation\n\n        /// <summary>\n        /// Create the walls using the outline generated by the beams\n        /// </summary>\n        /// <param name=\"project\"> A reference of current document</param>\n        /// <returns>true if no error happens; otherwise, false.</returns>\n        Boolean BeginCreate(Autodesk.Revit.DB.Document project)\n        {\n            //CurveArray curveArray = new CurveArray();   // store the curves used to create wall\n            List<Curve> curveArray = new List<Curve>();\n            Autodesk.Revit.DB.XYZ point;      // used to store the end point of the curve temporarily\n            Curve curve = m_lineCollection[0] as Curve;\n            curveArray.Add(curve);\n            point = curve.GetEndPoint(1);\n\n            // Sort the curves of analytical model and then add to curveArray.\n            // API asks for the curves should be in a sequence, deasil or anticlockwise\n            for (int i = 1; i < m_lineCollection.Count; i++)\n            {\n                foreach (Object o in m_lineCollection)\n                {\n                    Boolean isInclude = false;\n                    foreach (Curve j in curveArray)\n                    {\n                        if (o.Equals(j))\n                        {\n                            isInclude = true;\n                            break;\n                        }\n                    }\n                    if (true == isInclude)\n                    {\n                        continue;\n                    }\n\n                    curve = o as Curve;\n                    if (!EqualPoint(curve.GetEndPoint(0), point)\n                        && !EqualPoint(curve.GetEndPoint(1), point))\n                    {\n                        continue;\n                    }\n                    else if (EqualPoint(curve.GetEndPoint(0), point))\n                    {\n                        curveArray.Add(curve);\n                        point = curve.GetEndPoint(1);\n                        break;\n                    }\n                    else if (EqualPoint(curve.GetEndPoint(1), point))\n                    {\n                        curveArray.Add(curve);\n                        point = curve.GetEndPoint(0);\n                        break;\n                    }\n                    else\n                    {\n                        m_errorInformation = \"The program should never go here.\";\n                        return false;\n                    }\n                }\n            }\n\n            // If the program goes here, it means the beams can't form a profile.\n            if (curveArray.Count != m_lineCollection.Count)\n            {\n                m_errorInformation = \"There are more than one closed profile.\";\n                return false;\n            }\n\n            // Begin to create the wall.\n            Transaction t = new Transaction(project, Guid.NewGuid().GetHashCode().ToString());\n            t.Start();\n            Wall createdWall = Wall.Create(project, curveArray,\n                                            m_selectedWallType.Id, m_level.Id, m_isStructural);\n\n            if (null == createdWall)\n            {\n                m_errorInformation = \"Can not create the wall\";\n                return false;\n            }\n\n            // Modify some parameters of the created wall to make it look better.\n            Double baseOffset = FindBaseOffset();   // get the base offset from m_level\n            Double topOffset = FindTopOffset();     // get the top offset from m_level\n            Autodesk.Revit.DB.ElementId levelId = m_level.Id;\n            // Modify the \"Base Constraint\", \"Base Offset\", \"Top Constraint\" and \"Top Offset\"\n            //properties of the created wall.\n            createdWall.get_Parameter(BuiltInParameter.WALL_BASE_CONSTRAINT).Set(levelId);\n            createdWall.get_Parameter(BuiltInParameter.WALL_BASE_OFFSET).Set(baseOffset);\n            createdWall.get_Parameter(BuiltInParameter.WALL_HEIGHT_TYPE).Set(levelId);\n            createdWall.get_Parameter(BuiltInParameter.WALL_TOP_OFFSET).Set(topOffset);\n            t.Commit();\n            return true;\n        }\n\n      /// <summary>\n      /// Get necessary data from revit.such as selected beams, wall types and level information\n      /// </summary>\n      /// <param name=\"project\">A reference of current document</param>\n      /// <returns>true if no error happens; otherwise, false.</returns>\n      Boolean PrepareData(Autodesk.Revit.UI.UIDocument project)\n      {\n         // Search all the wall types in the Revit\n         FilteredElementCollector filteredElementCollector = new FilteredElementCollector(project.Document);\n         filteredElementCollector.OfClass(typeof(WallType));\n         m_wallTypeCollection = filteredElementCollector.Cast<WallType>().ToList<WallType>();\n\n         // Find the selection of beams in Revit\n         ElementSet selection = new ElementSet();\n         foreach (ElementId elementId in project.Selection.GetElementIds())\n         {\n            selection.Insert(project.Document.GetElement(elementId));\n         }\n\n         foreach (Autodesk.Revit.DB.Element e in selection)\n         {\n            FamilyInstance m = e as FamilyInstance;\n\n            // Use StructuralType property can judge whether it is a beam.\n            if (null != m && StructuralType.Beam == m.StructuralType)\n            {\n               m_beamCollection.Add(e);    // store the beams\n\n               if (!(m.Location is LocationCurve))\n               {\n                  m_errorInformation = \"The beam should have location curve.\";\n                  return false;\n               }\n               m_lineCollection.Add((m.Location as LocationCurve).Curve);\n            }\n         }\n         if (0 == m_beamCollection.Count)\n         {\n            m_errorInformation = \"Can not find any beams.\";\n            return false;\n         }\n\n         // Get the level which will be used in create method\n         FilteredElementCollector collector = new FilteredElementCollector(project.Document);\n         m_level = collector.OfClass(typeof(Level)).FirstElement() as Level;\n         return true;\n      }\n\n      /// <summary>\n      /// Check whether the selected beams can make a a vertical profile.\n      /// </summary>\n      /// <returns>true if selected beams create a vertical profile; otherwise, false.</returns>\n      Boolean IsVerticalProfile()\n        {\n            // First check whether all the beams are in a same vertical plane\n            if (!IsInVerticalPlane())\n            {\n                m_errorInformation = \"Not all the beam in a vertical plane.\";\n                return false;\n            }\n\n            // Second check whether a closed profile can be created by all the beams\n            if (!CanCreateProfile())\n            {\n                m_errorInformation = \"All the beams should create only one profile.\";\n                return false;\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Check whether the input two points are the same\n        /// </summary>\n        /// <param name=\"first\"> The first point</param>\n        /// <param name=\"second\"> The second point</param>\n        /// <returns>true if two points are the same; otherwise, false</returns>\n        Boolean EqualPoint(Autodesk.Revit.DB.XYZ first, Autodesk.Revit.DB.XYZ second)\n        {\n            if ((-PRECISION <= first.X - second.X && PRECISION >= first.X - second.X)\n                && (-PRECISION <= first.Y - second.Y && PRECISION >= first.Y - second.Y)\n                && (-PRECISION <= first.Z - second.Z && PRECISION >= first.Z - second.Z))\n            {\n                return true;\n            }\n            return false;\n        }\n\n        /// <summary>\n        /// Check whether the two double data are the same\n        /// </summary>\n        /// <param name=\"first\">The first double data</param>\n        /// <param name=\"second\">The second double data</param>\n        /// <returns>true if two double data are the same; otherwise, false</returns>\n        Boolean EqualDouble(Double first, Double second)\n        {\n            if (-PRECISION <= first - second && PRECISION >= first - second)\n            {\n                return true;\n            }\n            return false;\n        }\n\n        /// <summary>\n        /// Check whether all the beams are in a same vertical plane\n        /// </summary>\n        /// <returns>true if they are in same vertical plane; otherwise, false</returns>\n        Boolean IsInVerticalPlane()\n        {\n            Autodesk.Revit.DB.XYZ startPoint = new Autodesk.Revit.DB.XYZ();\n            Autodesk.Revit.DB.XYZ endPoint = new Autodesk.Revit.DB.XYZ();\n            int sign = 0;               // used as a symbol,\n            Double slope = 0;           // record slope of the lines' projection on X-Y plane\n\n            // When all the beams in the X-Z plane or Y-Z plane, the deal is especial\n            // So I use 3 ways to judge whether all the beams are in same vertical plane\n            Curve curve = m_lineCollection[0] as Curve;\n            startPoint = curve.GetEndPoint(0);\n            endPoint = curve.GetEndPoint(1);\n            if (EqualDouble(startPoint.X, endPoint.X))\n            {\n                sign = 1;           // All the beams may be in Y-Z plane\n            }\n            else if (EqualDouble(startPoint.Y, endPoint.Y))\n            {\n                sign = 2;           // All the beams may be in X-Z plane\n            }\n            else\n            {\n                slope = (startPoint.Y - endPoint.Y) / (startPoint.X - endPoint.X);\n            }\n\n            // Begin to compare each analytical line and judge whether they are in same vertical plane\n            for (int i = 1; i < m_lineCollection.Count; i++)\n            {\n                curve = m_lineCollection[i] as Curve;\n                startPoint = curve.GetEndPoint(0);\n                endPoint = curve.GetEndPoint(1);\n\n                switch (sign)\n                {\n                    case 0:     // Judge whether the slope of beam's projection on X-Y plane are same.\n                        Double anotherSlope = (startPoint.Y - endPoint.Y) / (startPoint.X - endPoint.X);\n                        if (!EqualDouble(slope, anotherSlope))\n                        {\n                            return false;\n                        }\n                        break;\n                    case 1:     // Judge whether the beams are in Y-Z plane\n                        if (!EqualDouble(startPoint.X, endPoint.X))\n                        {\n                            return false;\n                        }\n                        break;\n                    case 2:     // Judge whether the beams are in X-Z plane\n                        if (!EqualDouble(startPoint.Y, endPoint.Y))\n                        {\n                            return false;\n                        }\n                        break;\n                    default:    // If it go here, there must be something error.\n                        TaskDialog.Show(\"Revit\", \"Should not come here.\");\n                        break;\n                }\n            }\n            return true;\n        }\n\n        /// <summary>\n        /// Check whether a closed profile can be created by all the beams\n        /// </summary>\n        /// <returns>true if one profile found; otherwise, false</returns>\n        Boolean CanCreateProfile()\n        {\n            // Only allow all the beams compose a close profile.\n            // As we all know, a close profile is composed by borders and points,\n            // and the number of borders should be equal to points'.\n            // So, the judgement use this way. \n            Autodesk.Revit.DB.XYZ startPoint = new Autodesk.Revit.DB.XYZ();\n            Autodesk.Revit.DB.XYZ endPoint = new Autodesk.Revit.DB.XYZ();\n            Curve curve = null;\n            ArrayList pointArray = new ArrayList();\n            bool hasStartpoint;      // indicate whether start point is in the array\n            bool hasEndPoint;        // indicate whether end point is in the array\n\n            // Find out all the points in the curves, the same point only count once.\n            for (int i = 0; i < m_lineCollection.Count; i++)\n            {\n                curve = m_lineCollection[i] as Curve;\n                startPoint = curve.GetEndPoint(0);\n                endPoint = curve.GetEndPoint(1);\n                hasStartpoint = false;  // Judge whether start point has been counted.\n                hasEndPoint = false;    // Judge whether end point has been counted.\n\n                if (0 == pointArray.Count)\n                {\n                    pointArray.Add(startPoint);\n                    pointArray.Add(endPoint);\n                    continue;\n                }\n\n                // Judge whether the points of this curve have been counted.\n                foreach (Object o in pointArray)\n                {\n                    Autodesk.Revit.DB.XYZ point = (Autodesk.Revit.DB.XYZ)o;\n                    if (EqualPoint(startPoint, point))\n                    {\n                        hasStartpoint = true;\n                    }\n                    if (EqualPoint(endPoint, point))\n                    {\n                        hasEndPoint = true;\n                    }\n                }\n\n                // If not, add the points into the array.\n                if (!hasStartpoint)\n                {\n                    pointArray.Add(startPoint);\n                }\n                if (!hasEndPoint)\n                {\n                    pointArray.Add(endPoint);\n                }\n            }\n\n            if (pointArray.Count != m_lineCollection.Count)\n            {\n                return false;\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Find the offset from the elevation of the lowest point to m_level's elevation \n        /// </summary>\n        /// <returns> The length of the offset </returns>\n        Double FindBaseOffset()\n        {\n            // Initialize the data.\n            Double baseOffset = 0;  // the offset from the m_level's elevation\n            Double lowestElevation = 0; // the elevation of the lowest point\n            Curve curve = m_lineCollection[0] as Curve;\n            lowestElevation = curve.GetEndPoint(0).Z;\n\n            // Find out the elevation of the lowest point.\n            foreach (Curve c in m_lineCollection)\n            {\n                if (c.GetEndPoint(0).Z < lowestElevation)\n                {\n                    lowestElevation = c.GetEndPoint(0).Z;\n                }\n                if (c.GetEndPoint(1).Z < lowestElevation)\n                {\n                    lowestElevation = c.GetEndPoint(1).Z;\n                }\n            }\n\n            // Count the offset and return.\n            baseOffset = lowestElevation - m_level.Elevation;\n            return baseOffset;\n        }\n\n        /// <summary>\n        /// Find the offset from the elevation of the highest point to m_level's elevation\n        /// </summary>\n        /// <returns>The length of the offset</returns>\n        Double FindTopOffset()\n        {\n            // Initialize the data\n            Double topOffset = 0;   // the offset from the m_level's elevation\n            Double highestElevation = 0;    // the elevation of the highest point\n            Curve curve = m_lineCollection[0] as Curve;\n            highestElevation = curve.GetEndPoint(0).Z;\n\n            // Find out the elevation of the highest point.\n            foreach (Curve c in m_lineCollection)\n            {\n                if (c.GetEndPoint(0).Z > highestElevation)\n                {\n                    highestElevation = c.GetEndPoint(0).Z;\n                }\n                if (c.GetEndPoint(1).Z > highestElevation)\n                {\n                    highestElevation = c.GetEndPoint(1).Z;\n                }\n            }\n\n            // Count the offset and return.\n            topOffset = highestElevation - m_level.Elevation;\n            return topOffset;\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_CreateWallinBeamProfile.rtf": "Summary: This sample demonstrates how to generate a wall which has the profile of beams selection. When the command is executed, a dialog should appear that contains a drop-down list for all types of wall and a check box for whether the walls are structural. Default should be checked.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.UI.Elements.FamilyInstance\nAutodesk.Revit.DB.Curve\nAutodesk.Revit.DB.Document \n\nProject Files: \nCreateWallinBeamProfile.cs\nThe main DLL source file contains the class Command which implements interface IExternalCommand. Get necessary data from revit. Check whether the selected beams are made of a colsed and vertical profile. Show the dialog for the user to select the wall type. Create the walls using the outline generated by the beams. \n\nCreateWallinBeamProfileForm.cs\nThis file contains a form class which includes a drop-down list for all types of wall and a check box for whether the walls are structural.\n\nDescription: This sample should provide the following functionalities:\n-\tAdd a command that takes a selection of beams that makes a vertical profile and make a profiled wall using the outline generated by the beams.\n-\tThis sample should be worked for only a selection of beams that makes a vertical profile.\n-\tWhen the command is executed a dialog should appear that contains the following:\n-\tA drop-down list for all types of wall.\n-\tA check box for whether the walls are structural. Default should be checked.\n-\tUsers should be able to select wall type which will be used in creation. And the users can choose to create structural or architecture walls also.\n-\tUsers select the required items from these boxes. When OK is clicked the dialog should be dismissed and a profile wall should be created using the outline generated by the beams.\n\nInstructions: \n1.\tRun Revit Structure.\n2.\tPrepare your Revit project.\nOpen or new a Revit project and draw some beams which made of a closed and vertical profile. A sample project file CreateWallinBeamProfile.rvt is available in the sample’s folder\n3.\tSelect these beams and run this command.\n4.\tUser can select wall type and choose whether the wall is structural.\n5.\tClick the OK button.\n6.\tApplication will create a profiled wall using the beams selection’s outline."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\CreateWallsUnderBeams\\CS",
    "key_code": {
      "class_name": "CreateWallsUnderBeams",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                                    ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Autodesk.Revit.UI.UIApplication revit = commandData.Application;\n            UIDocument project = revit.ActiveUIDocument;\n\n            // Find the selection of beams in Revit\n            ElementSet selection = new ElementSet();\n            foreach (ElementId elementId in project.Selection.GetElementIds())\n            {\n               selection.Insert(project.Document.GetElement(elementId));\n            }\n            foreach (Autodesk.Revit.DB.Element e in selection)\n            {\n                FamilyInstance m = e as FamilyInstance;\n                if (null != m)\n                {\n                    if (StructuralType.Beam == m.StructuralType)\n                    {\n                        // Store all the beams the user selected in Revit\n                        m_beamCollection.Add(e);\n                    }\n                }\n            }\n            if (0 == m_beamCollection.Count)\n            {\n                message = \"Can not find any beams.\";\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            // Make sure all the beams have horizontal analytical line\n            if (!CheckBeamHorizontal())\n            {\n                message = m_errorInformation;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            // Search all the wall types in the Revit\n            FilteredElementCollector filteredElementCollector = new FilteredElementCollector(project.Document);\n            filteredElementCollector.OfClass(typeof(WallType));\n            m_wallTypeCollection = filteredElementCollector.Cast<WallType>().ToList<WallType>();\n\n            // Show the dialog for the user select the wall style\n            using (CreateWallsUnderBeamsForm displayForm = new CreateWallsUnderBeamsForm(this))\n            {\n                if (DialogResult.OK != displayForm.ShowDialog())\n                {\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n            }\n\n            // Create the walls which along and under the path of the beams.\n            if (!BeginCreate(project.Document))\n            {\n                message = m_errorInformation;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            // If everything goes right, return succeeded.\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n      #endregion IExternalCommand Members Implementation\n\n      /// <summary>\n      /// Create the walls which along and under the path of the selected beams\n      /// </summary>\n      /// <param name=\"project\"> A reference of current document</param>\n      /// <returns>true if there is no error in process; otherwise, false.</returns>\n      Boolean BeginCreate(Autodesk.Revit.DB.Document project)\n      {\n         // Begin to create walls along and under each beam\n         for (int i = 0; i < m_beamCollection.Count; i++)\n         {\n            // Get each selected beam.\n            FamilyInstance m = m_beamCollection[i] as FamilyInstance;\n            if (null == m)\n            {\n               m_errorInformation = \"The program should not go here.\";\n               return false;\n            }\n\n            // the wall will be created using beam's model line as path.   \n            if (!(m.Location is LocationCurve))\n            {\n               m_errorInformation = \"The beam should have location curve.\";\n               return false;\n            }\n            Curve beamCurve = (m.Location as LocationCurve).Curve;\n\n            // Get the level using the beam's reference level\n            Autodesk.Revit.DB.ElementId levelId = m.get_Parameter(BuiltInParameter.INSTANCE_REFERENCE_LEVEL_PARAM).AsElementId();\n            m_level = project.GetElement(levelId) as Level;\n            if (null == m_level)\n            {\n               m_errorInformation = \"The program should not go here.\";\n               return false;\n            }\n\n            Transaction t = new Transaction(project, Guid.NewGuid().GetHashCode().ToString());\n            t.Start();\n            Wall createdWall = Wall.Create(project, beamCurve, m_selectedWallType.Id,\n                                            m_level.Id, 10, 0, true, m_isStructural);\n            if (null == createdWall)\n            {\n               m_errorInformation = \"Can not create the walls\";\n               return false;\n            }\n\n            // Modify some parameters of the created wall to make it look better.\n            Double offset = beamCurve.GetEndPoint(0).Z - m_level.Elevation;\n            createdWall.get_Parameter(BuiltInParameter.WALL_BASE_CONSTRAINT).Set(levelId);\n            createdWall.get_Parameter(BuiltInParameter.WALL_BASE_OFFSET).Set(offset - 3000 / 304.8);\n            createdWall.get_Parameter(BuiltInParameter.WALL_HEIGHT_TYPE).Set(levelId);\n            t.Commit();\n         }\n         return true;\n      }\n\n\n      /// <summary>\n      /// Check whether all the beams have horizontal analytical line \n      /// </summary>\n      /// <returns>true if each beam has horizontal analytical line; otherwise, false.</returns>\n      Boolean CheckBeamHorizontal()\n      {\n         for (int i = 0; i < m_beamCollection.Count; i++)\n         {\n            // Get the analytical curve of each selected beam.\n            // And check if Z coordinate of start point and end point of the curve are same.\n            FamilyInstance m = m_beamCollection[i] as FamilyInstance;\n            Curve beamCurve = m.Location is LocationCurve ? (m.Location as LocationCurve).Curve : null;\n            if (null == beamCurve)\n            {\n               m_errorInformation = \"The beam should have location curve.\";\n               return false;\n            }\n            else if ((PRECISION <= beamCurve.GetEndPoint(0).Z - beamCurve.GetEndPoint(1).Z)\n                || (-PRECISION >= beamCurve.GetEndPoint(0).Z - beamCurve.GetEndPoint(1).Z))\n            {\n               m_errorInformation = \"Please only select horizontal beams.\";\n               return false;\n            }\n         }\n         return true;\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_CreateWallsUnderBeams.rtf": "Summary: This sample demonstrates how to generate simple rectangular wall(s) under the beam(s) selection. When the command is executed a dialog should appear that contains a drop-down list for all types of wall and a check box for whether the walls are structural. Default should be checked.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.Document \n\nProject Files: \nCreateWallsUnderBeams.cs\nThe main DLL source file which contains the class Command which implements interface IExternalCommand. Find the selection of beams in Revit; Make sure all the beams have horizontal analytical line; Show the dialog for the user to select the wall style and Create walls which along and under the path of the beams. \n\nCreateWallsUnderBeamsForm.cs\nThis file contains a form class contains a drop-down list for all types of wall and a check box for whether the walls are structural.\n\nDescription: This sample should provide the following functionalities:\n-\tAdd a command that takes a selection of beams that makes a vertical profile and make a profiled wall using the outline generated by the beams.\n-\tThis command will take a selection of beams and draw simple rectangular walls along and under the path of the beams.\n-\tThis sample should be worked for only horizontal beam objects.\n-\tWhen the command is executed a dialog should appear that contains the following:\n-\tA drop-down list for all types of wall.\n-\tA check box for whether the walls are structural. Default should be checked.\n-\tUsers should be able to select the wall type which will be used in creation. And users can choose to create structural or architecture walls also.\n-\tUsers select the required items from these boxes. When OK is clicked. The dialog should be dismissed and simple rectangular walls should be created along and under the path of the selected beams.\n\nInstructions: \n1.\tOpen Revit Structure and draw some beams.\n2.\tSelect the beams and run this command.\n3.\tUsers can select the wall type and choose whether the wall(s) is structural.\n4.\tClick the OK button.\n5.\tApplication will create simple rectangular wall(s) under the beams."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\CurvedBeam\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            m_revit = commandData.Application;\n            Transaction tran = new Transaction(m_revit.ActiveUIDocument.Document, \"CurvedBeam\");\n            tran.Start();\n\n            // if initialize failed return Result.Failed\n            bool initializeOK = Initialize();\n            if (!initializeOK)\n            {\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            // pop up new beam form\n            CurvedBeamForm displayForm = new CurvedBeamForm(this);\n            displayForm.ShowDialog();\n            tran.Commit();\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n        #endregion\n\n\n        /// <summary>\n        /// iterate all the symbols of levels and beams\n        /// </summary>\n        /// <returns>A value that signifies if the initialization was successful for true or failed for false</returns>\n        private bool Initialize()\n        {\n            try\n            {\n                ElementClassFilter levelFilter = new ElementClassFilter(typeof(Level));\n                ElementClassFilter famFilter = new ElementClassFilter(typeof(Family));\n                LogicalOrFilter orFilter = new LogicalOrFilter(levelFilter, famFilter);\n                FilteredElementCollector collector = new FilteredElementCollector(m_revit.ActiveUIDocument.Document);\n                FilteredElementIterator i = collector.WherePasses(orFilter).GetElementIterator();\n                i.Reset();\n                bool moreElement = i.MoveNext();\n                while (moreElement)\n                {\n                    object o = i.Current;\n\n                    // add level to list\n                    Level level = o as Level;\n                    if (null != level)\n                    {\n                        m_levels.Add(new LevelMap(level));\n                        goto nextLoop;\n                    }\n\n                    // get\n                    Family f = o as Family;\n                    if (null == f)\n                    {\n                        goto nextLoop;\n                    }\n\n                    foreach (ElementId elementId in f.GetFamilySymbolIds())\n                    {\n                       object symbol = m_revit.ActiveUIDocument.Document.GetElement(elementId);\n                        FamilySymbol familyType = symbol as FamilySymbol;\n                        if (null == familyType)\n                        {\n                            goto nextLoop;\n                        }\n                        if (null == familyType.Category)\n                        {\n                            goto nextLoop;\n                        }\n\n                        // add symbols of beams and braces to lists \n                        string categoryName = familyType.Category.Name;\n                        if (\"Structural Framing\" == categoryName)\n                        {\n                            m_beamMaps.Add(new SymbolMap(familyType));\n                        }\n                    }\n                nextLoop:\n                    moreElement = i.MoveNext();\n                }\n            }\n            catch (Exception ex)\n            {\n                throw new Exception(ex.ToString());\n            }\n            return true;\n        }\n\n        /// <summary>\n        /// create an horizontal arc instance with specified z coordinate value\n        /// </summary>\n        public Arc CreateArc(double z)\n        {\n            Autodesk.Revit.DB.XYZ center = new Autodesk.Revit.DB.XYZ(0, 0, z);\n            double radius = 20.0;\n            double startAngle = 0.0;\n            double endAngle = 5.0;\n            Autodesk.Revit.DB.XYZ xAxis = new Autodesk.Revit.DB.XYZ(1, 0, 0);\n            Autodesk.Revit.DB.XYZ yAxis = new Autodesk.Revit.DB.XYZ(0, 1, 0);\n            return Arc.Create(center, radius, startAngle, endAngle, xAxis, yAxis);\n        }\n\n\n        /// <summary>\n        /// create a horizontal partial ellipse instance with specified z coordinate value\n        /// </summary>\n        public Curve CreateEllipse(double z)\n        {\n            Autodesk.Revit.DB.XYZ center = new Autodesk.Revit.DB.XYZ(0, 0, z);\n            double radX = 30;\n            double radY = 50;\n            Autodesk.Revit.DB.XYZ xVec = new Autodesk.Revit.DB.XYZ(1, 0, 0);\n            Autodesk.Revit.DB.XYZ yVec = new Autodesk.Revit.DB.XYZ(0, 1, 0);\n            double param0 = 0.0;\n            double param1 = 3.1415;\n            Curve ellpise = Ellipse.CreateCurve(center, radX, radY, xVec, yVec, param0, param1);\n            m_revit.ActiveUIDocument.Document.Regenerate();\n            return ellpise;\n        }\n\n\n        /// <summary>\n        /// create a horizontal nurbspline instance with specified z coordinate value\n        /// </summary>\n        public Curve CreateNurbSpline(double z)\n        {\n            // create control points with same z value\n            List<XYZ> ctrPoints = new List<XYZ>();\n            Autodesk.Revit.DB.XYZ xyz1 = new Autodesk.Revit.DB.XYZ(-41.887503610431267, -9.0290629129782189, z);\n            Autodesk.Revit.DB.XYZ xyz2 = new Autodesk.Revit.DB.XYZ(-9.27600019217055, 0.32213521486563046, z);\n            Autodesk.Revit.DB.XYZ xyz3 = new Autodesk.Revit.DB.XYZ(9.27600019217055, 0.32213521486563046, z);\n            Autodesk.Revit.DB.XYZ xyz4 = new Autodesk.Revit.DB.XYZ(41.887503610431267, 9.0290629129782189, z);\n\n            ctrPoints.Add(xyz1); ctrPoints.Add(xyz2); ctrPoints.Add(xyz3);\n            ctrPoints.Add(xyz4);\n\n            IList<double> weights = new List<double>();\n            double w1 = 1, w2 = 1, w3 = 1, w4 = 1;\n            weights.Add(w1); weights.Add(w2); weights.Add(w3);\n            weights.Add(w4);\n\n            IList<double> knots = new List<double>();\n            double k0 = 0, k1 = 0, k2 = 0, k3 = 0, k4 = 34.425128, k5 = 34.425128, k6 = 34.425128, k7 = 34.425128;\n\n            knots.Add(k0); knots.Add(k1); knots.Add(k2); knots.Add(k3);\n            knots.Add(k4); knots.Add(k5); knots.Add(k6);\n            knots.Add(k7);\n\n            Curve detailNurbSpline = NurbSpline.CreateCurve(3, knots,ctrPoints, weights);\n            m_revit.ActiveUIDocument.Document.Regenerate();\n\n            return detailNurbSpline;\n        }\n\n\n        /// <summary>\n        /// create a curved beam\n        /// </summary>\n        /// <param name=\"fsBeam\">beam type</param>\n        /// <param name=\"curve\">Curve of this beam.</param>\n        /// <param name=\"level\">beam's reference level</param>\n        /// <returns></returns>\n        public bool CreateCurvedBeam(FamilySymbol fsBeam, Curve curve, Level level)\n        {\n            FamilyInstance beam;\n            try\n            {\n               if (!fsBeam.IsActive)\n                  fsBeam.Activate();\n                beam = m_revit.ActiveUIDocument.Document.Create.NewFamilyInstance(curve, fsBeam, level, StructuralType.Beam);\n                if (null == beam)\n                {\n                    return false;\n                }\n\n                // get beam location curve\n                LocationCurve beamCurve = beam.Location as LocationCurve;\n                if (null == beamCurve)\n                {\n                    return false;\n                }\n            }\n            catch (Exception ex)\n            {\n                TaskDialog.Show(\"Revit\", ex.ToString());\n                return false;\n            }\n\n            // regenerate document\n            m_revit.ActiveUIDocument.Document.Regenerate();\n            return true;\n        }\n    }\n\n\n    /// <summary>\n    /// assistant class contains symbol and it's name\n    /// </summary>\n    public class SymbolMap\n    {\n        #region SymbolMap class member variables\n        string m_symbolName = \"\";\n        FamilySymbol m_symbol = null;\n        #endregion\n\n\n        /// <summary>\n        /// constructor without parameter is forbidden\n        /// </summary>\n        private SymbolMap()\n        {\n            // no operation \n        }\n\n\n        /// <summary>\n        /// constructor\n        /// </summary>\n        /// <param name=\"symbol\">family symbol</param>\n        public SymbolMap(FamilySymbol symbol)\n        {\n            m_symbol = symbol;\n            string familyName = \"\";\n            if (null != symbol.Family)\n            {\n                familyName = symbol.Family.Name;\n            }\n            m_symbolName = familyName + \" : \" + symbol.Name;\n        }\n\n\n        /// <summary>\n        /// SymbolName property\n        /// </summary>\n        public string SymbolName\n        {\n            get\n            {\n                return m_symbolName;\n            }\n        }\n\n\n        /// <summary>\n        /// ElementType property\n        /// </summary>\n        public FamilySymbol ElementType\n        {\n            get\n            {\n                return m_symbol;\n            }\n        }\n    }\n\n\n    /// <summary>\n    /// assistant class contains level and it's name\n    /// </summary>\n    public class LevelMap\n    {\n        #region LevelMap class member variable\n        string m_levelName = \"\";\n        Level m_level = null;\n        #endregion\n\n\n        #region LevelMap Constructors\n        /// <summary>\n        /// constructor without parameter is forbidden\n        /// </summary>\n        private LevelMap()\n        {\n            // no operation\n        }\n\n\n        /// <summary>\n        /// constructor\n        /// </summary>\n        /// <param name=\"level\">level</param>\n        public LevelMap(Level level)\n        {\n            m_level = level;\n            m_levelName = level.Name;\n        }\n        #endregion\n\n\n        #region LevelMap properties\n        /// <summary>\n        /// LevelName property\n        /// </summary>\n        public string LevelName\n        {\n            get\n            {\n                return m_levelName;\n            }\n        }\n\n        /// <summary>\n        /// Level property\n        /// </summary>\n        public Level Level\n        {\n            get\n            {\n                return m_level;\n            }\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_CurvedBeam.rtf": "Summary: This sample demonstrates how to create curved beam, this sample can create three types of curved beam: arc, ellipse and nurbspline.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Creation.Document\nAutodesk.Revit.DB.Symbols.FamilySymbol\nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.Level\nAutodesk.Revit.DB.Geometry.Arc\nAutodesk.Revit.DB.Geometry.Ellipse\nAutodesk.Revit.DB.Geometry.NurbSpline\nAutodesk.Revit.DB.Geometry.XYZ\n\nProject Files: \nCurvedBeam.cs\nThis file contains the class Command which inherits from IExternalCommand interface and implements the Execute method; besides, it implements the functionalities to get all levels and structural framing (beam and brace) types from Revit project. Two classes SymbolMap and LevelMap which are for reserving all types of beam and level are contained in this file too.\n\nCurvedBeamForm.cs\nThis file contains a Form class which consists of two ComboBox controls which will show all structural framing (beam and brace) types and levels of project; three buttons which will create arc, ellipse, nurbspline beams respectively when they’re clicked.\n\nDescription: This sample uses FamilySymbol, FamilyInstance, Arc, Ellipse and NurbSpline classes mostly to get all structural framing types and levels from Revit project, then use them to create new beam.\n-\tTo get structural framing types and levels of Revit, use ElementClassFilter to iterate them.\n-\tTo get all symbols of a family, use Family.Symbols property.\n-\tTo get the category of family symbol, use FamiySybol.Category property.\n-\tTo create arc, ellipse and nurbspline, use NewArc, NewEllipse and NewNurbSpline methods of Creation.Document class respectively.\n-\tTo create curved beam instance, use NewFamilyInstance method of Creation.Document class, by specifying the curve for new beam.\n\nInstructions: \n1.\tStart Revit, make sure there are some structural framing types and levels in project.\n2.\tRun the command, the “Curved Beam” form will pop up, all the available framing types and levels will be listed in two ComboBox controls.\n3.\tSelect a type and a level on which beam will be created\n4.\tClick “Arc” button will create one arc beam, click “Partial Ellipse” button will create one partial ellipse beam, click “Spline” button will create one nurbspline beam.\n\nNote:\n1.\tThe location of arc, ellipse and nurbspline instances are hard codes.\n2.\tPlease run the sample in latest version (later than 14th, Dec, 2006)."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\DeckProperties\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n                                               ref string message,\n                                               ElementSet elements)\n        {\n            // Get the application of revit\n            Autodesk.Revit.UI.UIApplication revit = commandData.Application;\n            m_document = revit.ActiveUIDocument.Document;\n\n            try\n            {\n               ElementSet elementSet = new ElementSet();\n               foreach (ElementId elementId in revit.ActiveUIDocument.Selection.GetElementIds())\n               {\n                  elementSet.Insert(revit.ActiveUIDocument.Document.GetElement(elementId));\n               }\n                if (elementSet.IsEmpty)\n                {\n                    TaskDialog.Show(\"Select\", \"Please select one floor or slab at least.\");\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n                using (m_displayForm = new DeckPropertyForm())\n                {\n                    List<Floor> floorList = new List<Floor>();\n                    foreach (ElementId elementId in revit.ActiveUIDocument.Selection.GetElementIds())\n                    {\n                       Element element = revit.ActiveUIDocument.Document.GetElement(elementId);\n                        Floor floor = element as Floor;\n                        if (floor != null)\n                        {\n                            floorList.Add(floor);\n                        }\n                    }\n\n                    if (floorList.Count <= 0)\n                    {\n                        TaskDialog.Show(\"Select\", \"Please select one floor or slab at least.\");\n                        return Autodesk.Revit.UI.Result.Cancelled;\n                    }\n\n                    foreach (Floor floor in floorList)\n                    {\n                        DumpSlab(floor);\n                    }\n                    m_displayForm.ShowDialog();\n                }\n            }\n            catch (Exception ex)\n            {\n                // If any error, store error information in message and return failed\n                message = ex.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            // If everything goes well, return succeeded.\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        /// <summary>\n        /// Dump the properties of interest for the slab passed as a parameter\n        /// </summary>\n        /// <param name=\"slab\"></param>\n        private void DumpSlab(Floor slab)\n        {\n            m_displayForm.WriteLine(\"Dumping Slab\" + slab.Id.ToString());\n\n            Autodesk.Revit.DB.FloorType slabType = slab.FloorType;\n\n            if (slabType != null)\n            {\n                foreach (CompoundStructureLayer layer in slabType.GetCompoundStructure().GetLayers())\n                {\n                    if (layer.Function == MaterialFunctionAssignment.StructuralDeck)\n                    {\n                        DumbDeck(layer);\n                    }\n                    else\n                    {\n                        DumpLayer(layer);\n                    }\n                }\n            }\n\n            m_displayForm.WriteLine(\" \");\n        }\n\n        /// <summary>\n        /// Dump properties specific to a decking layer\n        /// </summary>\n        /// <param name=\"deck\"></param>\n        private void DumbDeck(CompoundStructureLayer deck)\n        {\n            m_displayForm.WriteLine(\"Dumping Deck\");\n\n            if (deck.MaterialId != ElementId.InvalidElementId)\n            {\n                // get the deck material object. In this sample all we need to display is the\n                // name, but other properties are readily available from the material object.\n                Autodesk.Revit.DB.Material deckMaterial = m_document.GetElement(deck.MaterialId) as Material;\n                m_displayForm.WriteLine(\"Deck Material = \" + deckMaterial.Name);\n            }\n\n            if (deck.DeckProfileId != ElementId.InvalidElementId)\n            {\n                // the deck profile is actually a family symbol from a family of profiles\n                Autodesk.Revit.DB.FamilySymbol deckProfile = m_document.GetElement(deck.DeckProfileId) as FamilySymbol;\n\n                // firstly display the full name as the user would see it in the user interface\n                // this is done in the format Family.Name and then Symbol.Name\n                m_displayForm.WriteLine(\"Deck Profile = \"\n                    + deckProfile.Family.Name + \" : \" + deckProfile.Name);\n\n                // the symbol object also contains parameters that describe how the deck is\n                // specified. From these parameters an external application can generate\n                // identical decking for analysis purposes\n                DumpParameters(deckProfile);\n            }\n        }\n\n        /// <summary>\n        /// A generic parameter display method that displays all the parameters of an element\n        /// </summary>\n        /// <param name=\"element\"></param>\n        private void DumpParameters(Element element)\n        {\n            foreach (Parameter parameter in element.Parameters)\n            {\n                string value = \"\";\n                switch (parameter.StorageType)\n                {\n                    case Autodesk.Revit.DB.StorageType.Double:\n                        value = parameter.AsDouble().ToString();\n                        break;\n                    case Autodesk.Revit.DB.StorageType.ElementId:\n                        value = parameter.AsElementId().ToString();\n                        break;\n                    case Autodesk.Revit.DB.StorageType.String:\n                        value = parameter.AsString();\n                        break;\n                    case Autodesk.Revit.DB.StorageType.Integer:\n                        value = parameter.AsInteger().ToString();\n                        break;\n                }\n\n                m_displayForm.WriteLine(parameter.Definition.Name + \" = \" + value);\n            }\n        }\n\n        /// <summary>\n        /// for non deck layers this method is called and it displays minimal information\n        /// about the layer\n        /// </summary>\n        /// <param name=\"layer\"></param>\n        private void DumpLayer(CompoundStructureLayer layer)\n        {\n            // Display the name of the material. More detailed material properties can\n            // be found form the material object\n            m_displayForm.WriteLine(\"Dumping Layer\");\n            Autodesk.Revit.DB.Material material = m_document.GetElement(layer.MaterialId) as Material;\n            if (material != null)\n            {\n                m_displayForm.WriteLine(\"Layer material = \" + material.Name);\n            }\n\n            // display the thickness of the layer in inches.\n            m_displayForm.WriteLine(\"Layer Thickness = \" + layer.Width.ToString());\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_DeckProperties.rtf": "Summary: This sample shows that how to get the properties of deck layer by RevitAPI.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.CompoundStructureLayer\nAutodesk.Revit.DB.FloorType\nAutodesk.Revit.DB.CompoundStructureLayerFunction\n\nProject Files:\nCommand.cs\nThis file contains the functions that how to get the properties of deck layer.\n\nDescription: -\tDisplay the properties deck layer in a list. It contains Deck Profile, Deck Material, Concrete cover thickness and Concrete Material.\n-\tFor concrete slabs, it contains Concrete thickness and Concrete material.\n-\tThe CompoundStructureLayer layers can be obtained from the Autodesk.Revit.DB.FloorType’s CompoundStructureLayer property.\n\nInstructions: \n1.\tDraw a floor which contains some layers in Revit UI. A sample project file SlabProperties.rvt is available in the SlabProperties sample’s folder.\n2.\tSelect the floor and run the command, it will show all the deck layer properties of the selected floor in a list.\n\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\DeleteDimensions\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n          ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         ElementSet selections = new ElementSet();\n         foreach (ElementId elementId in commandData.Application.ActiveUIDocument.Selection.GetElementIds())\n         {\n            selections.Insert(commandData.Application.ActiveUIDocument.Document.GetElement(elementId));\n         }\n         ElementSet dimsToDelete = new Autodesk.Revit.DB.ElementSet();\n\n         //warning if nothing selected\n         if (0 == selections.Size)\n         {\n            message = \"Please select dimensions\";\n            return Autodesk.Revit.UI.Result.Failed;\n         }\n\n         //find all unpinned dimensions in the current selection \n         foreach (Element e in selections)\n         {\n            Dimension dimesionTemp = e as Dimension;\n            if (null != dimesionTemp && !dimesionTemp.Pinned)\n            {\n               dimsToDelete.Insert(dimesionTemp);\n            }\n         }\n\n         //warning if could not find any unpinned dimension\n         if (0 == dimsToDelete.Size)\n         {\n            message = \"There are no unpinned dimensions currently selected\";\n            return Autodesk.Revit.UI.Result.Failed;\n         }\n\n         Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"External Tool\");\n\n         transaction.Start();\n         //delete all the unpinned dimensions\n         foreach (Element e in dimsToDelete)\n         {\n             commandData.Application.ActiveUIDocument.Document.Delete(e.Id);\n         }\n\n         transaction.Commit();\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_DeleteDimensions.rtf": "Summary: Show how to delete Dimension elements.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.DB.Dimension\nAutodesk.Revit.DB.Element\n\nProject Files: \nDeleteDimesions.cs\nThis file contains a class Command that implements the IExternalCommand, the function of the class is to get the dimension objects from the selected elements and delete those that are not pinned.\n\nDescription: -\tTo get the select elements use Application.ActiveUIDocument.Selection.Elements.\n-\tTo verify the dimension is pinned or not use Dimension.Pinned.\n-\tTo delete a dimension use Document.Delete(ElementSet).\n\nInstructions: \n1.\tOpen or new a Revit project and make sure all needed Dimensions are placed. A sample project file DeleteDimensions.rvt is available in the sample’s folder.\n2.\tSelect some dimensions to be deleted.\n3.\tRun the command.\n4.\tThe dimensions will be deleted if it is not pinned.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\DoorSwing\\CS",
    "key_code": {
      "class_name": "InitializeCommand",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, \n                                             ref string message, \n                                             ElementSet elements)\n      {\n         Autodesk.Revit.UI.Result returnCode = Autodesk.Revit.UI.Result.Cancelled;  \n\n         Transaction tran = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Initialize Command\");\n         tran.Start();\n\n         try\n         {\n            // one instance of DoorSwingData class.\n            DoorSwingData databuffer = new DoorSwingData(commandData.Application);\n   \n            using (InitializeForm initForm = new InitializeForm(databuffer))\n            {\n               // Show UI\n               DialogResult dialogResult = initForm.ShowDialog();\n\n               if (DialogResult.OK == dialogResult)\n               {\n                  databuffer.DeleteTempDoorInstances();\n\n                  // update door type's opening feature based on family's actual geometry and \n                  // country's standard.\n                  databuffer.UpdateDoorFamiliesOpeningFeature();\n\n                  // update each door instance's Opening feature and internal door flag\n                  returnCode = DoorSwingData.UpdateDoorsInfo(commandData.Application.ActiveUIDocument.Document, false, true, ref message);\n               }\n            }\n         }\n         catch (Exception ex)\n         {\n            // if there is anything wrong, give error information and return failed.\n            message    = ex.Message;\n            returnCode = Autodesk.Revit.UI.Result.Failed;\n         }\n\n         if (Autodesk.Revit.UI.Result.Succeeded == returnCode)\n         {\n            tran.Commit();\n         }\n         else\n         {\n            tran.RollBack();\n         }\n         return returnCode;\n      }\n\n      #endregion\n   }\n\n   /// <summary>\n   /// A ExternalCommand class inherited IExternalCommand interface.\n   /// This command will update each door instance's opening, ToRoom, FromRoom and \n   /// internal door flag values according to door's current geometry.\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class UpdateParamsCommand : IExternalCommand\n   {\n      #region IExternalCommand Members\n\n      /// <summary>\n      /// Implement this method as an external command for Revit.\n      /// </summary>\n      /// <param name=\"commandData\">An object that is passed to the external application \n      /// which contains data related to the command, \n      /// such as the application object and active view.</param>\n      /// <param name=\"message\">A message that can be set by the external application \n      /// which will be displayed if a failure or cancellation is returned by \n      /// the external command.</param>\n      /// <param name=\"elements\">A set of elements to which the external application \n      /// can add elements that are to be highlighted in case of failure or cancellation.</param>\n      /// <returns>Return the status of the external command. \n      /// A result of Succeeded means that the API external method functioned as expected. \n      /// Cancelled can be used to signify that the user cancelled the external operation \n      /// at some point. Failure should be returned if the application is unable to proceed with \n      /// the operation.</returns>\n      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         Autodesk.Revit.UI.Result returnCode = Autodesk.Revit.UI.Result.Succeeded;\n         Autodesk.Revit.UI.UIApplication app = commandData.Application;\n         UIDocument doc = app.ActiveUIDocument;\n         Transaction tran = new Transaction(doc.Document, \"Update Parameters Command\");\n         tran.Start();\n\n         try\n         {\n            ElementSet elementSet = new ElementSet();\n            foreach (ElementId elementId in doc.Selection.GetElementIds())\n            {\n               elementSet.Insert(doc.Document.GetElement(elementId));\n            }\n            if (elementSet.IsEmpty)\n            {\n               returnCode = DoorSwingData.UpdateDoorsInfo(doc.Document, false, true, ref message);\n            }\n            else\n            {\n               returnCode = DoorSwingData.UpdateDoorsInfo(doc.Document, true, true, ref message);\n            }\n         }\n         catch (Exception ex)\n         {\n            // if there is anything wrong, give error information and return failed.\n            message = ex.Message;\n            returnCode = Autodesk.Revit.UI.Result.Failed;\n         }\n\n         if (Autodesk.Revit.UI.Result.Succeeded == returnCode)\n         {\n            tran.Commit();\n         }\n         else\n         {\n            tran.RollBack();\n         }\n         return returnCode;\n      }\n\n      #endregion\n   }\n\n   /// <summary>\n   /// A ExternalCommand class inherited IExternalCommand interface.\n   /// This command will update door instance's geometry according to door's \n   /// current To/From Room value.\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class UpdateGeometryCommand : IExternalCommand\n   {\n      #region IExternalCommand Members\n\n      /// <summary>\n      /// Implement this method as an external command for Revit.\n      /// </summary>\n      /// <param name=\"commandData\">An object that is passed to the external application \n      /// which contains data related to the command, \n      /// such as the application object and active view.</param>\n      /// <param name=\"message\">A message that can be set by the external application \n      /// which will be displayed if a failure or cancellation is returned by \n      /// the external command.</param>\n      /// <param name=\"elements\">A set of elements to which the external application \n      /// can add elements that are to be highlighted in case of failure or cancellation.</param>\n      /// <returns>Return the status of the external command. \n      /// A result of Succeeded means that the API external method functioned as expected. \n      /// Cancelled can be used to signify that the user cancelled the external operation \n      /// at some point. Failure should be returned if the application is unable to proceed with \n      /// the operation.</returns>\n      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         Autodesk.Revit.UI.Result returnCode = Autodesk.Revit.UI.Result.Succeeded;\n         Autodesk.Revit.UI.UIApplication app = commandData.Application;\n         UIDocument doc = app.ActiveUIDocument;\n         Transaction tran = new Transaction(doc.Document, \"Update Geometry Command\");\n         tran.Start();\n\n         try\n         {\n            ElementSet elementSet = new ElementSet();\n            foreach (ElementId elementId in doc.Selection.GetElementIds())\n            {\n               elementSet.Insert(doc.Document.GetElement(elementId));\n            }\n            if (elementSet.IsEmpty)\n            {\n               DoorSwingData.UpdateDoorsGeometry(doc.Document, false);\n            }\n            else\n            {\n               DoorSwingData.UpdateDoorsGeometry(doc.Document, true);\n            }\n\n            returnCode =  Autodesk.Revit.UI.Result.Succeeded;\n         }\n         catch (Exception ex)\n         {\n            // if there is anything wrong, give error information and return failed.\n            message = ex.Message;\n            returnCode = Autodesk.Revit.UI.Result.Failed;\n         }\n\n         if (Autodesk.Revit.UI.Result.Succeeded == returnCode)\n         {\n            tran.Commit();\n         }\n         else\n         {\n            tran.RollBack();\n         }\n\n         return returnCode;\n      }\n\n      #endregion\n   }\n}"
    },
    "documentation": {
      "ReadMe_DoorSwing.rtf": "Summary: This sample will demonstrate how to create and maintain door opening parameters, internal door parameter, From/To Room and how to schedule these parameters. Feature to customize to your country standard is also provided.\n \nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.UI.IExternalApplication\nAutodesk.Revit.ApplicationServices.ControlledApplication\nAutodesk.Revit.UI.RibbonPanel\nAutodesk.Revit. UI.PushButton\nAutodesk.Revit.DB.DocumentType.Family\nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.GeometryElement\nAutodesk.Revit.DB.BoundingBoxXYZ\nAutodesk.Revit.DB.Options\nAutodesk.Revit.DB.DefinitionFile\nAutodesk.Revit.DB.Definition\nAutodesk.Revit.DB.BindingMap\nAutodesk.Revit.DB.ElementBinding\nAutodesk.Revit.DB.InstanceBinding\nAutodesk.Revit.DB.TypeBinding\nAutodesk.Revit.DB.Parameter\nAutodesk.Revit.DB.Events.DocumentSavingEventArgs\nAutodesk.Revit.DB.Events.DocumentSavingAsEventArgs\n\nProject Files: \nCommand.cs\nIt contains three classes InitializeCommand, UpdateParamsCommand and UpdateGeometryCommand. All of them implement interface IExternalCommand. \n\nExternalApplication.cs\nThis file contains one class ExternalApplication which implements interface IExternalApplication. This class will create one custom Ribbon panel contains three buttons to invoke the three external commands defined in Command.cs file. This class subscribes some application level events to update door parameters too. That can insure the doc is correct when it is about saved, saved as etc.\n\nDoorSwingData.cs\nThis file contains one class DoorSwingData which prepares the needed data and updates door opening, Internal/External door and To/From Room information.\n\nDoorFamily.cs\nThis file contains one class DoorFamily which maintains family name, family geometry and door opening expression information for each door family. And it also customizes the door opening expression according to each door family’s geometry and country's standard.\n\nDoorFamilyGeometry.cs\nThis file contains one class DoorGeometry which is used to transform Revit geometry data to appropriate format for GDI.\n\nDoorSharedParameters.cs\nThis file contains one Static class DoorSharedParameters which is used to add three shared parameters to door and named with BasalOpening, InstanceOpening and Internal Door.\n\nInitializeForm.cs\nThis file contains a form class InitializeForm which consists of one DataGridView to show user all door families existent in current Revit project, and one pictureBox to show door family’s geometry. User can customize door opening expression according to each door family’s geometry and country's standard here.\n\nDoorSwingResource.resx\nA resource file which contains some strings to identify the door opening.\n\nDescription: For door’s opening functionality, user can invoke the external command \"Customize Door Opening Expression\" to add needed shared parameters and customize door opening expression according to their own country's standard and each door family’s geometry. When the door was flipped or mirrored, user can invoke the external command “Update Door Properties” to update parameters’ values. Schedule for these parameters will be done from Revit UI.\n\nFor door’s related room functionality, from Revit UI user can schedule the “To room” and “From room” information for Internal and external doors in two separate schedule tables and can change the direction of the door in schedule tables. User will then use “Update Door Geometry” command to update the geometry of the door after the direction of the door was changed in schedule tables. When the door was flipped or mirrored in view, user can invoke the external command “Update Door Properties” to update “To room” and “From room” information too.\n\nParameter updating process will also be invoked upon closing, save or save as of the project file.\n\nInstructions: \n1.\tPrepare your Revit project. \nOpen or new a Revit project and make sure all needed rooms are placed. If your project file has any closed wall loop without a room being defined, the sample will have a dialog to ask you to confirm that you would consider doors bounding those areas as external doors.\nA sample project file DoorSwing.rvt is available in the sample’s folder.\n\n2.\tCustomize your door opening expression. \nClick \"Customize Door Opening Expression\" command (menu item or Ribbon button) to customize each door family’s opening expression based on the family’s geometry and your country’s standard. This is the first command of the sample. If the expressions which comply with your country standard are not available on the list, you can open the source code project and modify in the following 3 areas:\n\na.\tEdit project resource file.\nb.\tEdit DoorSwingData static constructor in DoorSwingData.cs. Add more door opening expressions from resource file into OpeningTypes list.\nc.\tEdit UpdateOpeningFeatureOfOneDoor function in DoorSwingData.cs. Add more else if in “if (switchesOpeningValueFlag){…}” statement to deal with the added door opening expression.\n\nUsers who want to create a localized version of the sample can follow step 2.a above.\n\n3.\tSchedule the parameters.\nCreate door schedule from Revit UI. You can schedule “Opening” , “Internal Door” parameters and “Room number” of “From Room”/”To Room” or any others you need.\n\na.\tCreate Internal Door Schedule.\nRevit Button: View Tab->Create Panel->Schedules Button->Schedule/Quantities;\nCategory: Doors; Name: Internal Door Schedule.\n\nAdd parameters which need to be scheduled.\n·\tAdd existing parameters: Mark, Internal Door, InstanceOpening, FromRoom:Number, ToRoom:Number;\n·\tAdd a Calculated value: Name: Opening, Select: Formula, Discipline: Common, Type: Text, Formula: InstanceOpening.\n·\tMove up Opening parameter before InstanceOpening parameter.\n\n\n\nModify the appearance of the schedule including visibility, sorting and so on.\n·\tHide Internal Door and InstanceOpening column if you want: right click the “Internal Door” column, and then left click the Hide Column(s) menu; right click the “InstanceOpening” column, and then left click the Hide Column(s) menu;\n·\tSort items by door’s Mark value: right click anywhere in the schedule, then left click View Properties… menu; Sorting/Grouping item in the Properties dialog box; Sort by: Mark.\n·\tFilter by Internal Door: Filter item in the Properties dialog; Filter by: Internal Door equals Yes.\nb.\tCreate External Door Schedule.\nFollow the same steps as creating Internal Door Schedule except the Filter setting. Filter by: Internal Door equals No.\n\n4.\tUpdate door parameter when flip/mirror the door\nFlip/mirror any door, then click “Update Door Properties” command (menu item or Ribbon button). This command will update door parameters according to door’s geometry.\n\n5.\tUpdate door geometry when change the direction of the door in the schedule.\nYou can even change the room number of “From Room” / ”To Room” from the schedule. After that click the “Update Door Geometry” command will change the door’s geometry based on the changes you made in the schedule.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\ElementFilter\\ViewFilters\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n                                               ref string message, ElementSet elements)\n        {\n            try\n            {\n                // create a form to display the information of view filters\n                using (ViewFiltersForm infoForm = new ViewFiltersForm(commandData))\n                {\n                    infoForm.ShowDialog();\n                }\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception ex)\n            {\n                // If there is something wrong, give error information and return failed\n                message = ex.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_ViewFilters.rtf": "Summary: This sample demonstrates how to create and modify view filters by 2011 new element iteration API.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.FilteredElementCollector\nAutodesk.Revit.DB.ParameterFilterElement\nAutodesk.Revit.DB.ParameterFilterUtilities\nAutodesk.Revit.DB.ParameterFilterRuleFactory\n\nProject Files: \nCommand.cs\nThis file contains the class Command which inherits from IExternalCommand interface and implements the Execute method.\n\nViewFiltersForm.cs\nThis file contains a Form class which consists of several controls to show existing filters and theirs categories, filter rules; some controls provide functionalities allow modifying filters and rules.\n\nFilterData.cs\nThis file defines two custom data classes FilterData and FilterRuleData representing data of API Filter and FilterRule elements; these two data caches will help show contents of Filter and FilterRules on UI controls. The file also has class RuleCriteraNames which is used to get string criteria for filter rule.\n\nFiltersUtil.cs\nThis file defines class FiltersUtil which consists of some utility methods used to deal with filter and its rules. E.g. get existing filters from document; get criteria (in string) from FilterRule’s evaluator. \n\nExtension.cs\nThis file have extension utility classes which deal with Enum and List related, they’re used to parse enum values and compare list content, etc.\n\nDescription: This sample uses element iteration API and especially ParameterFilterElement related method to simulate functionalities of UI command: View\\Filters. This sample also allows adding filter rule of > 3 and provides more options on rule values.\n-\tTo find all view filters within document, use ElementClassFilter(typof(ParameterFilterElement)).\n-\tParameterFilterElement.Create(…) methods can create new view filters; its related methods can access or modify categories/ rules of filter.\n-\tParameterFilterUtilities.GetAllFilterableCategories() method can find all categories which support filtering.\n-\tParameterFilterRuleFactory.CreateXXX() methods can create accordingly filter rules.\n-\tUsing FilterInverseRule to created inverted filter rule that inverts the boolean values returned by the rule it contains.\n-\tDocument.get_TypeOfStorage(BuiltInParameter) can get storage type(int/double/string/elementid) of parameter.\n-\tView filter (ParameterFilterElement) can be deleted by Document.Delete() method.\n-\tBy reflecting base FilterRule to its derived, we can find out details of this rule: rule criteria (equals/greater/less…), rule values.\n\n\nInstructions: \nCreate some filters and specify filter rules via UI command: View tab  Graphics panel  Filters. One .rvt file named ViewFilters.rvt is available under sample project folder, this project have one filter with four filter rules, some walls within that project are displayed in different mode(set by View tab  Graphics panel  Graphics/Visibility  Filters tab) because these walls passes filter and all rules.\nRun this sample: all existing filters and theirs filter rules can be retrieved; the filter rules data (parameter, criteria and rule values) are displayed on accordingly controls. \nCompared with UI command, this sample provides epsilon option for double value and case-sensitive option for string are provided, it allows user to specify them for double/string parameter; sample also allows displaying and adding filters of more than 3. \nFor filters: click “New” button to add new one filter; click “delete” button to delete someone filter.\nBy changing selected categories to modify filter’s categories, this will reset filter rules as well.\nFor filter rules: Sample allow user to change parameter/criteria/rule value to modify filter rule: To create new filter rule, select new parameter and click “New” button; after modifying criteria/rule value for existing rule, click “Update” to apply change; “Delete” button can delete current selected rule. Note that rule operations won’t take effect for Revit view filters until you click “OK” button, follow item below to apply your changes.\nWhen “OK” button is clicked, the change on filters will take effect and be applied to Revit view filters; you can verify the change in UI view filters or apply filters in view Visibility/Graphics setting then.\nNote: If you want to apply filters to specific views, please do this via Revit UI command: View tab à Graphics panel à Graphics/Visibility à Filters tab, this sample doesn’t provide function to do this because API doesn’t support this yet. \n\nNotes: \n-\tRevit UI command (View\\Filters) restricts numbers of rules to 3; rules of > 3 created by API will be removed once you update filter or rule by UI command.\n-\tThis sample only supports BuiltInParameter when creating filter rules.\n-\tThis sample is only available for project document."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\ErrorHandling\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n      ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         m_revitApp = commandData.Application.Application;\n         m_doc = commandData.Application.ActiveUIDocument.Document;\n\n         Level level1 = GetLevel();\n         if (level1 == null)\n         {\n            throw new Exception(\"[ERROR] Failed to get level 1\");\n         }\n\n         try\n         {\n            //\n            // Post a warning and resolve it in FailurePreproccessor\n            try\n            {\n               Transaction transaction = new Transaction(m_doc, \"Warning_FailurePreproccessor\");\n               FailureHandlingOptions options = transaction.GetFailureHandlingOptions();\n               FailurePreproccessor preproccessor = new FailurePreproccessor();\n               options.SetFailuresPreprocessor(preproccessor);\n               transaction.SetFailureHandlingOptions(options);\n               transaction.Start();\n               FailureMessage fm = new FailureMessage(m_idWarning);\n               m_doc.PostFailure(fm);\n               transaction.Commit();\n            }\n            catch (System.Exception)\n            {\n               message = \"Failed to commit transaction Warning_FailurePreproccessor\";\n               return Result.Failed;\n            }\n\n            //\n            // Dismiss the overlapped wall warning in FailurePreproccessor\n            try\n            {\n               Transaction transaction = new Transaction(m_doc, \"Warning_FailurePreproccessor_OverlappedWall\");\n               FailureHandlingOptions options = transaction.GetFailureHandlingOptions();\n               FailurePreproccessor preproccessor = new FailurePreproccessor();\n               options.SetFailuresPreprocessor(preproccessor);\n               transaction.SetFailureHandlingOptions(options);\n               transaction.Start();\n\n               Line line = Line.CreateBound(new XYZ(-10, 0, 0), new XYZ(-20, 0, 0));\n               Wall wall1 = Wall.Create(m_doc, line, level1.Id, false);\n               Wall wall2 = Wall.Create(m_doc, line, level1.Id, false);\n               m_doc.Regenerate();\n\n               transaction.Commit();\n            }\n            catch (System.Exception)\n            {\n               message = \"Failed to commit transaction Warning_FailurePreproccessor_OverlappedWall\";\n               return Result.Failed;\n            }\n\n            //\n            // Post an error and resolve it in FailuresProcessingEvent\n            try\n            {\n               m_revitApp.FailuresProcessing += new EventHandler<Autodesk.Revit.DB.Events.FailuresProcessingEventArgs>(FailuresProcessing);\n               Transaction transaction = new Transaction(m_doc, \"Error_FailuresProcessingEvent\");\n               transaction.Start();\n\n               Line line = Line.CreateBound(new XYZ(0, 10, 0), new XYZ(20, 10, 0));\n               Wall wall = Wall.Create(m_doc, line, level1.Id, false);\n               m_doc.Regenerate();\n\n               FailureMessage fm = new FailureMessage(m_idError);\n               FailureResolution fr = DeleteElements.Create(m_doc, wall.Id);\n               fm.AddResolution(FailureResolutionType.DeleteElements, fr);\n               m_doc.PostFailure(fm);\n               transaction.Commit();\n            }\n            catch (System.Exception)\n            {\n               message = \"Failed to commit transaction Error_FailuresProcessingEvent\";\n               return Result.Failed;\n            }\n\n            //\n            // Post an error and resolve it in FailuresProcessor\n            try\n            {\n               FailuresProcessor processor = new FailuresProcessor();\n               Application.RegisterFailuresProcessor(processor);\n               Transaction transaction = new Transaction(m_doc, \"Error_FailuresProcessor\");\n               transaction.Start();\n\n               Line line = Line.CreateBound(new XYZ(0, 20, 0), new XYZ(20, 20, 0));\n               Wall wall = Wall.Create(m_doc, line, level1.Id, false);\n               m_doc.Regenerate();\n\n               FailureMessage fm = new FailureMessage(m_idError);\n               FailureResolution fr = DeleteElements.Create(m_doc, wall.Id);\n               fm.AddResolution(FailureResolutionType.DeleteElements, fr);\n               m_doc.PostFailure(fm);\n               transaction.Commit();\n            }\n            catch (System.Exception)\n            {\n               message = \"Failed to commit transaction Error_FailuresProcessor\";\n               return Result.Failed;\n            }\n         }\n         catch (Exception ex)\n         {\n            message = ex.Message;\n            return Result.Failed;\n         }\n\n         return Result.Succeeded;\n      }\n\n      /// <summary>\n      /// Implements the FailuresProcessing event\n      /// </summary>\n      /// <param name=\"sender\"></param>\n      /// <param name=\"e\"></param>\n      private void FailuresProcessing(object sender, Autodesk.Revit.DB.Events.FailuresProcessingEventArgs e)\n      {\n         FailuresAccessor failuresAccessor = e.GetFailuresAccessor();\n         //failuresAccessor\n         String transactionName = failuresAccessor.GetTransactionName();\n\n         IList<FailureMessageAccessor> fmas = failuresAccessor.GetFailureMessages();\n         if (fmas.Count == 0)\n         {\n            e.SetProcessingResult(FailureProcessingResult.Continue);\n            return;\n         }\n\n         if (transactionName.Equals(\"Error_FailuresProcessingEvent\"))\n         {\n            foreach (FailureMessageAccessor fma in fmas)\n            {\n               FailureDefinitionId id = fma.GetFailureDefinitionId();\n               if (id == Command.m_idError)\n               {\n                  failuresAccessor.ResolveFailure(fma);\n               }\n            }\n\n            e.SetProcessingResult(FailureProcessingResult.ProceedWithCommit);\n            return;\n         }\n\n         e.SetProcessingResult(FailureProcessingResult.Continue);\n      }\n\n      /// <summary>\n      /// Gets the level named \"Level 1\"\n      /// </summary>\n      /// <returns></returns>\n      private Level GetLevel()\n      {\n         Level level1 = null;\n\n         FilteredElementCollector collector = new FilteredElementCollector(m_doc);\n         ElementClassFilter filter = new ElementClassFilter(typeof(Level));\n         IList<Element> levels = collector.WherePasses(filter).ToElements();\n\n         foreach (Level level in levels)\n         {\n            if (level.Name.Equals(\"Level 1\"))\n            {\n               level1 = level;\n               break;\n            }\n         }\n\n         return level1;\n      }\n      #endregion\n   }\n\n   /// <summary>\n   /// Implements the interface IFailuresPreprocessor\n   /// </summary>\n   public class FailurePreproccessor : IFailuresPreprocessor\n   {\n      /// <summary>\n      /// This method is called when there have been failures found at the end of a transaction and Revit is about to start processing them. \n      /// </summary>\n      /// <param name=\"failuresAccessor\">The Interface class that provides access to the failure information. </param>\n      /// <returns></returns>\n      public FailureProcessingResult PreprocessFailures(FailuresAccessor failuresAccessor)\n      {\n         IList<FailureMessageAccessor> fmas = failuresAccessor.GetFailureMessages();\n         if (fmas.Count == 0)\n         {\n            return FailureProcessingResult.Continue;\n         }\n\n         String transactionName = failuresAccessor.GetTransactionName();\n         if (transactionName.Equals(\"Warning_FailurePreproccessor\"))\n         {\n            foreach (FailureMessageAccessor fma in fmas)\n            {\n               FailureDefinitionId id = fma.GetFailureDefinitionId();\n               if (id == Command.m_idWarning)\n               {\n                  failuresAccessor.DeleteWarning(fma);\n               }\n            }\n\n            return FailureProcessingResult.ProceedWithCommit;\n         }\n         else if (transactionName.Equals(\"Warning_FailurePreproccessor_OverlappedWall\"))\n         {\n            foreach (FailureMessageAccessor fma in fmas)\n            {\n               FailureDefinitionId id = fma.GetFailureDefinitionId();\n               if (id == BuiltInFailures.OverlapFailures.WallsOverlap)\n               {\n                  failuresAccessor.DeleteWarning(fma);\n               }\n            }\n\n            return FailureProcessingResult.ProceedWithCommit;\n         }\n         else\n         {\n            return FailureProcessingResult.Continue;\n         }\n      }\n   }\n\n   /// <summary>\n   /// Implements the interface IFailuresProcessor\n   /// </summary>\n   public class FailuresProcessor : IFailuresProcessor\n   {\n      /// <summary>\n      /// This method is being called in case of exception or document destruction to dismiss any possible pending failure UI that may have left on the screen \n      /// </summary>\n      /// <param name=\"document\">Document for which pending failures processing UI should be dismissed </param>\n      public void Dismiss(Document document)\n      {\n      }\n\n      /// <summary>\n      /// Method that Revit will invoke to process failures at the end of transaction. \n      /// </summary>\n      /// <param name=\"failuresAccessor\">Provides all necessary data to perform the resolution of failures.</param>\n      /// <returns></returns>\n      public FailureProcessingResult ProcessFailures(FailuresAccessor failuresAccessor)\n      {\n         IList<FailureMessageAccessor> fmas = failuresAccessor.GetFailureMessages();\n         if (fmas.Count == 0)\n         {\n            return FailureProcessingResult.Continue;\n         }\n\n         String transactionName = failuresAccessor.GetTransactionName();\n         if (transactionName.Equals(\"Error_FailuresProcessor\"))\n         {\n            foreach (FailureMessageAccessor fma in fmas)\n            {\n               FailureDefinitionId id = fma.GetFailureDefinitionId();\n               if (id == Command.m_idError)\n               {\n                  failuresAccessor.ResolveFailure(fma);\n               }\n            }\n            return FailureProcessingResult.ProceedWithCommit;\n         }\n         else\n         {\n            return FailureProcessingResult.Continue;\n         }\n      }\n   }\n\n}"
    },
    "documentation": {
      "ReadMe_ErrorHandling.rtf": "Summary: This sample demonstrates how to create failure definition id, failure definition, failure message and how to resolve failures in failure (pro)processing steps.\n\nClasses: \nAutodesk.Revit.Document\nAutodesk.Revit.DB.FailureDefinitionId\nAutodesk.Revit.DB.FailureDefinition\nAutodesk.Revit.DB.FailureMessage\nAutodesk.Revit.DB.IFailuresPreprocessor\nAutodesk.Revit.DB.IFailuresProcessor\n\nProject Files: \nCommand.cs\nIt contains 3 classes.\n-\tCommand which implements interface IExternalCommand and IExternalApplication. This is the entry of this external command and external application.\n-\tFailurePreproccessor which implements interface IFailuresPreprocessor.\n-\tFailuresProcessor which implements interface IFailuresProcessor.\n\nDescription: Functionalities:\n-\tShows how to create failure definition ids and failure definitions with different severities and different resolution types.\n-\tShows how to create failure messages and post them.\n-\tShows how to solve failures during failure preprocessor.\n-\tShows how to solve failures in failure processing event.\n-\tShows how to solve failures during failure processor.\n\nImplements:\n-\tFailure definition id should be created with a guid.\n-\tFailure definition should be created with a failure definition id and the severity.\n-\tFailure message should be created with a failure definition id.\n-\tTo solve a failure in failure preprocessor, a FailureHandlingOptions should be created inside the transaction and an instance of IFailuresPreprocessor should be set to the FailureHandlingOptions.\n-\tTo solve a failure in failure processing event, the Application.FailuresProcessing event should be subscribed. \n-\tTo solve a failure in failure processor, an instance of IFailuresProcessor should be registered via the static method Application.RegisterFailuresProcessor.\n\nNotes:\nEach cycle of failures processing includes 3 steps:\n-\tpreprocessing of failures (FailuresPreprocessor)\nFailuresPreprocessor is being set for one transaction and used only during finishing of this one transaction. It gets control first during failure resolution process. It is nearly equivalent to checking and resolving failures before finishing transaction, except that FailuresPreprocessor gets control \"at the right time\" when all failures guaranteed to be posted and/or all irrelevant ones get deleted, so that there are no false positives or negatives.\n-\tbroadcasting of failures processing event (FailuresProcessing event)\nFailuresProcessing event is raised after FailuresPreprocessor (if any) has finished. It can have arbitrary number of handlers, and all of them will be invoked.\nBecause event handlers have no way to return value, setProcessingResult() on event argument should be used to communicate status. There is a restriction on result that can be set:\n-  Only Continue, ProceedWithRollback or ProceedWithCommit can be set\n-  If result is set to ProceedWithCommit, setting of Continue has no effect\n-  If result is set to ProceedWithRollback, setting of a different result has no effect\n-\tfinal processing (FailuresProcessor)\nFailuresProcessor gets control last, after FailuresProcessing event is processed. There is only one active FailuresProcessor in Revit session. There is a default one in Revit UI - it invoked all regular Revit error dialogs. If new FailuresProcessor is set, any previously set one is completely abandoned. If FailuresProcessor is set to NULL, any transaction that has any failures is silently aborted (unless failures are resolved by first two steps of failures processing). FailuresProcessor is allowd to return WaitForUserInput which leaves transaction pending. It is expected that in this case FailuresProcessor leaves some UI on the screen that will eventually commit or rollback pending transaction - otherwise pending state will last forever, killing user's ability to work with the document.\n\n\n\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Events\\EventsMonitor\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                       ref string message,\n                                       ElementSet elements)\n        {\n\n            IDictionary<string, string> journaldata = commandData.JournalData;\n\n        // These #if directives within file are used to compile project in different purpose:\n        // . Build project with Release mode for regression test,\n        // . Build project with Debug mode for manual run\n#if !(Debug || DEBUG)\n            // playing journal.\n            if (ExternalApplication.JnlProcessor.IsReplay)\n            {\n                ExternalApplication.ApplicationEvents = ExternalApplication.JnlProcessor.GetEventsListFromJournalData(journaldata);\n\n            }\n\n            // running the sample form UI.\n            else\n            {\n#endif\n\n            ExternalApplication.SettingDialog.ShowDialog();\n                if (DialogResult.OK == ExternalApplication.SettingDialog.DialogResult)\n                {\n                    // get what user select.\n                    ExternalApplication.ApplicationEvents = ExternalApplication.SettingDialog.AppSelectionList;\n                                        \n#if !(Debug || DEBUG)\n                    // dump what user select to a file in order to autotesting.\n                    ExternalApplication.JnlProcessor.DumpEventListToJournalData(ExternalApplication.ApplicationEvents, ref journaldata);\n#endif\n                }\n#if !(Debug || DEBUG)\n            }\n#endif\n                // update the events according to the selection.\n                ExternalApplication.AppEventMgr.Update(ExternalApplication.ApplicationEvents);\n\n                // track the selected events by showing the information in the information windows.\n                ExternalApplication.InfoWindows.Show();\n\n\n                return Autodesk.Revit.UI.Result.Succeeded;\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_EventsMonitor.rtf": "Summary: This sample demonstrates how to subscribe to controlled application level Events. \n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.UI.IExternamApplication\nAutodesk.Revit.DB.Events\n\nProject Files: \nCommand.cs\nThis file contains the class Command which implements IExternalCommand and used to retrieve the events setting to help user changing his choices.\n\nExternalApplication.cs\nThis file contains one class ExternalApplication which implements IExternalApplication interface and provides an entry of the sample.  This class controls other function class and plays the bridge role in this sample. It also creates a custom panel \"Event Monitor\" that contains a push button named “Set Events” in OnStartup method.\n\nEventManager.cs\nThis file contains one class AppEventManager which implements all the events handler methods. This class is a manager for application events. In this class, you can subscribe and remove the events according to what you select.\n\nLogManager.cs\nThis file contains one class LogManager which implements all operations about writing log file and generating event information for showing in the information windows.\n\nEventInfoWindows.cs\nThis file contains a form class InformationWindows which consists of one DataGridView to show the user the Revit events history log. The event log includes the event time, the event name, and the event type.\n\nEventSettingForm.cs\nThis file contains a form class which consists of CheckedList controls to provide the user with options about to which events they subscribe.\n\nJournalProcessor.cs\nThis file contains one class JournalProcessor which can help to auto-test this sample.This class checks the external xml file before the UI pops up and help entrance method to control whether it is playing journal or operating in UI.This class also can help to dump the selected event list to external xml file or journal file and retrieve the event list from those files. If you are just interested in how to use event, you can skip over this class and other related sentence.\n\nDescription: The sample pop up a dialog named “Events Tracking Setting” when the Revit application starts. User makes his choice in this dialog and tracking the events he selected. And one custom panel with a push button is created at the same time. This button is used to retrieve the setting dialog shown at the beginning to let use change his last choice. All subscribed events are shown in InformationWindows including their names, types and the trigger times.\n-\tThis sample will subscribe to events according to what the user chose in Events Setting Window.\n-\tThis sample lists events information like time, name, and type and so on in a modeless window when corresponding events are raised.\n\nInstructions: \nBuild this sample under Debug mode and register your .addin with .addin of this sample.\nRun Revit. An Events setting dialog box will appear.\nChoose any event that you would like to track. For example you might try to select DocumentSaving and DocumentsSaved events. Push OK button and go to Events information window. Open and save a document, then a log item will appear in the Events information window and be written into the EventsMonitor.log file. \nAnd then, if you want to change another event to track, you can push the “Set Events” button in the \"EventsMonitor\" panel. The Events Setting dialog box will appear again.\n\nNotes:\nNote that some condition compile directive(#if) were used in sample’s sources, they’re used for different purposes; please make sure you build this sample under Debug mode to let sample works as described above, building sample under Release mode is just for regression test purpose."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Events\\SelectionChanged\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                     ref string message,\n                                     ElementSet elements)\n      {\n         // track the selected events by showing the information in the information windows.\n         if(SelectionChanged.InfoWindow == null)\n         {\n            SelectionChanged.InfoWindow = new InfoWindow();\n            SelectionChanged.InfoWindow.Show();\n         }\n         else\n         {\n            SelectionChanged.InfoWindow.Focus();\n         }\n         \n\n\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n      #endregion\n   }\n}"
    },
    "documentation": {
      "ReadMe_SelectionChanged.rtf": "Summary: The sample implements IExternalApplication interface and subscribes SelectionChanged event in OnStartUp; the registered event handler will dump selected references related information to log files.\n\n\nClasses: \nAutodesk.Revit.UI.IExternalApplication\nAutodesk.Revit.ApplicationServices.ControlledApplication \nAutodesk.Revit.UI.Events.SelectionChangedEventArgs\n\nProject Files: \nSelectionChanged.cs\nThis file contains one class SelectionChanged which implements IExternalApplication interface. \n\nLogManager.cs\nThis file contains one class LogManager in which one log file will be created for tracking event raise.\n\n\nInstructions: \n1.\tCopy the provided .addin file under sample folder to install folder of your Revit and specify full paths for dll. \n2.\tStart Revit.\n3.\tChange selection and then refer to SelectionChanged.log."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\FamilyCreation\\AutoParameter\\CS",
    "key_code": {
      "class_name": "AddParameterToFamily",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                             ref string message,\n                                             ElementSet elements)\n      {\n         m_app = commandData.Application;\n         MessageManager.MessageBuff = new StringBuilder();\n\n         try\n         {\n            bool succeeded = AddParameters();\n\n            if (succeeded)\n            {\n               return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            else\n            {\n               message = MessageManager.MessageBuff.ToString();\n               return Autodesk.Revit.UI.Result.Failed;\n            }\n         }\n         catch (Exception e)\n         {\n            message = e.Message;\n            return Autodesk.Revit.UI.Result.Failed;\n         }\n      }\n\n      /// <summary>\n      /// add parameters to the active document\n      /// </summary>\n      /// <returns>\n      /// if succeeded, return true; otherwise false\n      /// </returns>\n      private bool AddParameters()\n      {\n         Document doc = m_app.ActiveUIDocument.Document;\n         if (null == doc)\n         {\n            MessageManager.MessageBuff.Append(\"There's no available document. \\n\");\n            return false;\n         }\n\n         if (!doc.IsFamilyDocument)\n         {\n            MessageManager.MessageBuff.Append(\"The active document is not a family document. \\n\");\n            return false;\n         }\n\n         FamilyParameterAssigner assigner = new FamilyParameterAssigner(m_app.Application, doc);\n         // the parameters to be added are defined and recorded in a text file, read them from that file and load to memory\n         bool succeeded = assigner.LoadParametersFromFile();\n         if (!succeeded)\n         {\n            return false;\n         }\n\n         Transaction t = new Transaction(doc, Guid.NewGuid().GetHashCode().ToString());\n         t.Start();\n         succeeded = assigner.AddParameters();\n         if (succeeded)\n         {\n            t.Commit();\n            return true;\n         }\n         else\n         {\n            t.RollBack();\n            return false;\n         }\n      }\n   } // end of class \"AddParameterToFamily\"\n\n   /// <summary>\n   /// A class inherits IExternalCommand interface.\n   /// this class read parameter data from txt files and add them to the family files in a folder.\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   [Autodesk.Revit.Attributes.Journaling(Autodesk.Revit.Attributes.JournalingMode.NoCommandData)]\n   public class AddParameterToFamilies : IExternalCommand\n   {\n      // the active Revit application\n      private Autodesk.Revit.ApplicationServices.Application m_app;\n\n      /// <summary>\n      /// Implement this method as an external command for Revit.\n      /// </summary>\n      /// <param name=\"commandData\">An object that is passed to the external application \n      /// which contains data related to the command, \n      /// such as the application object and active view.</param>\n      /// <param name=\"message\">A message that can be set by the external application \n      /// which will be displayed if a failure or cancellation is returned by \n      /// the external command.</param>\n      /// <param name=\"elements\">A set of elements to which the external application \n      /// can add elements that are to be highlighted in case of failure or cancellation.</param>\n      /// <returns>Return the status of the external command. \n      /// A result of Succeeded means that the API external method functioned as expected. \n      /// Cancelled can be used to signify that the user cancelled the external operation \n      /// at some point. Failure should be returned if the application is unable to proceed with \n      /// the operation.</returns>\n      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                             ref string message,\n                                             ElementSet elements)\n      {\n         m_app = commandData.Application.Application;\n         MessageManager.MessageBuff = new StringBuilder();\n\n         try\n         {\n            bool succeeded = LoadFamiliesAndAddParameters();\n\n            if (succeeded)\n            {\n               return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            else\n            {\n               message = MessageManager.MessageBuff.ToString();\n               return Autodesk.Revit.UI.Result.Failed;\n            }\n         }\n         catch (Exception e)\n         {\n            message = e.Message;\n            return Autodesk.Revit.UI.Result.Failed;\n         }\n      }\n\n      /// <summary>\n      /// search for the family files and the corresponding parameter records\n      /// load each family file, add parameters and then save and close.\n      /// </summary>\n      /// <returns>\n      /// if succeeded, return true; otherwise false\n      /// </returns>\n      private bool LoadFamiliesAndAddParameters()\n      {\n         bool succeeded = true;\n\n         List<string> famFilePaths = new List<string>();\n\n         Environment.SpecialFolder myDocumentsFolder = Environment.SpecialFolder.MyDocuments;\n         string myDocs = Environment.GetFolderPath(myDocumentsFolder);\n         string families = myDocs + \"\\\\AutoParameter_Families\";\n         if (!Directory.Exists(families))\n         {\n            MessageManager.MessageBuff.Append(\"The folder [AutoParameter_Families] doesn't exist in [MyDocuments] folder.\\n\");\n         }\n         DirectoryInfo familiesDir = new DirectoryInfo(families);\n         FileInfo[] files = familiesDir.GetFiles(\"*.rfa\");\n         if (0 == files.Length)\n         {\n            MessageManager.MessageBuff.Append(\"No family file exists in [AutoParameter_Families] folder.\\n\");\n         }\n         foreach (FileInfo info in files)\n         {\n            if (info.IsReadOnly)\n            {\n               MessageManager.MessageBuff.Append(\"Family file: \\\"\" + info.FullName + \"\\\" is read only. Can not add parameters to it.\\n\");\n               continue;\n            }\n\n            string famFilePath = info.FullName;\n            Document doc = m_app.OpenDocumentFile(famFilePath);\n\n            if (!doc.IsFamilyDocument)\n            {\n               succeeded = false;\n               MessageManager.MessageBuff.Append(\"Document: \\\"\" + famFilePath + \"\\\" is not a family document.\\n\");\n               continue;\n            }\n            \n            // return and report the errors\n            if (!succeeded)\n            {\n               return false;\n            }\n\n            FamilyParameterAssigner assigner = new FamilyParameterAssigner(m_app, doc);\n            // the parameters to be added are defined and recorded in a text file, read them from that file and load to memory\n            succeeded = assigner.LoadParametersFromFile();\n            if (!succeeded)\n            {\n               MessageManager.MessageBuff.Append(\"Failed to load parameters from parameter files.\\n\");\n               return false;\n            }\n            Transaction t = new Transaction(doc, Guid.NewGuid().GetHashCode().ToString());\n            t.Start();\n            succeeded = assigner.AddParameters();\n            if (succeeded)\n            {\n               t.Commit();\n               doc.Save();\n               doc.Close();\n            }\n            else\n            {\n               t.RollBack();\n               doc.Close();\n               MessageManager.MessageBuff.Append(\"Failed to add parameters to \" + famFilePath + \".\\n\");\n               return false;\n            }\n         }\n         return true;\n      }\n   } // end of class \"AddParameterToFamilies\"\n\n   /// <summary>\n   /// store the warning/error messeges when executing the sample\n   /// </summary>\n   static class MessageManager\n   {\n      static StringBuilder m_messageBuff = new StringBuilder();\n      /// <summary>\n      /// store the warning/error messages\n      /// </summary>\n      public static StringBuilder MessageBuff\n      {\n         get \n         { \n            return m_messageBuff; \n         }\n         set \n         { \n            m_messageBuff = value; \n         }\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_AutoParameter.rtf": "Summary: This sample demonstrates how to automatically add parameters (shared or not) to family documents.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.Document\nAutodesk.Revit.DB.FamilyManager\nAutodesk.Revit.DB.FamilyParameter\nAutodesk.Revit.DB.ExternalDefinition\n\nProject Files: \nCommand.cs\n      This file contains 2 classes: AddParameterToFamily and AddParameterToFamilies. AddParameterToFamily implements the Execute method and be used to add parameters to the active family document. AddParameterToFamilies implements the Execute method and be used to add parameters to all families in the “AutoParameter_Families” folder under “My Documents” folder.\nFamilyParameterAssigner.cs\n      This file contains the class FamilyParameterAssigner. This class adds all the parameters to the family file.\n\nDescription: This sample utilizes FamilyManager class to implement the features: add parameters (shared or not) to the specified family file.\n-\tTo add family parameters, use the AddParameter(String paramName, BuiltInParameterGroup paramGroup, ParameterType paramType, bool isInstance) method;\n-\tTo add shared parameters, use the AddParameter(ExternalDefinition familyDefinition, BuiltInParameterGroup paramGroup, bool isInstance) method;\n\nInstructions: \n1.\tIn order to auto-add parameters to family files, user should prepare the parameter files: family parameter file and shared parameter file.\nThe family parameter file should be named as “familyParameter.txt” and put in the same folder as the sample DLL. \nThe shared parameter file should be named as “sharedParameter.txt” and put in the same folder as the sample DLL.\nHere is a sample for how to organize the files:\n\nRootFolder:\n│  AutoParameter.dll\t   (this is the sample DLL)\n    │      SharedParameter.txt\n    │       FamilyParameter.txt\n\n2.\tThe format for the parameter files: for shared parameter file, it follows the format of Revit shared parameter file; for family parameter file, it has a similar format: Every line starts with “#” or “*” will be treated as the comment line and will be skipped, every parameter line should follow this format: “ParamName\tParamGroup\tParamType\tIsInstance”, and be separated by spaces.\nHere is a template for the family parameter file: \n# This is a Revit family parameter file.\n# allows to edit manually.\n# make sure the \"ParamGroup\" and \"ParamType\" values are correct (with or without #\"BuiltInParameterGroup.\" and \"ParameterType.\" doesn't affect the features).\n\n*ParamName\tParamGroup\tParamType\tIsInstance\nFamilyParam1\tPG_TEXT\t\tText\tfalse\nFamilyParam2\tBuiltInParameterGroup.PG_TEXT\tParameterType.Text\ttrue\n\n3.\tIn order to add parameters to a family file, Launch Revit, open the family file, and click the external command “AddParameterToFamily”, all parameters (shared or not) will be added to the active family document;\n4.\tIn order to add parameters to multiple family files, need to follow the steps:\na)\tCreate a folder “AutoParameter_Families” in “My Documents” folder;\nb)\tPut all the family files into that new folder, make sure all files are write-able (if some files are read-only, the parameters can’t be added in.);\nc)\tLaunch Revit, create a project, click the external command “AddParameterToFamilies”, all the parameters will be added to all the family files in the “AutoParameter_Families” folder",
      "FamilyParameter.txt": "# This is a Revit family parameter file.\n# allows to edit manually.\n# make sure the \"ParamGroup\" and \"ParamType\" values are correct.\n\n       \n*ParamName\tParamGroup\tParamType\tIsInstance\nFamilyParam1\tautodesk.parameter.group:text-1.0.0\t\tautodesk.spec:spec.string-1.0.0\tfalse\nFamilyParam2\tautodesk.parameter.group:text-1.0.0\t\tautodesk.spec:spec.string-1.0.0\ttrue",
      "SharedParameter.txt": "#\u0000 \u0000T\u0000h\u0000i\u0000s\u0000 \u0000i\u0000s\u0000 \u0000a\u0000 \u0000R\u0000e\u0000v\u0000i\u0000t\u0000 \u0000s\u0000h\u0000a\u0000r\u0000e\u0000d\u0000 \u0000p\u0000a\u0000r\u0000a\u0000m\u0000e\u0000t\u0000e\u0000r\u0000 \u0000f\u0000i\u0000l\u0000e\u0000.\u0000\n\u0000\n\u0000#\u0000 \u0000D\u0000o\u0000 \u0000n\u0000o\u0000t\u0000 \u0000e\u0000d\u0000i\u0000t\u0000 \u0000m\u0000a\u0000n\u0000u\u0000a\u0000l\u0000l\u0000y\u0000.\u0000\n\u0000\n\u0000*\u0000M\u0000E\u0000T\u0000A\u0000\t\u0000V\u0000E\u0000R\u0000S\u0000I\u0000O\u0000N\u0000\t\u0000M\u0000I\u0000N\u0000V\u0000E\u0000R\u0000S\u0000I\u0000O\u0000N\u0000\n\u0000\n\u0000M\u0000E\u0000T\u0000A\u0000\t\u00002\u0000\t\u00001\u0000\n\u0000\n\u0000*\u0000G\u0000R\u0000O\u0000U\u0000P\u0000\t\u0000I\u0000D\u0000\t\u0000N\u0000A\u0000M\u0000E\u0000\n\u0000\n\u0000G\u0000R\u0000O\u0000U\u0000P\u0000\t\u00001\u0000\t\u0000G\u0000r\u0000o\u0000u\u0000p\u00001\u0000\n\u0000\n\u0000*\u0000P\u0000A\u0000R\u0000A\u0000M\u0000\t\u0000G\u0000U\u0000I\u0000D\u0000\t\u0000N\u0000A\u0000M\u0000E\u0000\t\u0000D\u0000A\u0000T\u0000A\u0000T\u0000Y\u0000P\u0000E\u0000\t\u0000D\u0000A\u0000T\u0000A\u0000C\u0000A\u0000T\u0000E\u0000G\u0000O\u0000R\u0000Y\u0000\t\u0000G\u0000R\u0000O\u0000U\u0000P\u0000\t\u0000V\u0000I\u0000S\u0000I\u0000B\u0000L\u0000E\u0000\n\u0000\n\u0000P\u0000A\u0000R\u0000A\u0000M\u0000\t\u00008\u00005\u00008\u0000b\u0000d\u00007\u0000e\u0000d\u0000-\u00005\u0000a\u0000c\u0000f\u0000-\u00004\u0000d\u00002\u00000\u0000-\u00009\u0000d\u00007\u0000c\u0000-\u00003\u00001\u00002\u00006\u00009\u0000a\u00000\u0000c\u00000\u0000e\u00009\u0000a\u0000\t\u0000S\u0000h\u0000a\u0000r\u0000e\u0000d\u0000_\u0000L\u0000e\u0000n\u0000g\u0000t\u0000h\u0000\t\u0000L\u0000E\u0000N\u0000G\u0000..."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\FamilyCreation\\CreateAirHandler\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message,\n          ElementSet elements)\n      {\n         // set out default result to failure.\n         Autodesk.Revit.UI.Result retRes = Autodesk.Revit.UI.Result.Failed;\n         m_application = commandData.Application.Application;\n         m_document = commandData.Application.ActiveUIDocument.Document;\n         f = m_document.FamilyCreate;\n         extrusions = new Extrusion[5];\n         m_combineElements = new CombinableElementArray();\n\n         m_transaction = new Transaction(m_document, \"External Tool\");\n         m_transaction.Start();\n\n         if (m_document.OwnerFamily.FamilyCategory.Name !=\n             m_document.Settings.Categories.get_Item(BuiltInCategory.OST_MechanicalEquipment).Name) // FamilyCategory.Name is not \"Mechanical Equipment\".\n         {\n            message = \"Please make sure you opened a template of Mechanical Equipment.\";\n            return retRes;\n         }\n\n         try\n         {\n            CreateExtrusions();\n            m_document.Regenerate();\n            CreateConnectors();\n            m_document.Regenerate();\n            m_document.CombineElements(m_combineElements);\n            m_document.Regenerate();\n         }\n         catch (Exception x)\n         {\n            m_transaction.RollBack();\n            message = x.Message;\n            return retRes;\n         }\n\n         m_transaction.Commit();\n\n         retRes = Autodesk.Revit.UI.Result.Succeeded;\n         return retRes;\n      }\n      #endregion\n\n      /// <summary>\n      /// get all planar faces of an extrusion\n      /// </summary>\n      /// <param name=\"extrusion\">the extrusion to read</param>\n      /// <returns>a list of all planar faces of the extrusion</returns>\n      public List<PlanarFace> GetPlanarFaces(Extrusion extrusion)\n      {\n         // the option to get geometry elements\n         Options m_geoOptions = m_application.Create.NewGeometryOptions();\n         m_geoOptions.View = m_document.ActiveView;\n         m_geoOptions.ComputeReferences = true;\n\n         // get the planar faces\n         List<PlanarFace> m_planarFaces = new List<PlanarFace>();\n         Autodesk.Revit.DB.GeometryElement geoElement = extrusion.get_Geometry(m_geoOptions);\n         //foreach (GeometryObject geoObject in geoElement.Objects)\n         IEnumerator<GeometryObject> Objects = geoElement.GetEnumerator();\n         while (Objects.MoveNext())\n         {\n            GeometryObject geoObject = Objects.Current;\n\n            Solid geoSolid = geoObject as Solid;\n            if (null == geoSolid)\n            {\n               continue;\n            }\n            foreach (Face geoFace in geoSolid.Faces)\n            {\n               if (geoFace is PlanarFace)\n               {\n                  m_planarFaces.Add(geoFace as PlanarFace);\n               }\n            }\n         }\n         return m_planarFaces;\n      }\n\n      /// <summary>\n      /// create the extrusions of the air handler system\n      /// </summary>\n      private void CreateExtrusions()\n      {\n         Autodesk.Revit.Creation.Application app = m_application.Create;\n         CurveArray curves = null;\n         CurveArrArray profile = null;\n         Plane plane = null;\n         SketchPlane sketchPlane = null;\n\n         #region Create the cuboid extrusions\n\n         for (int i = 0; i <= 2; ++i)\n         {\n            // create the profile\n            curves = app.NewCurveArray();\n            curves.Append(Line.CreateBound(profileData[i, 0], profileData[i, 1]));\n            curves.Append(Line.CreateBound(profileData[i, 1], profileData[i, 2]));\n            curves.Append(Line.CreateBound(profileData[i, 2], profileData[i, 3]));\n            curves.Append(Line.CreateBound(profileData[i, 3], profileData[i, 0]));\n            profile = app.NewCurveArrArray();\n            profile.Append(curves);\n\n            // create the sketch plane\n            plane = Plane.CreateByNormalAndOrigin(sketchPlaneData[i, 0], sketchPlaneData[i, 1]);\n            sketchPlane = SketchPlane.Create(m_document, plane);\n\n            // create the extrusion\n            extrusions[i] = f.NewExtrusion(isSolid[i], profile, sketchPlane,\n                extrusionOffsets[i, 1]);\n            extrusions[i].StartOffset = extrusionOffsets[i, 0];\n            m_combineElements.Append(extrusions[i]);\n         }\n\n         #endregion\n\n         #region Create the round extrusions\n\n         for (int i = 3; i <= 4; ++i)\n         {\n            // create the profile\n            profile = app.NewCurveArrArray();\n\n            curves = app.NewCurveArray();\n            plane = Plane.CreateByNormalAndOrigin(profileData[i, 0], profileData[i, 1]);\n            curves.Append(Arc.Create(plane, arcRadius, 0, Math.PI * 2));\n            profile.Append(curves);\n\n                // create the sketch plane\n            plane = Plane.CreateByNormalAndOrigin(sketchPlaneData[i, 0], sketchPlaneData[i, 1]);\n            sketchPlane = SketchPlane.Create(m_document, plane);\n\n            // create the extrusion\n            extrusions[i] = f.NewExtrusion(isSolid[i], profile, sketchPlane,\n                extrusionOffsets[i, 1]);\n            extrusions[i].StartOffset = extrusionOffsets[i, 0];\n            m_combineElements.Append(extrusions[i]);\n         }\n\n         #endregion\n      }\n\n      /// <summary>\n      /// create the connectors on the extrusions\n      /// </summary>\n      private void CreateConnectors()\n      {\n         List<PlanarFace> m_planarFaces = null;\n         Parameter param = null;\n\n         #region Create the Supply Air duct connector\n\n         // get the planar faces of extrusion1\n         m_planarFaces = GetPlanarFaces(extrusions[1]);\n\n         // create the Supply Air duct connector\n         //DuctConnector connSupplyAir = f.NewDuctConnector(m_planarFaces[0].Reference,\n         //    DuctSystemType.SupplyAir);\n         ConnectorElement connSupplyAir = ConnectorElement.CreateDuctConnector(m_document, DuctSystemType.SupplyAir, ConnectorProfileType.Rectangular, m_planarFaces[0].Reference);\n         param = connSupplyAir.get_Parameter(BuiltInParameter.CONNECTOR_HEIGHT);\n         param.Set(connectorDimensions[0, 0]);\n         param = connSupplyAir.get_Parameter(BuiltInParameter.CONNECTOR_WIDTH);\n         param.Set(connectorDimensions[0, 1]);\n         param = connSupplyAir.get_Parameter(BuiltInParameter.RBS_DUCT_FLOW_DIRECTION_PARAM);\n         param.Set(2);\n         param = connSupplyAir.get_Parameter(BuiltInParameter.RBS_DUCT_FLOW_CONFIGURATION_PARAM);\n         param.Set(1);\n         param = connSupplyAir.get_Parameter(BuiltInParameter.RBS_DUCT_FLOW_PARAM);\n         param.Set(flow);\n\n         #endregion\n\n         #region Create the Return Air duct connector\n\n         // get the planar faces of extrusion2\n         m_planarFaces = GetPlanarFaces(extrusions[2]);\n\n         // create the Return Air duct connector\n         //DuctConnector connReturnAir = f.NewDuctConnector(m_planarFaces[0].Reference,\n         //    DuctSystemType.ReturnAir);\n         ConnectorElement connReturnAir = ConnectorElement.CreateDuctConnector(m_document, DuctSystemType.ReturnAir, ConnectorProfileType.Rectangular, m_planarFaces[0].Reference);\n         param = connReturnAir.get_Parameter(BuiltInParameter.CONNECTOR_HEIGHT);\n         param.Set(connectorDimensions[1, 0]);\n         param = connReturnAir.get_Parameter(BuiltInParameter.CONNECTOR_WIDTH);\n         param.Set(connectorDimensions[1, 1]);\n         param = connReturnAir.get_Parameter(BuiltInParameter.RBS_DUCT_FLOW_DIRECTION_PARAM);\n         param.Set(1);\n         param =\n             connReturnAir.get_Parameter(BuiltInParameter.RBS_DUCT_FLOW_CONFIGURATION_PARAM);\n         param.Set(1);\n         param = connReturnAir.get_Parameter(BuiltInParameter.RBS_DUCT_FLOW_PARAM);\n         param.Set(flow);\n\n         #endregion\n\n         #region Create the Supply Hydronic pipe connector\n\n         // get the planar faces of extrusion3\n         m_planarFaces = GetPlanarFaces(extrusions[3]);\n\n         // create the Hydronic Supply pipe connector\n         //PipeConnector connSupplyHydronic = f.NewPipeConnector(m_planarFaces[0].Reference,\n         //    PipeSystemType.SupplyHydronic);\n         ConnectorElement connSupplyHydronic = ConnectorElement.CreatePipeConnector(m_document, PipeSystemType.SupplyHydronic, m_planarFaces[0].Reference);\n         param = connSupplyHydronic.get_Parameter(BuiltInParameter.CONNECTOR_RADIUS);\n         param.Set(arcRadius);\n         param =\n             connSupplyHydronic.get_Parameter(BuiltInParameter.RBS_PIPE_FLOW_DIRECTION_PARAM);\n         param.Set(2);\n\n         #endregion\n\n         #region Create the Return Hydronic pipe connector\n\n         // get the planar faces of extrusion4\n         m_planarFaces = GetPlanarFaces(extrusions[4]);\n\n         // create the Hydronic Return pipe connector\n         //PipeConnector connReturnHydronic = f.NewPipeConnector(m_planarFaces[0].Reference,\n         //    PipeSystemType.ReturnHydronic);\n         ConnectorElement connReturnHydronic = ConnectorElement.CreatePipeConnector(m_document, PipeSystemType.ReturnHydronic, m_planarFaces[0].Reference);\n         param = connReturnHydronic.get_Parameter(BuiltInParameter.CONNECTOR_RADIUS);\n         param.Set(arcRadius);\n         param =\n             connReturnHydronic.get_Parameter(BuiltInParameter.RBS_PIPE_FLOW_DIRECTION_PARAM);\n         param.Set(1);\n\n         #endregion\n\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_CreateAirHandler.rtf": "Summary: This sample creates one air handler and adds connectors (piping, duct).\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.UI.UIDocument\nAutodesk.Revit.Creation.FamilyItemFactory\nAutodesk.Revit.DB.Extrusion\nAutodesk.Revit.DB.Mechanical.DuctConnector\nAutodesk.Revit.DB.Plumbing.PipeConnector\nAutodesk.Revit.DB.CombinableElement\n\nProject Files: \nCommand.cs\n      This file contains the class Command that inherits from IExternalCommand and implements the Execute method to create some extrusions and add connectors on them.\n\nDescription: This sample first utilizes the OwnerFamily.FamilyCategory property to check the template.\n\nAnd then this sample utilizes the NewExtrusion, NewPipeConnector, NewDuctConnector in Autodesk.Revit.Creation.FamilyItemFactory class to create handler and connectors, and utilizes xxxDuct properties to set proper parameters of connectors.\n\nFinally, this sample utilizes the method Document::CombineElements to join the extrusions in one air handler.\n\n\nInstructions: \nThis external command can be run on Revit family.\n1.\tUpdate your Revit.ini by following lines: \n[ExternalCommands]\nECCount        = 1\nECName1        = Create Air Handler\nECClassName1   = Revit.SDK.Samples.CreateAirHandler.CS.Command\nECAssembly1    = <your path>\\CreateAirHandler.dll\nECDescription1 = Create one air handler and add connectors.\n2.\tCreate a Revit family with “Mechanical Equipment” template file.\n3.\tRun this external command and the air handler is created. \n \n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\FamilyCreation\\CreateTruss\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData revit,\n                                                            ref string message,\n                                                            ElementSet elements)\n      {\n         try\n         {\n            m_application = revit.Application.Application;\n            m_document = revit.Application.ActiveUIDocument.Document;\n\n            // it can support in truss family document only\n            if (!m_document.IsFamilyDocument\n                || m_document.OwnerFamily.FamilyCategory.BuiltInCategory != BuiltInCategory.OST_Truss)\n            {\n               message = \"Cannot execute truss creation in non-truss family document\";\n               return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            m_appCreator = m_application.Create;\n            m_familyCreator = m_document.FamilyCreate;\n\n            Transaction newTran = new Transaction(m_document);\n            newTran.Start(\"NewTrussCurve\");\n\n            // Start the truss creation\n            MakeNewTruss();\n\n            newTran.Commit();\n         }\n         catch (Exception ex)\n         {\n            message = ex.ToString();\n            return Autodesk.Revit.UI.Result.Failed;\n         }\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n\n      /// <summary>\n      /// Example demonstrating truss creation in the Autodesk Revit API. This example constructs\n      /// a \"mono\" truss aligned with the reference planes in the (already loaded) truss family\n      /// document.\n      /// </summary>\n      private void MakeNewTruss()\n      {\n         // Constants for arranging the angular truss members\n         double webAngle = 35.0;\n         double webAngleRadians = (180 - webAngle) * Math.PI / 180.0;\n         Autodesk.Revit.DB.XYZ angleDirection = new Autodesk.Revit.DB.XYZ(Math.Cos(webAngleRadians), Math.Sin(webAngleRadians), 0);\n\n         // Look up the reference planes and view in which to sketch \n         ReferencePlane top = null, bottom = null, left = null, right = null, center = null;\n         View level1 = null;\n         List<Autodesk.Revit.DB.Element> elements = new List<Autodesk.Revit.DB.Element>();\n         ElementClassFilter refPlaneFilter = new ElementClassFilter(typeof(ReferencePlane));\n         ElementClassFilter viewFilter = new ElementClassFilter(typeof(View));\n         LogicalOrFilter filter = new LogicalOrFilter(refPlaneFilter, viewFilter);\n         FilteredElementCollector collector = new FilteredElementCollector(m_document);\n         elements.AddRange(collector.WherePasses(filter).ToElements());\n         foreach (Element e in elements)\n         {\n            // skip view templates because they're invisible invalid for truss creation\n            View view = e as View;\n            if (null != view && view.IsTemplate)\n               continue;\n            //\n            switch (e.Name)\n            {\n               case \"Top\": top = e as ReferencePlane; break;\n               case \"Bottom\": bottom = e as ReferencePlane; break;\n               case \"Right\": right = e as ReferencePlane; break;\n               case \"Left\": left = e as ReferencePlane; break;\n               case \"Center\": center = e as ReferencePlane; break;\n               case \"Level 1\": level1 = e as View; break;\n            }\n         }\n         if (top == null || bottom == null || left == null\n             || right == null || center == null || level1 == null)\n            throw new InvalidOperationException(\"Could not find prerequisite named reference plane or named view.\");\n\n         SketchPlane sPlane = level1.SketchPlane;\n\n         // Extract the geometry of each reference plane\n         Line bottomLine = GetReferencePlaneLine(bottom);\n         Line leftLine = GetReferencePlaneLine(left);\n         Line rightLine = GetReferencePlaneLine(right);\n         Line topLine = GetReferencePlaneLine(top);\n         Line centerLine = GetReferencePlaneLine(center);\n\n         // Create bottom chord along \"bottom\" from \"left\" to \"right\"\n         Autodesk.Revit.DB.XYZ bottomLeft = GetIntersection(bottomLine, leftLine);\n         Autodesk.Revit.DB.XYZ bottomRight = GetIntersection(bottomLine, rightLine);\n         ModelCurve bottomChord = MakeTrussCurve(bottomLeft, bottomRight, sPlane, TrussCurveType.BottomChord);\n         if (null != bottomChord)\n         {\n            // Add the alignment constraint to the bottom chord.\n            Curve geometryCurve = bottomChord.GeometryCurve;\n            // Lock the bottom chord to bottom reference plan\n            m_familyCreator.NewAlignment(level1, bottom.GetReference(), geometryCurve.Reference);\n         }\n\n         // Create web connecting top and bottom chords on the right side\n         Autodesk.Revit.DB.XYZ topRight = GetIntersection(topLine, rightLine);\n         ModelCurve rightWeb = MakeTrussCurve(bottomRight, topRight, sPlane, TrussCurveType.Web);\n         if (null != rightWeb)\n         {\n            // Add the alignment constraint to the right web chord.\n            Curve geometryCurve = rightWeb.GeometryCurve;\n            // Lock the right web chord to right reference plan\n            m_familyCreator.NewAlignment(level1, right.GetReference(), geometryCurve.Reference);\n         }\n\n         // Create top chord diagonally from bottom-left to top-right\n         ModelCurve topChord = MakeTrussCurve(bottomLeft, topRight, sPlane, TrussCurveType.TopChord);\n         if (null != topChord)\n         {\n            // Add the alignment constraint to the top chord.\n            Curve geometryCurve = topChord.GeometryCurve;\n            // Lock the start point of top chord to the Intersection of left and bottom reference plan\n            m_familyCreator.NewAlignment(level1, geometryCurve.GetEndPointReference(0), left.GetReference());\n            m_familyCreator.NewAlignment(level1, geometryCurve.GetEndPointReference(0), bottom.GetReference());\n            // Lock the end point of top chord to the Intersection of right and top reference plan\n            m_familyCreator.NewAlignment(level1, geometryCurve.GetEndPointReference(1), top.GetReference());\n            m_familyCreator.NewAlignment(level1, geometryCurve.GetEndPointReference(1), right.GetReference());\n         }\n\n         // Create angled web from midpoint to the narrow end of the truss\n         Autodesk.Revit.DB.XYZ bottomMidPoint = GetIntersection(bottomLine, centerLine);\n         Line webDirection = Line.CreateUnbound(bottomMidPoint, angleDirection);\n         Autodesk.Revit.DB.XYZ endOfWeb = GetIntersection(topChord.GeometryCurve as Line, webDirection);\n         ModelCurve angledWeb = MakeTrussCurve(bottomMidPoint, endOfWeb, sPlane, TrussCurveType.Web);\n\n         // Add a dimension to force the angle to be stable even when truss length and height are modified\n         Arc dimensionArc = Arc.Create(\n             bottomMidPoint, angledWeb.GeometryCurve.Length / 2, webAngleRadians, Math.PI, Autodesk.Revit.DB.XYZ.BasisX, Autodesk.Revit.DB.XYZ.BasisY);\n         Dimension createdDim = m_familyCreator.NewAngularDimension(\n             level1, dimensionArc, angledWeb.GeometryCurve.Reference, bottomChord.GeometryCurve.Reference);\n         if (null != createdDim)\n            createdDim.IsLocked = true;\n\n         // Create angled web from corner to top of truss\n         Autodesk.Revit.DB.XYZ bottomRight2 = GetIntersection(bottomLine, rightLine);\n         webDirection = Line.CreateUnbound(bottomRight2, angleDirection);\n         endOfWeb = GetIntersection(topChord.GeometryCurve as Line, webDirection);\n         ModelCurve angledWeb2 = MakeTrussCurve(bottomRight, endOfWeb, sPlane, TrussCurveType.Web);\n\n         // Add a dimension to force the angle to be stable even when truss length and height are modified\n         dimensionArc = Arc.Create(\n             bottomRight, angledWeb2.GeometryCurve.Length / 2, webAngleRadians, Math.PI, Autodesk.Revit.DB.XYZ.BasisX, Autodesk.Revit.DB.XYZ.BasisY);\n         createdDim = m_familyCreator.NewAngularDimension(\n             level1, dimensionArc, angledWeb2.GeometryCurve.Reference, bottomChord.GeometryCurve.Reference);\n         if (null != createdDim)\n            createdDim.IsLocked = true;\n\n         //Connect bottom midpoint to end of the angled web\n         ModelCurve braceWeb = MakeTrussCurve(bottomMidPoint, endOfWeb, sPlane, TrussCurveType.Web);\n      }\n\n      /// <summary>\n      /// Utility method to create a truss model curve.\n      /// </summary>\n      /// <param name=\"start\">The start point.</param>\n      /// <param name=\"end\">The end point.</param>\n      /// <param name=\"sketchPlane\">The sketch plane for the new curve.</param>\n      /// <param name=\"type\">The type of truss curve.</param>\n      /// <returns>the created truss model curve.</returns>\n      private ModelCurve MakeTrussCurve(Autodesk.Revit.DB.XYZ start, Autodesk.Revit.DB.XYZ end, SketchPlane sketchPlane, TrussCurveType type)\n      {\n         Line line = Line.CreateBound(start, end);\n         ModelCurve trussCurve = m_familyCreator.NewModelCurve(line, sketchPlane);\n         trussCurve.TrussCurveType = type;\n         m_document.Regenerate();\n\n         return trussCurve;\n      }\n\n      /// <summary>\n      /// Utility method for to extract the geometry of a reference plane in a family.\n      /// </summary>\n      /// <param name=\"plane\">The reference plane.</param>\n      /// <returns>An unbounded line representing the location of the plane.</returns>\n      private Line GetReferencePlaneLine(ReferencePlane plane)\n      {\n         // Reset the \"elevation\" of the plane's line to Z=0, since that's where the lines will be placed.  \n         // Otherwise, some intersection calculation may fail\n         Autodesk.Revit.DB.XYZ origin = new XYZ(\n             plane.BubbleEnd.X,\n             plane.BubbleEnd.Y,\n             0.0);\n\n         Line line = Line.CreateUnbound(origin, plane.Direction);\n\n         return line;\n      }\n\n      /// <summary>\n      /// Utility method for getting the intersection between two lines.\n      /// </summary>\n      /// <param name=\"line1\">The first line.</param>\n      /// <param name=\"line2\">The second line.</param>\n      /// <returns>The intersection point.</returns>\n      /// <exception cref=\"InvalidOperationException\">Thrown when an intersection can't be found.</exception>\n      private Autodesk.Revit.DB.XYZ GetIntersection(Line line1, Line line2)\n      {\n         Autodesk.Revit.DB.CurveIntersectResult intersectResult = line1.Intersect(line2, CurveIntersectResultOption.Detailed);\n\n         if (intersectResult?.Result != Autodesk.Revit.DB.SetComparisonResult.Overlap)\n            throw new InvalidOperationException(\"Input lines did not intersect.\");\n\n         if (intersectResult.GetOverlaps()?.Count != 1)\n            throw new InvalidOperationException(\"Could not extract intersection point for lines.\");\n\n         Autodesk.Revit.DB.XYZ intersectionPoint = intersectResult.GetOverlaps()[0]?.Point;\n         if (intersectionPoint == null)\n         {\n            throw new ArgumentException(\"Bad Input.\");\n         }\n\n         return intersectionPoint;\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_CreateTruss.rtf": "Summary: This sample demonstrates how to create a mono truss in truss family document.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Document\nAutodesk.Revit.DB.ModelCurve\nAutodesk.Revit.DB.Family\nAutodesk.Revit.Creation.ItemFactoryBase\nAutodesk.Revit.Creation.FamilyItemFactory\n\n\nProject Files: \nCommand.cs\n      This file contains the class Command that inherits from IExternalCommand. The class implements the Execute method and be used to create a mono truss in truss family document.\n\nDescription: The sample utilizes the method NewModelCurve to create the truss curves and utilizes the TrussCurveType property of ModelCurve class to set their truss types.\nSome useful constraints are added to the truss curves by the method NewAlignment.\n\n\nInstructions: \nThis external command can be run on Revit family document.\n1.\tUpdate your Revit.ini by following lines: \n[ExternalCommands]\nECCount        = 1\nECName1        = Create Truss\nECClassName1   = Revit.SDK.Samples.CreateTruss.CS.Command\nECAssembly1    = <your path>\\CreateTruss.dll\nECDescription1 = Create truss in truss family document.\n2.\tStart Revit.\n3.\tIn order to use the sample, the user should manually create a family document with structural trusses template. If the template is not right, the command will fail.\n4.\tRun this external command and a mono truss is created in truss family document.\n \n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\FamilyCreation\\DWGFamilyCreation\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n        ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            try\n            {\n                m_app = commandData.Application;\n                m_doc = commandData.Application.ActiveUIDocument.Document;\n                if (null == m_doc)\n                {\n                    message = \"There is no active document.\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                if (!m_doc.IsFamilyDocument)\n                {\n                    message = \"Current document is not a family document.\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                // Get the view where the dwg file will be imported\n                View view = GetView();\n                if (null == view)\n                {\n                    message = \"Opened wrong template file, please use the provided family template file.\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                // The dwg file which will be imported\n                string AssemblyDirectory = Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);\n                string DWGFile = \"Desk.dwg\";\n                string DWGFullPath = Path.Combine(AssemblyDirectory, DWGFile);\n\n                Transaction transaction = new Transaction(m_doc, \"DWGFamilyCreation\");\n                transaction.Start();\n                // Import the dwg file into current family document\n                DWGImportOptions options = new DWGImportOptions();\n                options.Placement = Autodesk.Revit.DB.ImportPlacement.Origin;\n                options.OrientToView = true;\n                ElementId elementId = null;\n                m_doc.Import(DWGFullPath, options, view, out elementId);\n\n                // Add type parameters to the family\n                AddParameters(DWGFile);\n                transaction.Commit();\n            }\n            catch (Exception ex)\n            {\n                message = ex.ToString();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        /// <summary>\n        /// Add type parameters to the family\n        /// </summary>\n        /// <param name=\"DWGFileName\">Name of imported dwg file</param>\n        private void AddParameters(string DWGFileName)\n        {\n            // Get the family manager\n            FamilyManager familyMgr = m_doc.FamilyManager;\n\n            // Add parameter 1: DWGFileName\n            familyMgr.NewType(\"DWGFamilyCreation\");\n            FamilyParameter paraFileName = familyMgr.AddParameter(\"DWGFileName\", new ForgeTypeId(),\n                SpecTypeId.String.Text, false);\n            familyMgr.Set(paraFileName, DWGFileName);\n\n            // Add parameter 2: ImportTime\n            String time = DateTime.Now.ToString(\"yyyy-MM-dd\");\n            FamilyParameter paraImportTime = familyMgr.AddParameter(\"ImportTime\", new ForgeTypeId(),\n                SpecTypeId.String.Text, false);\n            familyMgr.Set(paraImportTime, time);\n        }\n\n        /// <summary>\n        /// Get the view where the dwg file will be imported\n        /// </summary>\n        /// <returns>The view where the dwg file will be imported</returns>\n        private View GetView()\n        {\n            View view = null;\n            List<Autodesk.Revit.DB.Element> views = new List<Autodesk.Revit.DB.Element>();\n            FilteredElementCollector collector = new FilteredElementCollector(m_app.ActiveUIDocument.Document);\n            views.AddRange(collector.OfClass(typeof(View)).ToElements());\n            foreach (View v in views)\n            {\n                if (!v.IsTemplate && v.ViewType == Autodesk.Revit.DB.ViewType.FloorPlan && v.Name == \"Ref. Level\")\n                {\n                    view = v;\n                    break;\n                }\n            }\n\n            return view;\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_DWGFamilyCreation.rtf": "Summary: This sample shows how to import a dwg file into a family document and add parameters to the family through Revit API.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB\n\nProject Files: \nCommand.cs\nIt contains the class Command which inherits from interface IExternalCommand and implements the Execute method.\n\nDescription: This sample provides following functionalities.\n-\tLet user import a dwg file into a Revit family document.\n-\tLet user add parameters to the imported instance. \n\nInstructions: \n1. Put the provided desk.dwg file and dll file of the sample under same folder.\n2. Open Revit application, create a new family with the provided family template file “Furniture.rft” or open the provided family file “Furniture.rfa”.\n3. Execute the command.\nExpected result: The provided dwg file “Desk.dwg” is imported into the family document and two type parameters are added to the famiy - “DWGFileName” with the value of the dwg file name and “ImportTime” of import time."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\FamilyCreation\\GenericModelCreation\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                             ref string message,\n                                             ElementSet elements)\n      {\n         try\n         {\n            m_revit = commandData.Application.Application;\n            m_familyDocument = commandData.Application.ActiveUIDocument.Document;\n            // create new family document if active document is not a family document\n            if (!m_familyDocument.IsFamilyDocument)\n            {\n               m_familyDocument = m_revit.NewFamilyDocument(\"Generic Model.rft\");\n               if (null == m_familyDocument)\n               {\n                  message = \"Cannot open family document\";\n                  return Autodesk.Revit.UI.Result.Failed;\n               }\n            }\n            m_creationFamily = m_familyDocument.FamilyCreate;\n            // create generic model family in the document\n            CreateGenericModel();\n            if (0 == m_errCount)\n            {\n               return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            else\n            {\n               message = m_errorInfo;\n               return Autodesk.Revit.UI.Result.Failed;\n            }\n         }\n         catch (Exception e)\n         {\n            message = e.ToString();\n            return Autodesk.Revit.UI.Result.Failed;\n         }\n\n      }\n      #endregion\n\n      #region Class Implementation\n\n      /// <summary>\n      /// Examples for form creation in generic model families.\n      /// Create extrusion, blend, revolution, sweep, swept blend\n      /// </summary>\n      public void CreateGenericModel()\n      {\n         // use transaction if the family document is not active document\n         Transaction transaction = new Transaction(m_familyDocument, \"CreateGenericModel\");\n         transaction.Start();\n         CreateExtrusion();\n         CreateBlend();\n         CreateRevolution();\n         CreateSweep();\n         CreateSweptBlend();\n         transaction.Commit();\n         return;\n      }\n\n      /// <summary>\n      /// Create one rectangular extrusion\n      /// </summary>\n      private void CreateExtrusion()\n      {\n         try\n         {\n            #region Create rectangle profile\n            CurveArrArray curveArrArray = new CurveArrArray();\n            CurveArray curveArray1 = new CurveArray();\n\n            Autodesk.Revit.DB.XYZ normal = Autodesk.Revit.DB.XYZ.BasisZ;\n            SketchPlane sketchPlane = CreateSketchPlane(normal, Autodesk.Revit.DB.XYZ.Zero);\n\n            // create one rectangular extrusion\n            Autodesk.Revit.DB.XYZ p0 = Autodesk.Revit.DB.XYZ.Zero;\n            Autodesk.Revit.DB.XYZ p1 = new Autodesk.Revit.DB.XYZ(10, 0, 0);\n            Autodesk.Revit.DB.XYZ p2 = new Autodesk.Revit.DB.XYZ(10, 10, 0);\n            Autodesk.Revit.DB.XYZ p3 = new Autodesk.Revit.DB.XYZ(0, 10, 0);\n            Line line1 = Line.CreateBound(p0, p1);\n            Line line2 = Line.CreateBound(p1, p2);\n            Line line3 = Line.CreateBound(p2, p3);\n            Line line4 = Line.CreateBound(p3, p0);\n            curveArray1.Append(line1);\n            curveArray1.Append(line2);\n            curveArray1.Append(line3);\n            curveArray1.Append(line4);\n\n            curveArrArray.Append(curveArray1);\n            #endregion\n            // here create rectangular extrusion\n            Extrusion rectExtrusion = m_creationFamily.NewExtrusion(true, curveArrArray, sketchPlane, 10);\n            // move to proper place\n            Autodesk.Revit.DB.XYZ transPoint1 = new Autodesk.Revit.DB.XYZ(-16, 0, 0);\n            ElementTransformUtils.MoveElement(m_familyDocument, rectExtrusion.Id, transPoint1);\n         }\n         catch (Exception e)\n         {\n            m_errCount++;\n            m_errorInfo += \"Unexpected exceptions occur in CreateExtrusion: \" + e.ToString() + \"\\r\\n\";\n         }\n      }\n\n      /// <summary>\n      /// Create one blend\n      /// </summary>\n      private void CreateBlend()\n      {\n         try\n         {\n            #region Create top and base profiles\n            CurveArray topProfile = new CurveArray();\n            CurveArray baseProfile = new CurveArray();\n\n            Autodesk.Revit.DB.XYZ normal = Autodesk.Revit.DB.XYZ.BasisZ;\n            SketchPlane sketchPlane = CreateSketchPlane(normal, Autodesk.Revit.DB.XYZ.Zero);\n\n            // create one blend\n            Autodesk.Revit.DB.XYZ p00 = Autodesk.Revit.DB.XYZ.Zero;\n            Autodesk.Revit.DB.XYZ p01 = new Autodesk.Revit.DB.XYZ(10, 0, 0);\n            Autodesk.Revit.DB.XYZ p02 = new Autodesk.Revit.DB.XYZ(10, 10, 0);\n            Autodesk.Revit.DB.XYZ p03 = new Autodesk.Revit.DB.XYZ(0, 10, 0);\n            Line line01 = Line.CreateBound(p00, p01);\n            Line line02 = Line.CreateBound(p01, p02);\n            Line line03 = Line.CreateBound(p02, p03);\n            Line line04 = Line.CreateBound(p03, p00);\n\n            baseProfile.Append(line01);\n            baseProfile.Append(line02);\n            baseProfile.Append(line03);\n            baseProfile.Append(line04);\n\n            Autodesk.Revit.DB.XYZ p10 = new Autodesk.Revit.DB.XYZ(5, 2, 10);\n            Autodesk.Revit.DB.XYZ p11 = new Autodesk.Revit.DB.XYZ(8, 5, 10);\n            Autodesk.Revit.DB.XYZ p12 = new Autodesk.Revit.DB.XYZ(5, 8, 10);\n            Autodesk.Revit.DB.XYZ p13 = new Autodesk.Revit.DB.XYZ(2, 5, 10);\n            Line line11 = Line.CreateBound(p10, p11);\n            Line line12 = Line.CreateBound(p11, p12);\n            Line line13 = Line.CreateBound(p12, p13);\n            Line line14 = Line.CreateBound(p13, p10);\n\n            topProfile.Append(line11);\n            topProfile.Append(line12);\n            topProfile.Append(line13);\n            topProfile.Append(line14);\n            #endregion\n            // here create one blend\n            Blend blend = m_creationFamily.NewBlend(true, topProfile, baseProfile, sketchPlane);\n            // move to proper place\n            Autodesk.Revit.DB.XYZ transPoint1 = new Autodesk.Revit.DB.XYZ(0, 11, 0);\n            ElementTransformUtils.MoveElement(m_familyDocument, blend.Id, transPoint1);\n         }\n         catch (Exception e)\n         {\n            m_errCount++;\n            m_errorInfo += \"Unexpected exceptions occur in CreateBlend: \" + e.ToString() + \"\\r\\n\";\n         }\n      }\n\n      /// <summary>\n      /// Create one rectangular profile revolution\n      /// </summary>\n      private void CreateRevolution()\n      {\n         try\n         {\n            #region Create rectangular profile\n            CurveArrArray curveArrArray = new CurveArrArray();\n            CurveArray curveArray = new CurveArray();\n\n            Autodesk.Revit.DB.XYZ normal = Autodesk.Revit.DB.XYZ.BasisZ;\n            SketchPlane sketchPlane = CreateSketchPlane(normal, Autodesk.Revit.DB.XYZ.Zero);\n\n            // create one rectangular profile revolution\n            Autodesk.Revit.DB.XYZ p0 = Autodesk.Revit.DB.XYZ.Zero;\n            Autodesk.Revit.DB.XYZ p1 = new Autodesk.Revit.DB.XYZ(10, 0, 0);\n            Autodesk.Revit.DB.XYZ p2 = new Autodesk.Revit.DB.XYZ(10, 10, 0);\n            Autodesk.Revit.DB.XYZ p3 = new Autodesk.Revit.DB.XYZ(0, 10, 0);\n            Line line1 = Line.CreateBound(p0, p1);\n            Line line2 = Line.CreateBound(p1, p2);\n            Line line3 = Line.CreateBound(p2, p3);\n            Line line4 = Line.CreateBound(p3, p0);\n\n            Autodesk.Revit.DB.XYZ pp = new Autodesk.Revit.DB.XYZ(1, -1, 0);\n            Line axis1 = Line.CreateBound(Autodesk.Revit.DB.XYZ.Zero, pp);\n            curveArray.Append(line1);\n            curveArray.Append(line2);\n            curveArray.Append(line3);\n            curveArray.Append(line4);\n\n            curveArrArray.Append(curveArray);\n            #endregion\n            // here create rectangular profile revolution\n            Revolution revolution1 = m_creationFamily.NewRevolution(true, curveArrArray, sketchPlane, axis1, -Math.PI, 0);\n            // move to proper place\n            Autodesk.Revit.DB.XYZ transPoint1 = new Autodesk.Revit.DB.XYZ(0, 32, 0);\n            ElementTransformUtils.MoveElement(m_familyDocument, revolution1.Id, transPoint1);\n         }\n         catch (Exception e)\n         {\n            m_errCount++;\n            m_errorInfo += \"Unexpected exceptions occur in CreateRevolution: \" + e.ToString() + \"\\r\\n\";\n         }\n      }\n\n      /// <summary>\n      /// Create one sweep\n      /// </summary>\n      private void CreateSweep()\n      {\n         try\n         {\n            #region Create rectangular profile and path curve\n            CurveArrArray arrarr = new CurveArrArray();\n            CurveArray arr = new CurveArray();\n\n            Autodesk.Revit.DB.XYZ normal = Autodesk.Revit.DB.XYZ.BasisZ;\n            SketchPlane sketchPlane = CreateSketchPlane(normal, Autodesk.Revit.DB.XYZ.Zero);\n\n            Autodesk.Revit.DB.XYZ pnt1 = new Autodesk.Revit.DB.XYZ(0, 0, 0);\n            Autodesk.Revit.DB.XYZ pnt2 = new Autodesk.Revit.DB.XYZ(2, 0, 0);\n            Autodesk.Revit.DB.XYZ pnt3 = new Autodesk.Revit.DB.XYZ(1, 1, 0);\n            arr.Append(Arc.Create(pnt2, 1.0d, 0.0d, 180.0d, Autodesk.Revit.DB.XYZ.BasisX, Autodesk.Revit.DB.XYZ.BasisY));\n            arr.Append(Arc.Create(pnt1, pnt3, pnt2));\n            arrarr.Append(arr);\n            SweepProfile profile = m_revit.Create.NewCurveLoopsProfile(arrarr);\n\n            Autodesk.Revit.DB.XYZ pnt4 = new Autodesk.Revit.DB.XYZ(10, 0, 0);\n            Autodesk.Revit.DB.XYZ pnt5 = new Autodesk.Revit.DB.XYZ(0, 10, 0);\n            Curve curve = Line.CreateBound(pnt4, pnt5);\n\n            CurveArray curves = new CurveArray();\n            curves.Append(curve);\n            #endregion\n            // here create one sweep with two arcs formed the profile\n            Sweep sweep1 = m_creationFamily.NewSweep(true, curves, sketchPlane, profile, 0, ProfilePlaneLocation.Start);\n            // move to proper place\n            Autodesk.Revit.DB.XYZ transPoint1 = new Autodesk.Revit.DB.XYZ(11, 0, 0);\n            ElementTransformUtils.MoveElement(m_familyDocument, sweep1.Id, transPoint1);\n         }\n         catch (Exception e)\n         {\n            m_errCount++;\n            m_errorInfo += \"Unexpected exceptions occur in CreateSweep: \" + e.ToString() + \"\\r\\n\";\n         }\n      }\n\n      /// <summary>\n      /// Create one SweptBlend\n      /// </summary>\n      private void CreateSweptBlend()\n      {\n         try\n         {\n            #region Create top and bottom profiles and path curve\n            Autodesk.Revit.DB.XYZ pnt1 = new Autodesk.Revit.DB.XYZ(0, 0, 0);\n            Autodesk.Revit.DB.XYZ pnt2 = new Autodesk.Revit.DB.XYZ(1, 0, 0);\n            Autodesk.Revit.DB.XYZ pnt3 = new Autodesk.Revit.DB.XYZ(1, 1, 0);\n            Autodesk.Revit.DB.XYZ pnt4 = new Autodesk.Revit.DB.XYZ(0, 1, 0);\n            Autodesk.Revit.DB.XYZ pnt5 = new Autodesk.Revit.DB.XYZ(0, 0, 1);\n\n            CurveArrArray arrarr1 = new CurveArrArray();\n            CurveArray arr1 = new CurveArray();\n            arr1.Append(Line.CreateBound(pnt1, pnt2));\n            arr1.Append(Line.CreateBound(pnt2, pnt3));\n            arr1.Append(Line.CreateBound(pnt3, pnt4));\n            arr1.Append(Line.CreateBound(pnt4, pnt1));\n            arrarr1.Append(arr1);\n\n            Autodesk.Revit.DB.XYZ pnt6 = new Autodesk.Revit.DB.XYZ(0.5, 0, 0);\n            Autodesk.Revit.DB.XYZ pnt7 = new Autodesk.Revit.DB.XYZ(1, 0.5, 0);\n            Autodesk.Revit.DB.XYZ pnt8 = new Autodesk.Revit.DB.XYZ(0.5, 1, 0);\n            Autodesk.Revit.DB.XYZ pnt9 = new Autodesk.Revit.DB.XYZ(0, 0.5, 0);\n            CurveArrArray arrarr2 = new CurveArrArray();\n            CurveArray arr2 = new CurveArray();\n            arr2.Append(Line.CreateBound(pnt6, pnt7));\n            arr2.Append(Line.CreateBound(pnt7, pnt8));\n            arr2.Append(Line.CreateBound(pnt8, pnt9));\n            arr2.Append(Line.CreateBound(pnt9, pnt6));\n            arrarr2.Append(arr2);\n\n            SweepProfile bottomProfile = m_revit.Create.NewCurveLoopsProfile(arrarr1);\n            SweepProfile topProfile = m_revit.Create.NewCurveLoopsProfile(arrarr2);\n\n            Autodesk.Revit.DB.XYZ pnt10 = new Autodesk.Revit.DB.XYZ(5, 0, 0);\n            Autodesk.Revit.DB.XYZ pnt11 = new Autodesk.Revit.DB.XYZ(0, 20, 0);\n            Curve curve = Line.CreateBound(pnt10, pnt11);\n\n            Autodesk.Revit.DB.XYZ normal = Autodesk.Revit.DB.XYZ.BasisZ;\n            SketchPlane sketchPlane = CreateSketchPlane(normal, Autodesk.Revit.DB.XYZ.Zero);\n            #endregion\n            // here create one swept blend\n            SweptBlend newSweptBlend1 = m_creationFamily.NewSweptBlend(true, curve, sketchPlane, bottomProfile, topProfile);\n            // move to proper place\n            Autodesk.Revit.DB.XYZ transPoint1 = new Autodesk.Revit.DB.XYZ(11, 32, 0);\n            ElementTransformUtils.MoveElement(m_familyDocument, newSweptBlend1.Id, transPoint1);\n         }\n         catch (Exception e)\n         {\n            m_errCount++;\n            m_errorInfo += \"Unexpected exceptions occur in CreateSweptBlend: \" + e.ToString() + \"\\r\\n\";\n         }\n      }\n\n\n      /// <summary>\n      /// Get element by its id\n      /// </summary>\n      private T GetElement<T>(long eid) where T : Autodesk.Revit.DB.Element\n      {\n         Autodesk.Revit.DB.ElementId elementId = new ElementId(eid);\n         return m_familyDocument.GetElement(elementId) as T;\n      }\n\n      /// <summary>\n      /// Create sketch plane for generic model profile\n      /// </summary>\n      /// <param name=\"normal\">plane normal</param>\n      /// <param name=\"origin\">origin point</param>\n      /// <returns></returns>\n      internal SketchPlane CreateSketchPlane(Autodesk.Revit.DB.XYZ normal, Autodesk.Revit.DB.XYZ origin)\n      {\n         // First create a Geometry.Plane which need in NewSketchPlane() method\n         Plane geometryPlane = Plane.CreateByNormalAndOrigin(normal, origin);\n         if (null == geometryPlane)  // assert the creation is successful\n         {\n            throw new Exception(\"Create the geometry plane failed.\");\n         }\n         // Then create a sketch plane using the Geometry.Plane\n         SketchPlane plane = SketchPlane.Create(m_familyDocument, geometryPlane);\n         // throw exception if creation failed\n         if (null == plane)\n         {\n            throw new Exception(\"Create the sketch plane failed.\");\n         }\n         return plane;\n      }\n\n      #endregion\n\n   }\n}"
    },
    "documentation": {
      "ReadMe_GenericModelCreation.rtf": "Summary: This sample shows how to create Generic Model through Revit API\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Document\nAutodesk.Revit.DB.ElementSet\nAutodesk.Revit.DB.GeometryObject\nAutodesk.Revit.Creation.FamilyItemFactory\n\nProject Files: \nCommand.cs\nThis file contains the class Command that inherits from IExternalCommand. The class implements the Execute method and be used to create family in Revit.\n\nDescription: This sample mostly uses the FamilyItemFactory class for implementing the functionality: creating Extrusion/ Blend/ Revolution/ Sweep/ SweptBlend elements.\n-\tTo get a SketchPlane, use CreateSketchPlane().\n-\tTo get a Curve, use Autodesk.Revit.Creation.Application.Create.NewLineBound () and Append it to a CurveArray to get the array.\n-\tAutodesk.Revit.Creation.FamilyItemFactory.NewXXXX() create families.\n\nInstructions: \n1.\tIn order to create a family, user should manually create a family document by a template document (Generic Model wall based.rft is attached).\n2.\tClick the extern command, five Generic Model elements should be created as Extrusion/ Blend/ Revolution/ Sweep/ SweptBlend."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\FamilyCreation\\TypeRegeneration\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                             ref string message,\n                                             ElementSet elements)\n        {\n            Document document;\n            string assemblyPath;\n            document = commandData.Application.ActiveUIDocument.Document;\n            assemblyPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n            m_logFileName = assemblyPath + \"\\\\RegenerationLog.txt\";   \n            //only a family document  can retrieve family manager\n            if (document.IsFamilyDocument)\n            {\n                m_familyManager = document.FamilyManager;\n                //create regeneration log file\n                StreamWriter writer = File.CreateText(m_logFileName);\n                writer.WriteLine(\"Family Type     Result\");\n                writer.WriteLine(\"-------------------------\");\n                writer.Close();\n                using(MessageForm msgForm=new MessageForm())\n                {\n                    msgForm.StartPosition = FormStartPosition.Manual;\n                    CheckTypeRegeneration(msgForm);                    \n                    return Autodesk.Revit.UI.Result.Succeeded;                   \n               }\n            }\n            else\n            {\n                message = \"please make sure you have opened a family document!\";\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n        #endregion\n\n        #region Class Implementation\n       /// <summary>\n        ///  After setting CurrentType property, the CurrentType has changed to the new one,the Revit model will change along with the current type\n       /// </summary>\n       /// <param name=\"msgForm\">the form is used to show the regeneration result</param>        \n        public void CheckTypeRegeneration(MessageForm msgForm)\n        {\n            //the list to record the error messages           \n            List<string> errorInfo = new List<string>(); \n            try\n            {\n                foreach (FamilyType type in m_familyManager.Types)\n                {\n                    if (!(type.Name.ToString().Trim()==\"\"))\n                    {\n                        try\n                        {\n                            m_familyManager.CurrentType = type;\n                            msgForm.AddMessage(type.Name+\" Successful\\n\",true);\n                            WriteLog(type.Name + \"      Successful\");\n                        }\n                        catch\n                        {\n                            errorInfo.Add(type.Name);\n                            msgForm.AddMessage(type.Name+\" Failed \\n\",true);\n                            WriteLog(type.Name + \"      Failed\");\n                        }\n                        msgForm.ShowDialog();\n                    }                  \n                }\n\n                //add a conclusion regeneration result\n                string resMsg;\n                if (errorInfo.Count > 0)\n                {\n                    resMsg = \"\\nResult: \" + errorInfo.Count + \" family types regeneration failed!\";\n                    foreach (string error in errorInfo)\n                    {\n                        resMsg += \"\\n \" + error;\n                    }\n                }\n                else\n                {\n                    resMsg = \"\\nResult: All types in the family can regenerate successfully.\";\n                }\n                WriteLog(resMsg.ToString());\n                resMsg += \"\\nIf you want to know the detail regeneration result please get log file at \"+m_logFileName;\n                msgForm.AddMessage(resMsg,false);\n                msgForm.ShowDialog();           \n            }\n            catch(Exception ex)\n            {\n                WriteLog(\"There is some problem when regeneration:\" + ex.ToString());\n                msgForm.AddMessage(\"There is some problem when regeneration:\"+ex.ToString(),true);\n                msgForm.ShowDialog();  \n            }\n        }\n\n        /// <summary>\n        /// The method to write line to log file\n        /// </summary>\n        /// <param name=\"logStr\">the log string</param>\n        private void WriteLog(string logStr)\n        {\n            StreamWriter writer = null;\n            writer = File.AppendText(m_logFileName);\n            writer.WriteLine(logStr);\n            writer.Close();\n        }       \n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_TypeRegeneration.rtf": "Description: This sample only can be used in family. This sample mostly uses FamilyManager class for implementing the functionality: Check if every type regeneration without any error or warning. Revit model will change to the next one. Finally, give a conclusion result: If all regeneration goes well, the user will get one message says ‘All types in the family can regenerate successfully.’ If there is any error result, one message about which type(s) have a problem will be shown. There is one log file that stores all information displayed in the form.\n-\tTo get or set the current type, use property CurrentType of the FamilyManager.\n-\tTo get all the family types, use property Types of the FamilyManager.\n\nInstructions: \n1.\tUpdate your Revit.ini by following lines: \n[ExternalCommands]\nECCount  = 1\nECClassName1  = Revit.SDK.Samples.TypeRegeneration.CS.Command\nECAssembly1  = <your path>\\TypeRegeneration.dll\n2.\tStart Revit.\n3.\tIn order to use a family, user should manually open a family document.\n4.\tRun the extern command TypeRegeneration.\n\n\n\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\FamilyCreation\\WindowWizard\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                             ref string message,\n                                             ElementSet elements)\n        {\n            Document doc = commandData.Application.ActiveUIDocument.Document;\n            //only a family document  can retrieve family manager\n            if (doc.IsFamilyDocument)\n            {\n                if (null != doc.OwnerFamily && null != doc.OwnerFamily.FamilyCategory \n                    && doc.OwnerFamily.FamilyCategory.Name != doc.Settings.Categories.get_Item(BuiltInCategory.OST_Windows).Name)\n                    // FamilyCategory.Name is not \"Windows\".\n                {\n                    message = \"Please make sure you opened a template of Window.\";\n                    return Autodesk.Revit.UI.Result.Failed;                   \n                }\n                WindowWizard wizard = new WindowWizard(commandData);\n                int result = wizard.RunWizard();\n                if (1 == result)\n                {\n                    return Autodesk.Revit.UI.Result.Succeeded;\n                }\n                else if (0 == result)\n                {\n                    message = \"Window Creation was cancelled.\";\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n                else\n                {\n                    message = \"Window Creation failed, please check your template and inputs then try again.\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }              \n            }\n            else\n            {\n                message = \"please make sure you have opened a family document!\";\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_WindowWizard.rtf": "Description: The sample implements IExternalCommand interface and allows user to create window family via wizard. User should create a family with window family template, and then user can input dimensions for window parameters, specify the materials, and save family file locally. \n-\tTo create Extrusion, use the method NewExtrusion of FamilyItemFactory.\n-\tTo create Alignment, use the method NewAlignment of FamilyItemFactory.\n-\tTo create Dimension, use the method NewDimension of FamilyItemFactory.\n-\tTo create ReferencePlane, use the method NewReferencePlane of FamilyItemFactory.\n-\tTo create family type, use the method NewType of FamilyItemFactory\n-\tTo get the materials, use the property Settings.Materials of document.\n-\tTo get the Categories, use the property Settings.Categories of document.\n\nInstructions: \n1.\tUpdate your Revit.ini by following lines: \n[ExternalCommands] \nECCount      = 1 \nECName1=WindowWizard\nECClassName1=Revit.SDK.Samples.WindowWizard.CS\nECAssembly1  = <your path>\\WindowWizard.dll \n2.\tStart Revit.\n3.\tIn order to use the wizard, users should manually create a family document with window template(like Window.rft). If the template is not right, the command will fail.\n4.\tLaunch WindowWizard via the external command menu.\n5.\tInput the window dimensions including type name, Height, Width, Inset and Sill Height. You can click the new or duplicate button to create a new family type and input its dimensions; User can also select the family type and modify corresponding dimensions. Click Next button.\n6.\tSelect Material for Glass Pane and Sash. Click back button to modify dimensions or next button to next step.\n7.\tView all window types created before, you can go back do further modification on these types. Click the file button then choose a path to store the family file. Click Finish button, Revit will create one window family automatically for you."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\FindReferencesByDirection\\FindColumns\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,\n                                                             ref string message,\n                                                             Autodesk.Revit.DB.ElementSet elements)\n        {\n            // Initialization \n            m_app = revit.Application;\n            m_doc = revit.Application.ActiveUIDocument.Document;\n\n            // Find a 3D view to use for the ray tracing operation\n            Get3DView(\"{3D}\");\n\n            Selection selection = revit.Application.ActiveUIDocument.Selection;\n            List<Wall> wallsToCheck = new List<Wall>();\n\n            // If wall(s) are selected, process them.\n            if (selection.GetElementIds().Count > 0)\n            {\n                foreach (Autodesk.Revit.DB.ElementId eId in selection.GetElementIds())\n                {\n                   Autodesk.Revit.DB.Element e = revit.Application.ActiveUIDocument.Document.GetElement(eId);\n                    if (e is Wall)\n                    {\n                        wallsToCheck.Add((Wall)e);\n                    }\n                }\n\n                if (wallsToCheck.Count <= 0)\n                {\n                    message = \"No walls were found in the active document selection\";\n                    return Result.Cancelled;\n                }\n            }\n            // Find all walls in the document and process them.\n            else\n            {\n                FilteredElementCollector collector = new FilteredElementCollector(m_doc);\n                FilteredElementIterator iter = collector.OfClass(typeof(Wall)).GetElementIterator();\n                while (iter.MoveNext())\n                {\n                    wallsToCheck.Add((Wall)iter.Current);\n                }\n            }\n\n            // Execute the check for embedded columns\n            CheckWallsForEmbeddedColumns(wallsToCheck);\n\n            // Process the results, in this case set the active selection to contain all embedded columns\n            ICollection<ElementId> toSelected = new List<ElementId>(); \n            if (m_allColumnsOnWalls.Count > 0)\n            {\n                foreach (ElementId id in m_allColumnsOnWalls)\n                {\n                    ElementId familyInstanceId = id;\n                    Autodesk.Revit.DB.Element familyInstance = m_doc.GetElement(familyInstanceId);\n                    toSelected.Add(familyInstance.Id);\n                }\n                selection.SetElementIds(toSelected); \n            }\n            return Result.Succeeded;\n        }\n        #endregion\n\n        #region Class Implementation\n        /// <summary>\n        /// Check a list of walls for embedded columns.\n        /// </summary>\n        /// <param name=\"wallsToCheck\">The list of walls to check.</param>\n        private void CheckWallsForEmbeddedColumns(List<Wall> wallsToCheck)\n        {\n            foreach (Wall wall in wallsToCheck)\n            {\n                CheckWallForEmbeddedColumns(wall);\n            }\n        }\n\n        /// <summary>\n        /// Checks a single wall for embedded columns.\n        /// </summary>\n        /// <param name=\"wall\">The wall to check.</param>\n        private void CheckWallForEmbeddedColumns(Wall wall)\n        {\n            LocationCurve locationCurve = wall.Location as LocationCurve;\n            Curve wallCurve = locationCurve.Curve;\n            if (wallCurve is Line)\n            {\n                LogWallCurve((Line)wallCurve);\n                CheckLinearWallForEmbeddedColumns(wall, locationCurve, (Line)wallCurve);\n            }\n            else\n            {\n                CheckProfiledWallForEmbeddedColumns(wall, locationCurve, wallCurve);\n            }\n        }\n\n        /// <summary>\n        /// Checks a single linear wall for embedded columns.\n        /// </summary>\n        /// <param name=\"wall\">The wall to check.</param>\n        /// <param name=\"locationCurve\">The location curve extracted from this wall.</param>\n        /// <param name=\"wallCurve\">The profile of the wall.</param>\n        private void CheckLinearWallForEmbeddedColumns(Wall wall, LocationCurve locationCurve, Curve wallCurve)\n        {\n            double bottomHeight = GetElevationForRay(wall);\n\n            FindColumnsOnEitherSideOfWall(wall, locationCurve, wallCurve, 0, bottomHeight, wallCurve.Length);\n        }\n\n        /// <summary>\n        /// Finds columns on either side of the given wall.\n        /// </summary>\n        /// <param name=\"wall\">The wall.</param>\n        /// <param name=\"locationCurve\">The location curve of the wall.</param>\n        /// <param name=\"wallCurve\">The profile of the wall.</param>\n        /// <param name=\"parameter\">The normalized parameter along the wall profile which is being evaluated.</param>\n        /// <param name=\"elevation\">The elevation at which the rays are cast.</param>\n        /// <param name=\"within\">The maximum distance away that columns may be found.</param>\n        private void FindColumnsOnEitherSideOfWall(Wall wall, LocationCurve locationCurve, Curve wallCurve, double parameter, double elevation, double within)\n        {\n            XYZ rayDirection = GetTangentAt(wallCurve, parameter);\n            XYZ wallLocation = wallCurve.Evaluate(parameter, true);\n\n            XYZ wallDelta = GetWallDeltaAt(wall, locationCurve, parameter);\n\n            XYZ rayStart = new XYZ(wallLocation.X + wallDelta.X, wallLocation.Y + wallDelta.Y, elevation);\n            FindColumnsByDirection(rayStart, rayDirection, within, wall);\n\n            rayStart = new XYZ(wallLocation.X - wallDelta.X, wallLocation.Y - wallDelta.Y, elevation);\n            FindColumnsByDirection(rayStart, rayDirection, within, wall);\n        }\n\n        /// <summary>\n        /// Finds columns by projecting rays along a given direction.\n        /// </summary>\n        /// <param name=\"rayStart\">The origin of the ray.</param>\n        /// <param name=\"rayDirection\">The direction of the ray.</param>\n        /// <param name=\"within\">The maximum distance away that columns may be found.</param>\n        /// <param name=\"wall\">The wall that this search is associated with.</param>\n        private void FindColumnsByDirection(XYZ rayStart, XYZ rayDirection, double within, Wall wall)\n        {\n            ReferenceIntersector referenceIntersector = new ReferenceIntersector(m_view3D);\n            IList<ReferenceWithContext> intersectedReferences = referenceIntersector.Find(rayStart, rayDirection);\n            FindColumnsWithin(intersectedReferences, within, wall);\n        }\n\n        /// <summary>\n        /// Checks a single curved/profiled wall for embedded columns.\n        /// </summary>\n        /// <param name=\"wall\">The wall to check.</param>\n        /// <param name=\"locationCurve\">The location curve extracted from this wall.</param>\n        /// <param name=\"wallCurve\">The profile of the wall.</param>\n        private void CheckProfiledWallForEmbeddedColumns(Wall wall, LocationCurve locationCurve, Curve wallCurve)\n        {\n            double bottomHeight = GetElevationForRay(wall);\n\n            // Figure out the increment for the normalized parameter based on how long the wall is.  \n            double parameterIncrement = WallIncrement / wallCurve.Length;\n\n            // Find columns within 2' of the start of the ray.  Any smaller, and you run the risk of not finding a boundary\n            // face of the column within the target range.\n            double findColumnWithin = 2;\n\n            // check for columns along every WallIncrement fraction of the wall\n            for (double parameter = 0; parameter < 1.0; parameter += parameterIncrement)\n            {\n                FindColumnsOnEitherSideOfWall(wall, locationCurve, wallCurve, parameter, bottomHeight, findColumnWithin);\n            }\n\n        }\n\n        /// <summary>\n        /// Obtains the elevation for ray casting evaluation for a given wall.\n        /// </summary>\n        /// <param name=\"wall\">The wall.</param>\n        /// <returns>The elevation.</returns>\n        private double GetElevationForRay(Wall wall)\n        {\n            Level level = m_doc.GetElement(wall.LevelId) as Level;\n\n            // Start at 1 foot above the bottom level\n            double bottomHeight = level.Elevation + 1.0;\n\n            return bottomHeight;\n        }\n\n        /// <summary>\n        /// Obtains the offset to the wall at a given location along the wall's profile.\n        /// </summary>\n        /// <param name=\"wall\">The wall.</param>\n        /// <param name=\"locationCurve\">The location curve of the wall.</param>\n        /// <param name=\"parameter\">The normalized parameter along the location curve of the wall.</param>\n        /// <returns>An XY vector representing the offset from the wall centerline.</returns>\n        private XYZ GetWallDeltaAt(Wall wall, LocationCurve locationCurve, double parameter)\n        {\n            XYZ wallNormal = GetNormalToWallAt(wall, locationCurve, parameter);\n            double wallWidth = wall.Width;\n\n            // The LocationCurve is always the wall centerline, regardless of the setting for the wall Location Line.\n            // So the delta to place the ray just outside the wall extents is always 1/2 the wall width + a little extra.\n            XYZ wallDelta = new XYZ(wallNormal.X * wallWidth / 2 + WALL_EPSILON, wallNormal.Y * wallWidth / 2 + WALL_EPSILON, 0);\n\n            return wallDelta;\n        }\n\n        /// <summary>\n        /// Finds column elements which occur within a given set of references within the designated proximity, and stores them to the results. \n        /// </summary>\n        /// <param name=\"references\">The references obtained from FindReferencesByDirection()</param> \n        /// <param name=\"proximity\">The maximum proximity.</param>\n        /// <param name=\"wall\">The wall from which these references were found.</param>\n        private void FindColumnsWithin(IList<ReferenceWithContext> references, double proximity, Wall wall)\n        {\n            foreach (ReferenceWithContext reference in references)\n            {\n                // Exclude items too far from the start point.\n                if (reference.Proximity < proximity)\n                {\n                    Autodesk.Revit.DB.Element referenceElement = wall.Document.GetElement(reference.GetReference());\n                    if (referenceElement is FamilyInstance)\n                    {\n                        FamilyInstance familyInstance = (FamilyInstance)referenceElement;\n                        ElementId familyInstanceId = familyInstance.Id;\n                        ElementId wallId = wall.Id;\n                        BuiltInCategory categoryValue = referenceElement.Category.BuiltInCategory;\n                        if (categoryValue == BuiltInCategory.OST_Columns || categoryValue == BuiltInCategory.OST_StructuralColumns)\n                        {\n                            // Add the column to the map of wall->columns\n                            if (m_columnsOnWall.ContainsKey(wallId))\n                            {\n                                List<ElementId> columnsOnWall = m_columnsOnWall[wallId];\n                                if (!columnsOnWall.Contains(familyInstanceId))\n                                    columnsOnWall.Add(familyInstanceId);\n                            }\n                            else\n                            {\n                                List<ElementId> columnsOnWall = new List<ElementId>();\n                                columnsOnWall.Add(familyInstanceId);\n                                m_columnsOnWall.Add(wallId, columnsOnWall);\n                            }\n                            // Add the column to the complete list of all embedded columns\n                            if (!m_allColumnsOnWalls.Contains(familyInstanceId))\n                                m_allColumnsOnWalls.Add(familyInstanceId);\n                        }\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Obtains the tangent of the given curve at the given parameter.\n        /// </summary>\n        /// <param name=\"curve\">The curve.</param>\n        /// <param name=\"parameter\">The normalized parameter.</param>\n        /// <returns>The normalized tangent vector.</returns>\n        private XYZ GetTangentAt(Curve curve, double parameter)\n        {\n            Transform t = curve.ComputeDerivatives(parameter, true);\n            // BasisX is the tangent vector of the curve.\n            return t.BasisX.Normalize();\n        }\n\n        /// <summary>\n        /// Finds the normal to the wall centerline at the given parameter.\n        /// </summary>\n        /// <param name=\"wall\">The wall.</param>\n        /// <param name=\"curve\">The location curve of the wall.</param>\n        /// <param name=\"parameter\">The normalized parameter.</param>\n        /// <returns>The normalized normal vector.</returns>\n        private XYZ GetNormalToWallAt(Wall wall, LocationCurve curve, double parameter)\n        {\n            Curve wallCurve = curve.Curve;\n\n            // There is no normal at a given point for a line.  We need to get the normal based on the tangent of the wall location curve.\n            if (wallCurve is Line)\n            {\n                XYZ wallDirection = GetTangentAt(wallCurve, 0);\n                XYZ wallNormal = new XYZ(wallDirection.Y, wallDirection.X, 0);\n                return wallNormal;\n            }\n            else\n            {\n                Transform t = wallCurve.ComputeDerivatives(parameter, true);\n                // For non-linear curves, BasisY is the normal vector to the curve.\n                return t.BasisY.Normalize();\n            }\n        }\n\n        /// <summary>\n        /// Dump wall's curve(end points) to log\n        /// </summary>\n        /// <param name=\"wallCurve\">Wall curve to be dumped.</param>\n        private void LogWallCurve(Line wallCurve)\n        {\n            Debug.WriteLine(\"Wall curve is line: \");\n\n            Debug.WriteLine(\"Start point: \" + XYZToString(wallCurve.GetEndPoint(0)));\n            Debug.WriteLine(\"End point: \" + XYZToString(wallCurve.GetEndPoint(1)));\n        }\n\n        /// <summary>\n        /// Format XYZ to string \n        /// </summary>\n        /// <param name=\"point\"></param>\n        /// <returns></returns>\n        private String XYZToString(XYZ point)\n        {\n            return \"( \" + point.X + \", \" + point.Y + \", \" + point.Z + \")\";\n        }\n\n        /// <summary>\n        /// Get a 3D view from active document\n        /// </summary>\n        private void Get3DView(string viewName)\n        {\n            FilteredElementCollector collector = new FilteredElementCollector(m_app.ActiveUIDocument.Document);\n            foreach (Autodesk.Revit.DB.View3D v in collector.OfClass(typeof(View3D)).ToElements())\n            {\n                // skip view template here because view templates are invisible in project browsers\n                if (v != null && !v.IsTemplate && v.Name == viewName)\n                {\n                    m_view3D = v as Autodesk.Revit.DB.View3D;\n                    break;\n                }\n            }\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_FindColumns.rtf": "Summary: This sample shows how to find columns that are embedded in walls with the Revit API method FindReferencesWithContextByDirection.\n\nClasses: \nAutodesk.Revit.DB.FilteredElementCollector\nAutodesk.Revit.DB.FilteredElementIterator\nAutodesk.Revit.DB.Transform\nAutodesk.Revit.DB.XYZ\nAutodesk.Revit.DB.Document\nAutodesk.Revit.UI.Selection.Selection\n\nProject Files: \nFindColumns.cs\n\nDescription: 1.\tDetermine which walls to process (either the selected walls, or all walls if none are selected)\n2.\tFind columns embedded in each wall\na.\tFor linear walls\ni.\tSet the height for the ray at 1’ above the wall’s level\nii.\tFind the direction tangent to the wall’s location curve\niii.\tBecause the wall’s LocationCurve is always the wall centerline, use the wall’s width to determine the offset needed for FindReferencesWithContextByDirection to shoot its “ray” just outside of the wall\niv.\tFind references of objects returned by FindReferencesWithContextByDirection when running from one end of the wall to the other end of the wall\nv.\tCheck each reference to validate that it is a column within the allowable distance from the origin used with FindReferencesWithContextByDirection (don’t want columns past the end of the wall)\nb.\tFor non-linear walls\ni.\tUnlike linear walls, where a single ray can be to check for intersections along the entire length of the wall, a non-linear wall must be divided into series of smaller pieces to approximate the wall as a set of shorter straight segments.\nii.\tCalculate an increment that will be used for the length of these short segments\niii.\tCheck for columns along every incremental piece of the wall using the methodology described above for linear walls.\nc.\tSelect the resulting columns\n\nInstructions:\n1.\tOpen the file FindColumns-Basic.rvt or FindColumns-TestCases.rvt\n2.\tRun the external command “Find Columns Embedded in Walls”\n3.\tIf one or more walls are selected before running the command, Revit will select the columns embedded in the selected walls.\n4.\tIf no walls are selected before running the command, Revit will select all columns that are embedded in a wall."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\FindReferencesByDirection\\RaytraceBounce\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         try\n         {\n            // should have a line style \"bounce\" created in the document before running this\n            m_app = commandData.Application;\n            Get3DView();\n            if (m_view == null)\n            {\n               TaskDialog.Show(\"Revit\", \"A default 3D view (named {3D}) must exist before running this command\");\n               return Autodesk.Revit.UI.Result.Cancelled;\n            }\n            else\n            {\n               RayTraceBounceForm form = new RayTraceBounceForm(commandData, m_view);\n               form.ShowDialog();\n            }\n            return Autodesk.Revit.UI.Result.Succeeded;\n         }\n         catch (Exception e)\n         {\n            message = e.ToString();\n            return Autodesk.Revit.UI.Result.Failed;\n         }\n      }\n      #endregion\n\n      #region Class Implementation\n      /// <summary>\n      /// Get a 3D view from active document\n      /// </summary>\n      public void Get3DView()\n      {\n         List<Autodesk.Revit.DB.Element> list = new List<Autodesk.Revit.DB.Element>();\n         FilteredElementCollector collector = new FilteredElementCollector(m_app.ActiveUIDocument.Document);\n         list.AddRange(collector.OfClass(typeof(View3D)).ToElements());\n         foreach (Autodesk.Revit.DB.View3D v in list)\n         {\n             // skip view template here because view templates are invisible in project browsers\n             if (v != null && !v.IsTemplate && v.Name == \"{3D}\")\n            {\n               m_view = v as Autodesk.Revit.DB.View3D;\n               break;\n            }\n         }\n      }\n      #endregion\n\n   }\n}"
    },
    "documentation": {
      "ReadMe_RaytraceBounce.rtf": "Summary: This sample shows how to find intersection between ray and face and create connecting lines by Revit API method FindReferencesWithContextByDirection.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Document\nAutodesk.Revit.DB.ElementSet\nAutodesk.Revit.DB.GeometryObject\n\nProject Files: \nCommand.cs\nThis file contains the class Command that inherits from IExternalCommand. The class implements the Execute method and is used to show RayTraceBounceForm\nRayTraceBounceForm.cs\nThe form allows entry of a coordinate location (X, Y, Z) within the model and a coordinate direction (i, j, k).\n\nDescription: This sample mostly uses the FindReferencesWithContextByDirection method for implementing the functionalities:\n1.\tLaunch a ray from appointed location in appointed direction to find the first intersection with a face\n2.\tCalculate the reflection angle of the ray from the face and launch another ray to find the next intersection\n3.\tFor each ray/intersection, create a model line connecting the two points.  The end result should be a series of model lines bouncing from item to item.\n4.\tProvide a hard limit of say, 100 intersections, to prevent endless reflections within an enclosed space.\n5.\tWrite a log file of the intersection containing: the element type, id, and material of the intersected face.\n\nInstructions:\n1.\tOpen the document bounce.rvt which should have 3D view and a line style \"bounce\" created in the document\n2.\tRun this external command to show the dialog\n3.\tInput suitable origin point and direction and click ok button and the lines is created"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\FoundationSlab\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            try\n            {\n                // Check commandData parameter.\n                if (null == commandData)\n                {\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                SlabData revitDatas = null;\n                try\n                {\n                    // The Datas for UI.\n                    revitDatas = new SlabData(commandData.Application);\n                }\n                catch (NullReferenceException e)\n                {\n                    message = e.Message;\n                    return Autodesk.Revit.UI.Result.Cancelled;  // Data error.\n                }\n                // Display form.\n                using (FoundationSlabForm displayForm = new FoundationSlabForm(revitDatas))\n                {\n                    if (displayForm.ShowDialog() == System.Windows.Forms.DialogResult.OK)\n                    {\n                        return Autodesk.Revit.UI.Result.Succeeded; // Create foundation slabs successfully.\n                    }\n                }\n                return Autodesk.Revit.UI.Result.Cancelled;  // Cancel creation.\n            }\n            catch (Exception e)\n            {\n                message = e.Message;\n                return Autodesk.Revit.UI.Result.Failed; // Unknow error.\n            }\n        }\n        #endregion IExternalCommand Members Implementation\n    }\n}"
    },
    "documentation": {
      "ReadMe_FoundationSlab.rtf": "Summary: This sample demonstrates how to create Foundation Slab.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.DB.Floor\nAutodesk.Revit.DB.FloorType\nAutodesk.Revit.DB.Document \n\nProject Files: \nCommand.cs\nThis file contains the class Command which implements interface IExternalCommand. It creates an instance of SlabData for FoundationSlabForm and show the form.\n\nRegularSlab.cs\nThis file contains a class of regular slab. Create an octagonal profile for the floor according to its bounding box\n\nFoundationSlabForm.cs\nThis file contains a class to show properties and profiles of the foundation slabs.\n\nSlabData.cs\nThis file contains a class SlabData that is a mediator between RevitAPI and FoundationSlabForm. It has a collection of functions to create FoundationSlabs, find out all regular horizontal slabs, get the floor profile, verify whether the floor is planar etc.\n\nSketch.cs\nThis file contains an internal class for drawing slabs' profiles.\n\nDescription: -\tTo get slabs, iterate through the document looking for ‘Floor’ objects.\n-\tThe Mark property can be found in floor parameter: BuiltInParameter.ALL_MODEL_MARK.\n-\tFoundation slab types can be found by iterating through the document looking for ‘FloorType’ objects with category named ‘Structural Foundations’.\n-\tA Foundation Slab can be created by ‘NewFloor’ method with the given horizontal profile and using a specified foundation slab style. \n-\tStructural slab's profile can be found in its AnalyticalModel property. Nonstructural floor's profile can be formed through its Geometry property.\n-\tThe octagonal profile is an array of planar lines that represent the horizontal profile of the octagonal foundation slab.\n-\tMake sure the profile of slab is a closed outline, or else it could not be created by Revit.\n\nInstructions: \n1.\tPrepare your Revit project.\nOpen or new a Revit project and make sure there are some floors in the document. A sample project file FoundationSlab.rvt is available in the sample’s folder.\n2.\tRun the command.\n3.\tIn the Regular Slabs group, select the floors you want to make change.\n4.\tIn the bottom of the dialog, select the Foundation Slab Type to be applied.\n5.\tYou can see the preview of the converting results in the Picture Box. Click OK button to create octagonal slabs for the selected floors."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\FrameBuilder\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n\n           // try to initialize necessary data to create framing\n           FrameData data = FrameData.CreateInstance(commandData);\n           // display UI for user's input\n           using (CreateFrameForm framingForm = new CreateFrameForm(data))\n           {\n              if (framingForm.ShowDialog() == DialogResult.OK)\n              {\n                 // create framing\n                 FrameBuilder builder = new FrameBuilder(data);\n                 builder.CreateFraming();\n              }\n              else\n              {\n                 // cancel the command\n                 return Autodesk.Revit.UI.Result.Cancelled;\n              }\n           }\n            \n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n        #endregion IExternalCommand Members Implementation\n    }\n}"
    },
    "documentation": {
      "ReadMe_FrameBuilder.rtf": "Summary: This sample demonstrates how to create a frame composed of columns, beams and braces. User can input parameters to create a frame consist of column, beam and brace. It has a user visible option to use the suspended updating function to increase the speed of the model creation. And users can duplicate the type of column, beam and brace.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.Document \nAutodesk.Revit.DB.Level\nAutodesk.Revit.DB.FamilySymbol\n\nProject Files: \nCommand.cs\nThe main DLL source file which contains the class Command which implements interface IExternalCommand. Initialize necessary data to create framing and display UI for user's input\n\nCreateFrameForm.cs\nThis file contains a class that is the main form to create framing.\n\nDuplicateTypeForm.cs\nThis file contains a class that is the form to duplicate FamilySymbol and edit its name and parameters\n\nErrorMessageException.cs\nThis file contains a class which passes error message to UI or back to internal error messagebox by Execute method in IExternalCommand.\n\nFrameBuilder.cs\nThis file contains a class which creates columns, beams and braces to create framing\n\nFrameData.cs\nThis file contains a data class which includes information to create framing\n\nFrameTypeParameters.cs\nThis file contains a class which is used to show and modify parameters of column, beam or brace for control PropertyGrid\n\nFrameTypesMgr.cs\nThis file contains a class which is the data manager taking charge of FamilySymbol object in current document\n-\tPress the Duplicate button in the dialog;\n\nDescription: This sample provides the following functionality:\n-\tPresent a dialog to users asking for the following information:\n-\tDistance between columns\n-\tNumber of Columns in the X direction\n-\tNumber of Columns in the Y direction\n-\tThe type of the columns\n-\tThe type of the beams\n-\tThe type of the braces\n-\tNumber of Floors\n-\tIncremental height of Auto-generated levels\n-\tCoordinate of the bottom left corner of Frame\n-\tAngle to rotate Frame in clockwise\n-\tThe number of floors is less than the number of levels since columns will be inserted from the level below to the level above. For example if the number of floors requested is 3 then there must be 4 levels and the columns will go from Level 1 to 2, Level 2 to 3 and Level 3 to 4. If there is less than 2 levels tell the user 2 levels must be added and exit the command with a failure. If more levels are need, auto-generate levels according to the number of floors. The height between adjoin generated levels equals to the height between the highest 2 levels existed in the project.\n-\tStarting with the lowest level and progressing to higher levels, insert columns with the specified type into the project programmatically in an array format based on the number of columns specified in the X and Y directions with the correct specified distance between them. Do this for each floor specified.\n-\tInsert beams of the specified type between the tops of each adjacent column in the X and Y direction to form a square grid of beams. Beams are not needed between diagonal columns.\n-\tInsert braces of the specified type between the midpoint of each column and the midpoint of each adjoining beam.\n-\tThe frame is moved according to the coordinate of the bottom left corner. Then rotate it in clockwise according to the input angle.\n-\tUsers can create a new concrete element type through duplicating specified type. The work flow is as follows:\n-\tPress the Duplicate button in the dialog;\n-\tChange name of column’s type and press OK;\n-\tChange value for b and h of section in another dialog and press OK;\n-\tSimilar steps can be followed for concrete and wood beams and braces.\n\nInstructions: \n1.\tOpen Revit Structure.\n2.\tRun the command.\n3.\tInput the information to create beams, brace and columns, input the angle to rotate (optional).\n4.\tIn sample’s main UI click the OK button.\n5.\tApplication will create a frame consist of column, beam and brace."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\GenerateFloor\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n           Transaction tran = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Generate Floor\");\n           tran.Start();\n\n            try\n            {\n                if (null == commandData)\n                {\n                    throw new ArgumentNullException(\"commandData\");\n                }\n\n                Data data = new Data();\n                data.ObtainData(commandData);\n\n                GenerateFloorForm dlg = new GenerateFloorForm(data);\n\n                if (dlg.ShowDialog() == System.Windows.Forms.DialogResult.OK)\n                {\n                    CreateFloor(data, commandData.Application.ActiveUIDocument.Document);\n\n                    tran.Commit();\n                    return Autodesk.Revit.UI.Result.Succeeded;\n                }\n                else\n                {\n                   tran.RollBack();\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }                \n            }\n            catch (Exception e)\n            {\n                message = e.Message;\n                tran.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n\n        #endregion IExternalCommand Members Implementation\n\n        /// <summary>\n        /// create a floor by the data obtain from revit.\n        /// </summary>\n        /// <param name=\"data\">Data including the profile, level etc, which is need for create a floor.</param>\n        /// <param name=\"doc\">Retrieves an object that represents the currently active project.</param>\n        static public void CreateFloor(Data data, Document doc)\n        {\n            CurveLoop loop = new CurveLoop();\n            foreach (Curve curve in data.Profile)\n            {\n                loop.Append(curve);\n            }\n\n            List<CurveLoop> floorLoops = new List<CurveLoop> { loop };\n\n            Floor.Create(doc, floorLoops, data.FloorType.Id, data.Level.Id, data.Structural, null, 0.0);\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_GenerateFloor.rtf": "Summary: This sample demonstrates how to generate a floor using the closed outline made by a selection of walls.\n\nClasses: \nAutodesk.Revit.Creation.Document\nAutodesk.Revit.DB.Floor\nAutodesk.Revit.DB.FloorType\nAutodesk.Revit.DB.Level\n\nProject Files:                                \nCommand.cs\nThis is the main DLL source file. It contains the class Command which implements interface IExternalCommand.\n\nData.cs\nThis is the most important class of the sample project. Obtain all data for this sample: all possible types for floor, the level that walls based on.\n\nGenerateFloorForm.cs\n\tA dialog that contains the following:\n-\tA drop-down list box contains all the floor types.\n-\tA check box shows whether the floor to be created is structural or not.\n-\tA preview window should display the closed outline.\n\nDescription: -\tThe profile of floor can be retrieved from the location of walls. If this curve array is not in sequence, creating floor with this profile will encounter an exception. The solution is to arrange the curves in sequence first.\n-\tBefore RevitAPI 10, the method ‘NewFloor’ is the only interface to create the object floor, slab, and foundation slab etc… From the RevitAPI 10, it is divided into three methods, “NewFloor”, “NewSlab” and “NewFoundationSlab”.\n\nInstructions: \n1.\tSelect several walls that make a closed outline.\n2.\tRun this external command, a dialog will show you the profile of floor you want to create.\n3.\tSelect the floor type you want to create.\n4.\tClick the OK button, the floor will be created.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\GeometryAPI\\ComputedSymbolGeometry\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            try\n            {\n                Transaction trans = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Revit.SDK.Samples.ComputedSymbolGeometry\");\n                trans.Start();\n                // create a ComputedSymbolGeometry object \n                ComputedSymbolGeometry computedSymGeo = new ComputedSymbolGeometry(commandData.Application.ActiveUIDocument.Document);\n                // execute method to get and show geometry of all instances\n                computedSymGeo.GetInstanceGeometry();\n                trans.Commit();\n                return Result.Succeeded;\n            }\n            catch (Exception e)\n            {\n                message = e.Message;\n                message += e.StackTrace;\n                return Result.Failed;\n            }\n        }\n    }\n        #endregion\n}"
    },
    "documentation": {
      "ReadMe_ComputedSymbolGeometry.rtf": "Description: The sample implements IExternalCommand interface and allows user to get and view slave symbol geometry. \n-\tTo get slave symbol geometry, use the method GetInstanceGeometry of ComputedSymbolGeometry.\n-\tTo paint geometry information, use the method PaintSolid of ComputedSymbolGeometry.\n\nInstructions: \n1.\tSet up addin file and start revit to load this sample.\n2.\tLaunch ComputedSymbolGeometry via the external command menu.\n3.\tThe sample will display various types of geometry of the family instance in current building model. You can view them by switching Revit views."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\GeometryAPI\\EnergyAnalysisModel\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Transaction trans = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Revit.SDK.Samples.EnergyAnalysisModel\");\n            trans.Start();\n            // Create an object that is responsible for collecting users inputs and getting analysis data of current model.\n            using (EnergyAnalysisModel analysisModel = new EnergyAnalysisModel(commandData.Application.ActiveUIDocument.Document))\n            {\n               // Create the UI for users inputs options and view analysis models.\n               using (OptionsAndAnalysisForm form = new OptionsAndAnalysisForm(analysisModel))\n               {\n                   // make analysis data ready\n                   analysisModel.Initialize();\n                   // show dialog to browser analysis model\n                   if (DialogResult.OK != form.ShowDialog())\n                   {\n                       trans.RollBack();\n                       return Result.Cancelled;\n                   }\n               }\n               trans.Commit();\n               return Result.Succeeded;\n            }\n         }\n\n         #endregion\n      }\n}"
    },
    "documentation": {
      "ReadMe_EnergyAnalysisModel.rtf": "Description: The sample implements IExternalCommand interface and allows user to define the options of energy analysis and view the analytical data.\n-\tTo get analytical openings information, use the method GetAnalyticalOpenings of EnergyAnalysisModel.\n-\tTo get analytical shading surfaces information, use the method GetAnalyticalShadingSurfaces of EnergyAnalysisModel.\n-\tTo get analytical spaces information, use the method GetAnalyticalSpaces of EnergyAnalysisModel.\n-\tTo view new analytical model, use the method RefreshAnalysisData of EnergyAnalysisModel.\n\nInstructions: \n1.\tSet up addin file and start Revit to load this sample.\n2.\tLaunch EnergyAnalysis Model via the external command menu.\n4.\tInput the Options including Tier value, ExportMullions, IncludeShadingSurfaces and SimplifyCurtainSystems. Click Refresh button.\n6.\tAccording to the options you set, the sample will display energy analytical data of current building model. You can view its surface information by clicking the tree view.\n7.\tClick Close button to end."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\HelloRevit\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            // NOTES: Anything can be done in this method, such as create a message box, \n            // a task dialog or fetch some information from revit and so on.\n            // We mainly use the task dialog for example.\n\n            // Get the application and document from external command data.\n            Application app = commandData.Application.Application;\n            Document activeDoc = commandData.Application.ActiveUIDocument.Document;\n\n            #region Task Dialog Sample\n            // Study how to create a revit style dialog using task dialog API by following\n            // code snippet.  \n\n            // Creates a Revit task dialog to communicate information to the interactive user.\n            TaskDialog mainDialog = new TaskDialog(\"Hello, Revit!\");\n            mainDialog.MainInstruction = \"Hello, Revit!\";\n            mainDialog.MainContent =\n                \"This sample shows how a basic ExternalCommand can be added to the Revit user interface.\"\n                + \" It uses a Revit task dialog to communicate information to the interactive user.\\n\"\n                + \"The command links below open additional task dialogs with more information.\";\n\n            // Add commmandLink to task dialog\n            mainDialog.AddCommandLink(TaskDialogCommandLinkId.CommandLink1,\n                                      \"View information about the Revit installation\");\n            mainDialog.AddCommandLink(TaskDialogCommandLinkId.CommandLink2,\n                                      \"View information about the active document\");\n         \n            // Set common buttons and default button. If no CommonButton or CommandLink is added,\n            // task dialog will show a Close button by default.\n            mainDialog.CommonButtons = TaskDialogCommonButtons.Close;\n            mainDialog.DefaultButton = TaskDialogResult.Close;\n\n            // Set footer text. Footer text is usually used to link to the help document.\n            mainDialog.FooterText =\n                \"<a href=\\\"http://usa.autodesk.com/adsk/servlet/index?siteID=123112&id=2484975 \\\">\"\n                + \"Click here for the Revit API Developer Center</a>\";\n\n            TaskDialogResult tResult = mainDialog.Show();\n\n            // If the user clicks the first command link, a simple Task Dialog \n            // with only a Close button shows information about the Revit installation. \n            if (TaskDialogResult.CommandLink1 == tResult)\n            {\n                TaskDialog dialog_CommandLink1 = new TaskDialog(\"Revit Build Information\");\n                dialog_CommandLink1.MainInstruction =\n                    \"Revit Version Name is: \" + app.VersionName + \"\\n\"\n                    + \"Revit Version Number is: \" + app.VersionNumber + \"\\n\"\n                    + \"Revit Version Build is: \" + app.VersionBuild;\n\n                dialog_CommandLink1.Show();\n\n            }\n\n            // If the user clicks the second command link, a simple Task Dialog \n            // created by static method shows information about the active document.\n            else if (TaskDialogResult.CommandLink2 == tResult)\n            {\n                TaskDialog.Show(\"Active Document Information\",\n                    \"Active document: \" + activeDoc.Title + \"\\n\"\n                    + \"Active view name: \" + activeDoc.ActiveView.Name);\n            }\n            #endregion\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_HelloRevit.rtf": "Summary: Shows how a basic ExternalCommand can be added to the Revit user interface. It uses a Revit task dialog to communicate information to the interactive user.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.UI.TaskDialog\n\nProject Files: \n·\tCommand.cs\nThis file contains a class Command which inherits from IExternalCommmand interface. The function of the class is to add an external command to the Revit and create a Revit task dialog in Execute method to show some information of Revit to user. User can do anything in Execute method like create task dialog, fetch some information from Revit, and operate Element and so on. Here just take task dialog for example.\n\nDescription: The sample defines a class which inherits from IExternalCommand interface, and implements the Execute method with creating a task dialog in its body. \n·\tThe task dialog has Title, Main Instruction, Main Content, 2 Command Links, footer text, and OK/Cancel buttons. See as below:\n\n·\tIf push Command Link1, a task dialog with default Close button shows the information about the Revit Build.\n\n·\tIf push Command Link2, a task dialog created by static show () method shows the information about the Active Document.\n\nInstructions: \n1.\tRun the command.\n2.\tThe task dialog will be popped up.\n3.\tClick commandLink, corresponding dialog will pop up.\n\nNotes:\nFor as consistent as possible with native Revit dialogs, API developers should create task dialogs according to the Revit standards. More information, please refer to API Developer’s Guide."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\ImportExport\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n        ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            try\n            {\n                // Verify active document\n                if (null == commandData.Application.ActiveUIDocument.Document)\n                {\n                    message = \"Active view is null.\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n                \n                MainData mainData = new MainData(commandData);\n                // Show the dialog\n                using (MainForm mainForm = new MainForm(mainData))\n                {\n                    if (mainForm.ShowDialog() == DialogResult.Cancel)\n                    {\n                        return Autodesk.Revit.UI.Result.Cancelled;\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                message = ex.ToString();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_ImportExport.rtf": "Summary: This sample shows how to export current project to dwg, sat,dxf, dwf(x), gbxml, fbx, dgn, pdf or image files and how to import a dwg, image, GBXML or Inventor file into Revit.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.GBXMLExportOptions \nAutodesk.Revit.DB.DWFExportOptions\nAutodesk.Revit.DB.DWFXExportOptions\nAutodesk.Revit.DB.DWGExportOptions\nAutodesk.Revit.DB.FBXExportOptions\nAutodesk.Revit.DB.DGNExportOptions\nAutodesk.Revit.DB.DWGImportOptions\nAutodesk.Revit.DB.ImageImportOptions\nAutodesk.Revit.DB.PDFExportOptions\nAutodesk.Revit.DB.GBXMLImportOptions\nAutodesk.Revit.DB.InventorImportOptions\nAutodesk.Revit.DB.DXFExportOptions\nAutodesk.Revit.DB.SATExportOptions\nAutodesk.Revit.DB.ImageExportOptions\n\nProject Files: \nCommand.cs\nIt contains the class Command which implements interface IExternalCommand.\n\nMainData.cs\nData class contains the external command data.\n\nMainForm.cs\nIt contains a dialog which lets user choose the operation and the format.\n\nExportBaseOptionsData.cs\nBase data class for which stores the basic information for DWG, DXF export.\n\nExportBaseOptionsForm.cs\nIt contains a dialog which provides the options of common information for DWG, DXF exporting view related. \t\n\nExportDXFData.cs\nData class which stores the main information for exporting dxf format.\n\nExportDXFOptionsForm.cs\nDerive from the class ExportBaseOptionsForm.\n\nExportSATData.cs\nData class which stores the main information for exporting sat format.\n\nExportIMGData.cs\nData class which stores the main information for exporting image format.\n\nExportPDFData.cs\n    Data class which stores the main information for exporting pdf format.\n\nExportIMGOptionsForm.cs\nIt contains a dialog which provides the options of common information for image exporting view related.\n\nExportData.cs\nBase data class which stores the basic information for export.\n\nExportDataWithViews.cs\nBase data class which stores the basic information for exporting view related formats.\n\nExportWithViewsForm.cs\nIt contains a dialog which provides the options of common information for exporting view related formats.\n\nExportDWGData.cs\nData class which stores the main information for exporting dwg format.\n\nExportDWGOptionsData.cs\nData class which stores information of lower priority for exporting dwg format.\n\nExportDWGOptionsForm.cs\nDerive from the class ExportBaseOptionsForm.\n\nExportDWFData.cs\nData class which stores the information for exporting DWF(x) format.\n\nExportDWFOptionForm.cs\nIt contains a dialog which provides the options of lower priority information for exporting 2D DWF(x) format\n\nExportFBXData.cs\nData class which stores the information for exporting fbx format.\n\nExportGBXMLData.cs\nData class which stores the information for exporting gbxml format.\n\nExportDGNData.cs\nData class which stores the information for exporting dgn format.\n\nExportDGNOptionsForm.cs\nIt contains a dialog which provides the options for exporting dgn format.\n\nSelectViewsData.cs\nData class which stores information of views for export.\n\nSelectViewsForm.cs\nIt contains a dialog which lets users choose views to export.\n\nImportData.cs\nBase data class which stores the basic information for import.\n\nImportDWGData.cs\nData class which stores the information for importing dwg format.\n\nImportDWGForm.cs\nIt contains a dialog which provides the options of importing dwg format.\n\nImportImageData.cs\nData class which stores the information for importing image format.\n\nImportGBXMLData.cs\nData class which stores the information for importing GBXML format.\n\nImportInventorData.cs\nData class which stores the information for importing Inventor format.\n\nDescription: This sample provides following functionalities.\n-\tLet users specify the export options and export the current project to dwg, dwf(x), gbxml, fbx or dgn files.\n-\tLet users specify the import options and import a dwg, image, GBXML or Inventor file into Revit. \n\nInstructions: \n1.\tOpen Revit application and execute the command.\n2.\tTo export, check the radio button “export”, select the format to export and click “OK” button. The 3D DWF(x) and fbx formats will be available only when current view is a 3D view.\n-\tTo export dwg, DWF(x) or dgn formats\nSpecify the file name to export to, set the common options and click “Option…” button to set the lower priority options, click “Select…” button to select multi-views to export. Then click “Save” button to perform export.\n-\tTo export gbxml or fbx formats\nSpecify the file name to export to and click “Save” button to perform export.\n[NOTE]To export fbx format successfully, the Revit render appearance library must have been installed.\n  \n3.\tTo import, check the radio button “import” and click “OK” button. The image format will be available only when current view is not 3D view.\n-\tTo import dwg format\nSpecify the dwg file to import and set the other options. Then click “Open” button to perform import.\n-\tTo Import image, GBXML or Inventor format\nSpecify the file to import and click “Open” button to perform import."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\InPlaceMembers\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            m_commandData = commandData;\n            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"External Tool\");\n\n            FamilyInstance inPlace = null;\n\n            AnalyticalElement model = null;\n\n            try\n            {\n                transaction.Start();\n                if (!PrepareData(ref inPlace, ref model))\n                {\n                    message = \"You should select only one in place member which have analytical model.\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                GraphicsData graphicsData = GraphicsDataFactory.CreateGraphicsData(model);\n                Properties instanceProperties = new Properties(inPlace);\n                InPlaceMembersForm form = new InPlaceMembersForm(instanceProperties, graphicsData);\n                if (form.ShowDialog() == System.Windows.Forms.DialogResult.Abort)\n                {\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception e)\n            {\n                message = e.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            finally\n            {\n                transaction.Commit();\n            }\n        }\n      /// <summary>\n      /// Search for the In-Place family instance's properties data to be listed\n      /// and graphics data to be drawn.\n      /// </summary>\n      /// <param name=\"inPlaceMember\">properties data to be listed</param>\n      /// <param name=\"model\">graphics data to be draw</param>\n      /// <returns>Returns true if retrieved this data</returns>\n      private bool PrepareData(ref FamilyInstance inPlaceMember, ref AnalyticalElement model)\n      {\n         ElementSet selected = new ElementSet();\n         foreach (ElementId elementId in m_commandData.Application.ActiveUIDocument.Selection.GetElementIds())\n         {\n            selected.Insert(m_commandData.Application.ActiveUIDocument.Document.GetElement(elementId));\n         }\n\n         if (selected.Size != 1)\n         {\n            return false;\n         }\n\n         foreach (object o in selected)\n         {\n            inPlaceMember = o as FamilyInstance;\n            if (null == inPlaceMember)\n            {\n               return false;\n            }\n         }\n         Document document = inPlaceMember.Document;\n         AnalyticalToPhysicalAssociationManager relManager = AnalyticalToPhysicalAssociationManager.GetAnalyticalToPhysicalAssociationManager(document);\n         if (relManager != null)\n         {\n            ElementId associatedElementId = relManager.GetAssociatedElementId(inPlaceMember.Id);\n            if (associatedElementId != ElementId.InvalidElementId)\n            {\n               Element associatedElement = document.GetElement(associatedElementId);\n               if (associatedElement != null && associatedElement is AnalyticalElement)\n               {\n                  model = associatedElement as AnalyticalElement;\n               }\n            }\n         }\n\n         if (null == model)\n         {\n            return false;\n         }\n\n         return true;\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_InPlaceMembers.rtf": "Summary: This sample demonstrates how to get the In-place Family instance and its properties in the current document of Revit.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.Structure.AnalyticalModel\nAutodesk.Revit.DB.Curve\n\nProject Files: \nCommand.cs\nThis file contains a class Command that implements the IExternalCommand, the function of this class is to Retrieve values of an In-place Family instance’s properties and send the data to UI.\n\nGraphicsData.cs\nThis file contains a class GraphicsData, the function of this class is to store the AnalyticalModel’s curve points and implements some functionality to operate the Geometry: such as Rotate, Move, etc.\n\nGraphicsDataFactory.cs\nThis file contains a class GraphicsDataFactory. The class just has a static method CreateGraphicsData to create a GraphicsData object.\n\nPictureBox3D.cs\nThis file contains a class PictureBox3D, the functionality of this class is to paint the geometry curves of the analytical model contained in a GraphicsData object.\n\nProperties.cs\nThis file contains a class Properties, this class stores all the properties’ values of FamilyInstance object.\n\t\nInPlaceMembersForm.cs\nThis file contains a class InPlaceMembersForm, the class inherits from Form and ImessageFilter. It uses a PictureBox3D to paint the analytical model’s curves and a PropertyGrid to show the properties of selected FamilyInstance.\n\nDescription: This sample retrieves the properties’ values of an In-place FamilyInstance, paints the analytical model of FamilyInstance in a PictureBox and shows other properties in a Property Grid. We can get the AnalyticalModel’s profile via Curves property.\n\t\nInstructions: \n\n1.\tOpen or new a Revit project and make sure at least one in-place FamilyInstance which contains AnalyticalModel is placed. A sample project file InPlaceMembers.rvt is available in the sample’s folder.\n2.\tSelect an in-place FamilyInstance which contains AnalyticalModel.\n3.\tRun the command.\n4.\tThe Form will show the AnalyticalModel of the selected FamilyInstance. The geometry can be rotated, moved and scaled via keys: \n-    Rotate (Left, Right, Up, Down, PageUp, PageDown)\n-    Move (S, W, A, D) \n-    Scale (Home, End).\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\InvisibleParam\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(\n            ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"External Tool\");\n            try\n            {\n                transaction.Start();\n\n                //Create a clear file as parameter file.\n                String path = Assembly.GetExecutingAssembly().Location;\n                int index = path.LastIndexOf(\"\\\\\");\n                String newPath = path.Substring(0,index);\n                newPath += \"\\\\RevitParameters.txt\";\n                if(File.Exists(newPath))\n                {\n                    File.Delete(newPath);\n                }\n                FileStream fs = File.Create(newPath);\n                fs.Close();               \n\n                //cache application handle\n                Application revitApp = commandData.Application.Application;\n                //prepare shared parameter file\n                commandData.Application.Application.SharedParametersFilename = newPath;\n\n                //Open shared parameter file\n                DefinitionFile parafile = revitApp.OpenSharedParameterFile();\n\n                //get walls category\n                Category wallCat = commandData.Application.ActiveUIDocument.Document.Settings.Categories.get_Item(BuiltInCategory.OST_Walls);\n                CategorySet categories = revitApp.Create.NewCategorySet();\n                categories.Insert(wallCat);\n\n                InstanceBinding binding = revitApp.Create.NewInstanceBinding(categories);\n\n                //Create a group\n                DefinitionGroup apiGroup = parafile.Groups.Create(\"APIGroup\");\n\n                //Create a visible \"VisibleParam\" of text type.\n                ExternalDefinitionCreationOptions ExternalDefinitionCreationOptions1 = new ExternalDefinitionCreationOptions(\"VisibleParam\", SpecTypeId.String.Text);\n                Definition visibleParamDef = apiGroup.Definitions.Create\n                    (ExternalDefinitionCreationOptions1);\n                                        ;\n                                        BindingMap bindingMap = commandData.Application.ActiveUIDocument.Document.ParameterBindings;\n                bindingMap.Insert(visibleParamDef, binding);\n\n                //Create a invisible \"InvisibleParam\" of text type.\n                ExternalDefinitionCreationOptions ExternalDefinitionCreationOptions2 = new ExternalDefinitionCreationOptions(\"InvisibleParam\", SpecTypeId.String.Text);\n                Definition invisibleParamDef = apiGroup.Definitions.Create\n                    (ExternalDefinitionCreationOptions2);\n                bindingMap.Insert(invisibleParamDef, binding);\n            }\n            catch(Exception e)\n            {\n                transaction.RollBack();\n                message = e.ToString();\n                return Autodesk.Revit.UI.Result.Cancelled;\n            }\n            finally\n            {\n                transaction.Commit();\n            }\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_InvisibleParam.rtf": "Summary: This sample demonstrates how to use share parameter file to create share parameters and how to bind share parameters and instance.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.ApplicationServices.Application\nAutodesk.Revit.DB.DefinitionFile\nAutodesk.Revit.DB.Definition\nAutodesk.Revit.DB.DefinitionGroup\nAutodesk.Revit.DB.InstanceBinding\n\nProject Files: \nCommand.cs\nThis file define a class Command implement Autodesk.Revit.UI.IExternalCommand.\n\nDescription: This sample uses Application.OpenSharedParameterFile method to get DefinitionFile instance as the share parameter file and create visible and invisible two parameters. Use InstanceBinding instance created by NewInstanceBinding method to bind parameters to elements. \n\nInstructions: \n1.\tRun this command.\n2.\tOpen RevitParameters.txt to see the result.\n3.\tDraw a Wall.\n4.\tOpen Wall’s Property dialog, There will be a share parameter: Other ->VisibleParam in Instance Parameters.\n\n\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Journaling\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n                                               ref string message,\n                                               ElementSet elements)\n        {\n            try\n            {\n                Transaction tran = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Journaling\");\n                tran.Start();\n                // Create a real operate class\n                Journaling deal = new Journaling(commandData);\n                deal.Run();     // The main deal operation\n                tran.Commit();\n\n                // if everything goes well, return succeeded.\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception ex)\n            {\n                // If there is something wrong, give error information and return failed\n                message = ex.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n        #endregion IExternalCommand Members Implementation\n    }\n}"
    },
    "documentation": {
      "ReadMe_Journaling.rtf": "Summary: This sample demonstrates how an external application can be incorporated into the journaling mechanism.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Document\nAutodesk.Revit.DB.Element\nAutodesk.Revit.DB.Creation\nAutodesk.Revit.DB.Collections.StringStringMap\n\nProject Files: \nCommand.cs\nThis file contains the class Command that inherits from IExternalCommand. The class implements the Execute method and be used to interoperate with Revit.\n\nJournaling.cs\nThis file will implement the functions: get all Wall types and all Levels; show all Wall types and Level information in a Form; read and write journal data to journal file; create a Wall according to user setting. \n\nJournalingForm.cs\nThis file contains the Form class which consists of: two ComboBox controls, one list all Wall types, the other is for all Levels; a user control to get Wall location from user’s inputting.\n\nPointUserControl.cs\nThis file contains user control class which implements a user control for getting XYZ data from user input.\n\nDescription: This sample mostly uses StringStringMap class for implementing the functionality: read and write user data from/to journal file, the data exists in APIStringStringMapJournalData journal data section in journal file.\n-\tTo read or write data which stored in the journal file, use StringStringMap class’s methods:  get_Item(key) and Insert(key, value).\n-\tThe ExternalCommandData.Data property can be used to get/set the journal data (StringStringMap object).\n-\tTo get all Wall Type in Revit project, use ActiveDocument.WallTypes.\n-\tTo get an existing element by Id, use ActiveDocument.get_Element(ref ElementId).\n\nInstructions: \n1.\tIn order to test the sample function about reading / writing journal data, firstly, user should manually execute this sample one time.\n2.\tClick the extern command, a dialog will be popped up; input the start and end point for new Wall, click Ok to create a new wall and then close Revit without saving.\n3.\tOpen the latest journal file generated by Revit in Journals folder under Revit install directory(ensure there is Journals folder before run this sample), you will see the journal data (End Point, Start Point, Level Id, etc) added by API in APIStringStringMapJournalData section:\n  Jrn.Data \"APIStringStringMapJournalData\"  _\n          , 4, \"End Point\", \"(100,0,0)\" _\n          , \"Level Id\", \"30\", \"Start Point\" _\n          , \"(0,0,0)\", \"Wall Type Name\", \"Curtain Wall 1\"\n\n4.\tWhen replay this sample journal (drag the journal to Revit.exe icon directly), you will find same Wall is created successfully via reading the journal data value reserved in above steps.\n5.\tHowever, if you comment the WriteJournalData() method in method Run() of Journaling.cs file then execute step1 to step3; in step4, the JournalingForm will be popped up and blocks the execution, because there is no journal data be reserved in step1 to step3.\n\nNote: \n1.\tBecause we need to write APIStringStringMapJournalData content to journal, make sure the external command uses JournalingData.UsingCommandData attribute; otherwise, no content will be dumped to journal when manually running samples."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\LevelsProperty\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit, ref String message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            m_revit = revit;\n            UnitTypeId = m_revit.Application.ActiveUIDocument.Document.GetUnits().GetFormatOptions(Autodesk.Revit.DB.SpecTypeId.Length).GetUnitTypeId();\n            Transaction documentTransaction = new Transaction(revit.Application.ActiveUIDocument.Document, \"Document\");\n            documentTransaction.Start();\n            try\n            {\n                //Get every level by iterating through all elements\n                systemLevelsDatum = new List<LevelsDataSource>();\n                FilteredElementCollector collector = new FilteredElementCollector(m_revit.Application.ActiveUIDocument.Document);\n                ICollection<Element> collection = collector.OfClass(typeof(Level)).ToElements();\n                foreach (Element element in collection)\n                {\n                     Level systemLevel = element as Level;\n                     LevelsDataSource levelsDataSourceRow = new LevelsDataSource();\n\n                     levelsDataSourceRow.LevelIDValue = systemLevel.Id;\n                     levelsDataSourceRow.Name = systemLevel.Name;\n\n                     Parameter elevationPara = systemLevel.get_Parameter(BuiltInParameter.LEVEL_ELEV);\n                     \n                     double temValue = Unit.CovertFromAPI(UnitTypeId, elevationPara.AsDouble());\n                     double temValue2 = double.Parse(temValue.ToString(\"#.0\"));\n                     \n                     levelsDataSourceRow.Elevation = temValue2;\n\n                     systemLevelsDatum.Add(levelsDataSourceRow);\n                }\n\n                using (LevelsForm displayForm = new LevelsForm(this))\n                {\n                    displayForm.ShowDialog();\n                }\n            }\n            catch (Exception ex)\n            {\n                message = ex.Message;\n                documentTransaction.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            documentTransaction.Commit();\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        ExternalCommandData m_revit;\n        public Autodesk.Revit.DB.ForgeTypeId UnitTypeId;\n        System.Collections.Generic.List<LevelsDataSource> systemLevelsDatum;\n        /// <summary>\n        /// Store all levels' datum in system\n        /// </summary>\n        public System.Collections.Generic.List<LevelsDataSource> SystemLevelsDatum\n        {\n            get\n            {\n                return systemLevelsDatum;\n            }\n            set\n            {\n                systemLevelsDatum = value;\n            }\n        }\n        #endregion\n\n        #region SetData\n\n\n        /// <summary>\n        /// Set Level\n        /// </summary>\n        /// <param name=\"levelID\">Pass a Level's ID value</param>\n        /// <param name=\"levelName\">Pass a Level's Name</param>\n        /// <param name=\"levelElevation\">Pass a Level's Elevation</param>\n        /// <returns>True if succeed, else return false</returns>\n        public bool SetLevel(Autodesk.Revit.DB.ElementId levelID, String levelName, double levelElevation)\n        {\n            try\n            {\n                Level systemLevel = m_revit.Application.ActiveUIDocument.Document.GetElement(levelID) as Level;\n\n                Parameter elevationPara = systemLevel.get_Parameter(BuiltInParameter.LEVEL_ELEV);\n                elevationPara.SetValueString(levelElevation.ToString());\n                systemLevel.Name = levelName;\n\n                return true;\n            }\n            catch (Exception)\n            {\n                return false;\n            }\n        }\n        #endregion\n\n        #region CreateLevel\n        /// <summary>\n        /// Create a level\n        /// </summary>\n        /// <param name=\"levelName\">Pass a Level's Name</param>\n        /// <param name=\"levelElevation\">Pass a Level's Elevation</param>\n        public void CreateLevel(String levelName, double levelElevation)\n        {\n           Level newLevel = Level.Create(m_revit.Application.ActiveUIDocument.Document, levelElevation);\n            Parameter elevationPara = newLevel.get_Parameter(BuiltInParameter.LEVEL_ELEV);\n            elevationPara.SetValueString(levelElevation.ToString());\n\n            newLevel.Name = levelName;\n        }\n        #endregion\n\n        #region DeleteLevel\n        /// <summary>\n        /// Delete a Level.\n        /// </summary>\n        /// <param name=\"IDOfLevel\">A Level's ID value</param>\n        public void DeleteLevel(ElementId IDOfLevel)\n        {\n\n            m_revit.Application.ActiveUIDocument.Document.Delete(IDOfLevel);\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_LevelsProperty.rtf": "Summary: This sample demonstrates how to get all the levels in a document, and how to create or delete a level and set its properties.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Level\nAutodesk.Revit.Creation.Document\n\nProject Files:\nCommand.cs\nThis file contains the functions that how to get all the levels in a Revit file, how to create a level and set its properties and implement the IExternalCommand interface.\n\nLevelsDataSource.cs\nThis file contains the LevelsDataSource Class which used to store the data of a level in Revit.\n\nDescription: -\tDisplay a list of all Levels in the current document, with their name and elevation. All the levels can be found by iterating through the current document elements.\n-\tCreate a new level with a unique name and an elevation. A new level can be created by using the NewLevel method which belongs to the Autodesk.Revit.Creation.Document Class.\n-\tDelete a level.\n-\tA level’s name and elevation can be set by the Name and Elevation property in the Autodesk.Revit.DB.Level Class. The name of a Level should be unique.\n\nInstructions: \n1.\tOpen a Revit document which contains some levels.\n2.\tRun the sample, it will get all levels in current document.\n3.\tClick the Add button to create a new level.\n4.\tSelected a level in the list to set its name and elevation, click Ok button to finish set.\n5.\tClick the Delete button to delete a selected level in the list, click Ok button to finish it.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Loads\\CS",
    "key_code": {
      "class_name": "Loads",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                                    ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            m_revit = commandData.Application.Application;\n            Transaction documentTransaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Document\");\n            documentTransaction.Start();\n            // Initialize the helper classes.\n            m_combinationDeal = new LoadCombinationDeal(this);\n            m_loadCaseDeal = new LoadCaseDeal(this);\n\n            // Prepare some data for the form displaying\n            PrepareData();\n\n\n            // Display the form and wait for the user's operate.\n            // This class give some public methods to add or delete LoadUsage and delete LoadCombination\n            // The form will use these methods to add or delete dynamically.\n            // If the user press cancel button, return Cancelled to roll back All the changes.\n            using (LoadsForm displayForm = new LoadsForm(this))\n            {\n                if (DialogResult.OK != displayForm.ShowDialog())\n                {\n                    documentTransaction.RollBack();\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n            }\n\n            // If everything goes right, return succeeded.\n            documentTransaction.Commit();\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        /// <summary>\n        /// Prepare the data for the form displaying.\n        /// </summary>\n        void PrepareData()\n        {\n            // Prepare the data of the LoadCase page on form\n            m_loadCaseDeal.PrepareData();\n\n            //Prepare the data of the LoadCombination page on form\n            m_combinationDeal.PrepareData();\n        }\n\n        /// <summary>\n        /// Create new Load Combination\n        /// </summary>\n        /// <param name=\"name\">The new Load Combination name</param>\n        /// <param name=\"typeId\">The index of new Load Combination Type</param>\n        /// <param name=\"stateId\">The index of new Load Combination State</param>\n        /// <returns>true if the creation was successful; otherwise, false</returns>\n        public Boolean NewLoadCombination(String name, int typeId, int stateId)\n        {\n            // In order to refresh the combination DataGridView,\n            // We should do like as follow\n            m_LoadCombinationMap = new List<LoadCombinationMap>(m_LoadCombinationMap);\n\n            // Just go to run NewLoadCombination method of LoadCombinationDeal class\n            return m_combinationDeal.NewLoadCombination(name, typeId, stateId);\n        }\n\n        /// <summary>\n        /// Delete the selected Load Combination\n        /// </summary>\n        /// <param name=\"index\">The selected index in the DataGridView</param>\n        /// <returns>true if the delete operation was successful; otherwise, false</returns>\n        public Boolean DeleteCombination(int index)\n        {\n            // Just go to run DeleteCombination method of LoadCombinationDeal class\n            return m_combinationDeal.DeleteCombination(index);\n        }\n\n        /// <summary>\n        /// Create a new load combination usage\n        /// </summary>\n        /// <param name=\"usageName\">The new Load Usage name</param>\n        /// <returns>true if the process is successful; otherwise, false</returns> \n        public Boolean NewLoadUsage(String usageName)\n        {\n            // In order to refresh the usage DataGridView,\n            // We should do like as follow\n            m_usageMap = new List<UsageMap>(m_usageMap);\n\n            // Just go to run NewLoadUsage method of LoadCombinationDeal class\n            return m_combinationDeal.NewLoadUsage(usageName);\n        }\n\n        /// <summary>\n        /// Delete the selected Load Usage\n        /// </summary>\n        /// <param name=\"index\">The selected index in the DataGridView</param>\n        /// <returns>true if the delete operation was successful; otherwise, false</returns>\n        public Boolean DeleteUsage(int index)\n        {\n            // Just go to run DeleteUsage method of LoadCombinationDeal class\n            if (false == m_combinationDeal.DeleteUsage(index))\n            {\n                return false;\n            }\n\n            // In order to refresh the usage DataGridView,\n            // We should do like as follow\n            if (0 == m_usageMap.Count)\n            {\n                m_usageMap = new List<UsageMap>();\n            }\n            return true;\n        }\n\n        /// <summary>\n        /// Change usage name when the user modify it on the form\n        /// </summary>\n        /// <param name=\"oldName\">The name before modification</param>\n        /// <param name=\"newName\">The name after modification</param>\n        /// <returns>true if the modification was successful; otherwise, false</returns>\n        public Boolean ModifyUsageName(String oldName, String newName)\n        {\n            // Just go to run ModifyUsageName method of LoadCombinationDeal class\n            return m_combinationDeal.ModifyUsageName(oldName, newName);\n        }\n\n        /// <summary>\n        /// Add a formula when the user click Add button to new a formula\n        /// </summary>\n        /// <returns>true if the creation is successful; otherwise, false</returns>\n        public Boolean AddFormula()\n        {\n            // Get the first member in LoadCases as the Case\n            LoadCase loadCase = m_loadCases[0];\n            if (null == loadCase)\n            {\n                m_errorInformation = \"Can't not find a LoadCase.\";\n                return false;\n            }\n            String caseName = loadCase.Name;\n\n            // In order to refresh the formula DataGridView,\n            // We should do like as follow\n            m_formulaMap = new List<FormulaMap>(m_formulaMap);\n\n            // Run AddFormula method of LoadCombinationDeal class\n            return m_combinationDeal.AddFormula(caseName);\n        }\n\n        /// <summary>\n        /// Delete the selected Load Formula\n        /// </summary>\n        /// <param name=\"index\">The selected index in the DataGridView</param>\n        /// <returns>true if the delete operation was successful; otherwise, false</returns>\n        public Boolean DeleteFormula(int index)\n        {\n            // Just remove that data.\n            try\n            {\n                m_formulaMap.RemoveAt(index);\n            }\n            catch (Exception e)\n            {\n                m_errorInformation = e.ToString();\n                return false;\n            }\n            return true;\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_Loads.rtf": "Summary: This sample shows how to operate Load Case, Load Nature, Load Usage and Load Combination.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Structure.LoadCase\nAutodesk.Revit.DB.Structure.LoadNature\nAutodesk.Revit.DB.Structure.LoadCombination\nAutodesk.Revit.Creation.Document\n\nProject Files:\nLoads.cs\nThere is a class named Loads which implements the IExternalCommand interface. This file uses the other files to show how to operate Load Case, Load Nature, Load Usage and Load Combination.\n\nLoadCaseDeal.cs\nThis file contains the functions to operate the Load Case and Load Nature.\n\nLoadCombinationDeal.cs\nThis file contains the functions to operate the Load Combination and Load Usage.\n\nLoadCaseTabPage.cs\nThis UserControl is used to deal with the operation of load case on the form.\n\nLoadCombinationTabPage:\nThis UserControl is used to deal with the operation of load combination on the form.\n\nDescription: Functionalities:\n-\tGet all the load cases, load natures, load combinations, load usages, and formulas in a Revit project.\n-\tPresent all existing Load Cases in current project including their names, case numbers, natures, and categories; Modify name, nature and category. Then allow users to “Duplicate” a new Load Case into current project, meanwhile displaying them on the dialog.\n-\tShow all the load natures (including the existing natures in current project already and the added natures), which name can be modified, and an “Add” button allow to add a new one.\n-\tAdd new Load Combination into current project and set its parameters such as load cases and load usages in creation. \n-\tDelete certain Load Combination or Load usage.\nImplementation:\n-\tNew load case and new load combination can be created by using NewLoadCase () and NewLoadCombination () methods in namespace Autodesk.Revit.Creation.Document.\n-\tNew load nature and load usage can be created by using NewLoadNature () and NewLoadUsage () method in namespace Autodesk.Revit.Creation.Document.\n-\tThe load case element can be retrieved from a Load Instance object using the parameter named “Load Case”.\n-\tAll the load natures, load cases, load combinations and load usages can be found by iterating through the document elements.\n-\tAll objects have a Name property can be used to retrieve a user visible name.\n\nInstructions: \n1.\tRun the command, it will show all the load cases, load natures, load combinations, load usage, and formulas in Revit project. Using Revit Menu Command “Setting->Structural Setting” can open a similar dialog.\n2.\tSelect a Load Case then you can duplicate a new Load Case in Load Cases Tab Page.\n3.\tSelect a Load Nature then you can add a new Load Nature in Load Cases Tab Page.\n4.\tYou can create a new Load or delete Combination in the Load Combination Tab Page by using the “Add” or “Delete” buttons. You can also add or delete Load Combination Usage.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Massing\\DistanceToPanels\\CS",
    "key_code": {
      "class_name": "SetDistanceParam",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            m_uiApp = commandData.Application;\n            m_uiDoc = m_uiApp.ActiveUIDocument;\n\n            // get the target element to be used for the Distance computation\n            ElementSet collection = new ElementSet();\n            foreach (ElementId elementId in m_uiDoc.Selection.GetElementIds())\n            {\n               collection.Insert(m_uiDoc.Document.GetElement(elementId));\n            }\n            Parameter param = null;\n            ElementSet es = new ElementSet();\n            foreach (ElementId elementId in m_uiDoc.Selection.GetElementIds())\n            {\n               es.Insert(m_uiDoc.Document.GetElement(elementId));\n            }\n            Autodesk.Revit.DB.XYZ targetPoint = getTargetPoint(es);\n\n            // get all the divided surfaces in the Revit document\n            List<DividedSurface> dsList = GetElements<DividedSurface>();\n\n            foreach (DividedSurface ds in dsList)\n            {\n                GridNode gn = new GridNode();\n                int u = 0;\n                while (u < ds.NumberOfUGridlines)\n                {\n                    gn.UIndex = u;\n                    int v = 0;\n                    while (v < ds.NumberOfVGridlines)\n                    {\n                        gn.VIndex = v;\n                        if (ds.IsSeedNode(gn))\n                        {\n                            FamilyInstance familyinstance = ds.GetTileFamilyInstance(gn, 0);\n                            if (familyinstance != null)\n                            {\n                               param = familyinstance.LookupParameter(\"Distance\");\n                                if (param == null) throw new Exception(\"Panel family must have a Distance instance parameter\");\n                                else\n                                {\n                                    LocationPoint loc = familyinstance.Location as LocationPoint;\n                                    XYZ panelPoint = loc.Point;\n\n                                    double d = Math.Sqrt(Math.Pow((targetPoint.X - panelPoint.X), 2) + Math.Pow((targetPoint.Y - panelPoint.Y), 2) + Math.Pow((targetPoint.Z - panelPoint.Z), 2));\n                                    param.Set(d);\n\n                                    // uncomment the following lines to create points and lines showing where the distance measurement is made\n                                    //ReferencePoint rp = m_doc.FamilyCreate.NewReferencePoint(panelPoint);\n                                    //Line line = m_app.Create.NewLine(targetPoint, panelPoint, true);\n                                    //Plane plane = m_app.Create.NewPlane(targetPoint.Cross(panelPoint), panelPoint);\n                                    //SketchPlane skplane = m_doc.FamilyCreate.NewSketchPlane(plane);\n                                    //ModelCurve modelcurve = m_doc.FamilyCreate.NewModelCurve(line, skplane);\n                                }\n                            }\n                        }\n                        v = v + 1;\n                    }\n                    u = u + 1;\n                }\n            }\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        /// <summary>\n        /// Get the Autodesk.Revit.DB.XYZ point of the selected target element\n        /// </summary>\n        /// <param name=\"collection\">Selected elements</param>\n        /// <returns>the Autodesk.Revit.DB.XYZ point of the selected target element</returns>\n        Autodesk.Revit.DB.XYZ getTargetPoint(ElementSet collection)\n        {\n            FamilyInstance targetElement = null;\n            if (collection.Size != 1)\n            {\n                throw new Exception(\"You must select one component from which the distance to panels will be measured\");\n            }\n            else\n            {\n                foreach (Autodesk.Revit.DB.Element e in collection)\n                {\n                    targetElement = e as FamilyInstance;\n                }\n            }\n\n            if (null == targetElement)\n            {\n                throw new Exception(\"You must select one family instance from which the distance to panels will be measured\");\n            }\n            LocationPoint targetLocation = targetElement.Location as LocationPoint;\n            return targetLocation.Point;\n        }\n\n        protected List<T> GetElements<T>() where T : Element\n        {\n           List<T> returns = new List<T>();\n           FilteredElementCollector collector = new FilteredElementCollector(m_uiDoc.Document);\n           ICollection<Element> founds = collector.OfClass(typeof(T)).ToElements();\n           foreach (Element elem in founds)\n           {\n              returns.Add(elem as T);\n           }\n           return returns;\n        }\n\n\n    }\n}"
    },
    "documentation": {
      "ReadMe_DistanceToPanels.rtf": "Summary: Measure the distance from a selected object to all divided surface panels. Store this value for each panel in an instance parameter Distance.\n\nClasses: \n\tAutodesk.Revit.UI.IExternalCommand\n\tAutodesk.Revit.DB.DividedSurface\n\tAutodesk.Revit.DB.Panel\n\nProject Files:\n\nCommand.cs\n\tThis file contains the SetDistanceParam class and is invoked by the external command. This class is used to compute the distance data and update the parameter.\n\nDescription: 1.\tFind divided surfaces in the massing family\n2.\tFind all panels in the DividedSurface elements. The panels are FamilyInstance elements returned by the DividedSurface.GetTileFamilyInstance(GridNode, tileIndex) method.\n3.\tFind the location of the selected \"origin\" component.\n4.\tCheck the parameters of each panel and set the \"Distance\" instance parameter with the distance from that panel to the origin component.\n\nInstructions: \n1.\tOpen a massing family with divided surfaces such as DistanceToPanels.rfa\n2.\tThe divided surfaces should use a panel with a Distance instance parameter.\n3.\tThe massing family should include a family instance that will be used as the origin for the distance computation.\n4.\tSelect the instance mentioned in step 3) and run this command\n5.\tThe Distance parameter will be populated for each panel. This parameter can be scheduled in the project environment and used to drive the geometry of the panels.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Massing\\DividedSurfaceByIntersects\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         // store the active Revit document\n         m_document = commandData.Application.ActiveUIDocument.Document;\n\n         DividedSurface ds = GetDividedSurface();\n         if (null == ds)\n         {\n            message = \"Open the family file from the sample folder first.\";\n            return Result.Failed;\n         }\n         IEnumerable<ElementId> planes = GetPlanes();\n         IEnumerable<ElementId> lines = GetLines();\n\n         Transaction act = new Transaction(m_document);\n         act.Start(\"AddRemoveIntersects\");\n         try\n         {\n            // step 1: divide the surface with reference planes and levels\n            foreach (ElementId id in planes)\n            {\n               if (ds.CanBeIntersectionElement(id))\n               {\n                  ds.AddIntersectionElement(id);\n               }\n            }\n\n            // step 2: remove all the reference planes and level intersection elements\n            IEnumerable<ElementId> intersects = ds.GetAllIntersectionElements();\n\n            foreach (ElementId id in intersects)\n            {\n               ds.RemoveIntersectionElement(id);\n            }\n            \n            // step 3: divide the surface with model lines instead\n            foreach (ElementId id in lines)\n            {\n               if (ds.CanBeIntersectionElement(id))\n               {\n                  ds.AddIntersectionElement(id);\n               }\n            }\n         }\n         catch (Exception)\n         {\n            act.RollBack();\n         }\n         finally\n         {\n            act.Commit();\n         }\n\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n\n      private DividedSurface GetDividedSurface()\n      {\n         return m_document.GetElement(new ElementId(31519L)) as DividedSurface;\n      }\n\n      private IEnumerable<ElementId> GetPlanes()\n      {\n         // 1027, 1071 & 1072 are ids of the reference planes and levels drawn in the family file\n         yield return new ElementId(1027L); \n         yield return new ElementId(1071L);\n         yield return new ElementId(1072L);\n      }\n\n      private IEnumerable<ElementId> GetLines()\n      {\n         // the \"31xxx\" numberic values are ids of the model lines drawn in the family file\n         yield return new ElementId(31170L);\n         yield return new ElementId(31206L);\n         yield return new ElementId(31321L);\n         yield return new ElementId(31343L);\n         yield return new ElementId(31377L);\n         yield return new ElementId(31395L);\n      }\n\n      /// <summary>\n      /// Get element by its Id\n      /// </summary>\n      /// <typeparam name=\"T\"></typeparam>\n      /// <param name=\"eid\"></param>\n      /// <returns></returns>\n      public T GetElement<T>(long eid) where T : Element\n      {\n         return m_document.GetElement(new ElementId(eid)) as T;\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_DividedSurfaceByIntersects.rtf": "Summary: This sample demonstrates 2 main features:\n1.\tHow to add intersects to DividedSurface.\n2.\tHow to remove intersects to DividedSurface.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.CurtainSystem\n\nProject Files: \nCommand.cs\nThis file contains the class “Command” which inherits from “IExternalCommand” interface and implements the “Execute” method.\n\nDescription: Functionalities:\n-\tDivide the surface with intersect elements ( Level, ReferencePlane, ModelCurve, etc).\n-\tRemove the intersects that don’t need any more.\n\nImplementations:\n-\tAdd/ remove Intersects via \nvoid AddIntersectionElement(ElementId ^newIntersectionElemId)\nvoid RemoveIntersectionElement(ElementId ^referenceElemIdToRemove)\n\nInstructions: \nOpen the family file “DividedSurface.rfa” in the sample’s folder;\nRun the command;\nThe DividedSurface changes;"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Massing\\MeasurePanelArea\\CS",
    "key_code": {
      "class_name": "MeasurePanelArea",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         using (frmPanelArea form = new frmPanelArea(commandData))\n         {\n            // The form is created successfully\n            if (null != form && !form.IsDisposed)\n            {\n               form.ShowDialog();\n            }\n         }\n\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_MeasurePanelArea.rtf": "Summary: Measure the area of curtain panels in divided surfaces. Identify panels with area greater than and less than user-specified values. A text file is created in the same folder as the sample DLL file listing the area and element ID of every panel.\n\nClasses: \n\tAutodesk.Revit.UI.IExternalCommand\n\tAutodesk.Revit.DB.DividedSurface\n\tAutodesk.Revit.DB.Panel\n\nProject Files:\n\nCommand.cs\n\tThis file contains the MeasurePanelArea class and is invoked when the external command runs\n\nFormPanelArea.cs\n\tCreates the user interface and computes the areas in the btnCompute_Click event.\n\nDescription: 1.\tFind panel families loaded into the massing family\n2.\tCreate a List containing the selected DividedSurface elements. If no DividedSurface elements are selected, include all DividedSurface elements in the model.\n3.\tFind all panels in the DividedSurface elements. The panels are FamilyInstance elements returned by the DividedSurface.GetTileFamilyInstance(GridNode, tileIndex) method.\n4.\tGet the area of each panel using FamilyInstance.get_Geometry(opt)\na.\tFor partial border panels, get_Geometry returns the panel geometry in a Solid object\nb.\tFor uncut panels, their geometry is found through Instance.SymbolGeometry.Objects\n5.\tChange the FamilyInstance.Symbol based on the panel area relative to the range specified by the user in the dialog box.\n\nInstructions: \n1.\tCreate one or more massing forms with divided surface(s) and panels applied to these surfaces\n2.\tIf you don't want to analyze all divided surfaces in the model, select the surfaces of interest.\n3.\tRun this command\n4.\tEnter maximum and minimum values to define the range of allowable panel area\n5.\tSelect the panel types to be used to identify panels that are below, above, and within the range.\n6.\tPush \"Compute\"\n\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Massing\\NewForm\\CS",
    "key_code": {
      "class_name": "MakeExtrusionForm",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         ExternalCommandData cdata = commandData;\n         Autodesk.Revit.ApplicationServices.Application app = commandData.Application.Application;\n         app = commandData.Application.Application;\n         Document doc = commandData.Application.ActiveUIDocument.Document;\n\n         Transaction transaction = new Transaction(doc, \"MakeExtrusionForm\");\n         transaction.Start();\n\n         // Create one profile\n         ReferenceArray ref_ar = new ReferenceArray();\n\n         Autodesk.Revit.DB.XYZ ptA = new Autodesk.Revit.DB.XYZ(10, 10, 0);\n         Autodesk.Revit.DB.XYZ ptB = new Autodesk.Revit.DB.XYZ(90, 10, 0);\n         ModelCurve modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n\n         ptA = new Autodesk.Revit.DB.XYZ(90, 10, 0);\n         ptB = new Autodesk.Revit.DB.XYZ(10, 90, 0);\n         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n\n         ptA = new Autodesk.Revit.DB.XYZ(10, 90, 0);\n         ptB = new Autodesk.Revit.DB.XYZ(10, 10, 0);\n         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n\n         // The extrusion form direction\n         Autodesk.Revit.DB.XYZ direction = new Autodesk.Revit.DB.XYZ(0, 0, 50);\n\n         Autodesk.Revit.DB.Form form = doc.FamilyCreate.NewExtrusionForm(true, ref_ar, direction);\n\n         transaction.Commit();\n\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n      #endregion\n   }\n\n   /// <summary>\n   /// A class inherits IExternalCommand interface.\n   /// This class show how to create cap form by Revit API.\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class MakeCapForm : IExternalCommand\n   {\n      #region Class Interface Implementation\n      /// <summary>\n      /// Implement this method as an external command for Revit.\n      /// </summary>\n      /// <param name=\"commandData\">An object that is passed to the external application \n      /// which contains data related to the command, \n      /// such as the application object and active view.</param>\n      /// <param name=\"message\">A message that can be set by the external application \n      /// which will be displayed if a failure or cancellation is returned by \n      /// the external command.</param>\n      /// <param name=\"elements\">A set of elements to which the external application \n      /// can add elements that are to be highlighted in case of failure or cancellation.</param>\n      /// <returns>Return the status of the external command. \n      /// A result of Succeeded means that the API external method functioned as expected. \n      /// Cancelled can be used to signify that the user cancelled the external operation \n      /// at some point. Failure should be returned if the application is unable to proceed with \n      /// the operation.</returns>\n      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         ExternalCommandData cdata = commandData;\n         Autodesk.Revit.ApplicationServices.Application app = commandData.Application.Application;\n         app = commandData.Application.Application;\n         Document doc = commandData.Application.ActiveUIDocument.Document;\n\n         Transaction transaction = new Transaction(doc, \"MakeCapForm\");\n         transaction.Start();\n\n         // Create one profile\n         ReferenceArray ref_ar = new ReferenceArray();\n\n         Autodesk.Revit.DB.XYZ ptA = new Autodesk.Revit.DB.XYZ(10, 10, 0);\n         Autodesk.Revit.DB.XYZ ptB = new Autodesk.Revit.DB.XYZ(100, 10, 0);\n         Line line = Line.CreateBound(ptA, ptB);\n         ModelCurve modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n\n         ptA = new Autodesk.Revit.DB.XYZ(100, 10, 0);\n         ptB = new Autodesk.Revit.DB.XYZ(50, 50, 0);\n         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n\n         ptA = new Autodesk.Revit.DB.XYZ(50, 50, 0);\n         ptB = new Autodesk.Revit.DB.XYZ(10, 10, 0);\n         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n\n         Autodesk.Revit.DB.Form form = doc.FamilyCreate.NewFormByCap(true, ref_ar);\n\n         transaction.Commit();\n\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n      #endregion\n   }\n\n   /// <summary>\n   /// A class inherits IExternalCommand interface.\n   /// This class show how to create revolve form by Revit API.\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class MakeRevolveForm : IExternalCommand\n   {\n      #region Class Interface Implementation\n      /// <summary>\n      /// Implement this method as an external command for Revit.\n      /// </summary>\n      /// <param name=\"commandData\">An object that is passed to the external application \n      /// which contains data related to the command, \n      /// such as the application object and active view.</param>\n      /// <param name=\"message\">A message that can be set by the external application \n      /// which will be displayed if a failure or cancellation is returned by \n      /// the external command.</param>\n      /// <param name=\"elements\">A set of elements to which the external application \n      /// can add elements that are to be highlighted in case of failure or cancellation.</param>\n      /// <returns>Return the status of the external command. \n      /// A result of Succeeded means that the API external method functioned as expected. \n      /// Cancelled can be used to signify that the user cancelled the external operation \n      /// at some point. Failure should be returned if the application is unable to proceed with \n      /// the operation.</returns>\n      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         ExternalCommandData cdata = commandData;\n         Autodesk.Revit.ApplicationServices.Application app = commandData.Application.Application;\n         app = commandData.Application.Application;\n         Document doc = commandData.Application.ActiveUIDocument.Document;\n\n         Transaction transaction = new Transaction(doc, \"MakeRevolveForm\");\n         transaction.Start();\n\n         // Create one profile\n         ReferenceArray ref_ar = new ReferenceArray();\n         Autodesk.Revit.DB.XYZ norm = Autodesk.Revit.DB.XYZ.BasisZ;\n\n         Autodesk.Revit.DB.XYZ ptA = new Autodesk.Revit.DB.XYZ(0, 0, 10);\n         Autodesk.Revit.DB.XYZ ptB = new Autodesk.Revit.DB.XYZ(100, 0, 10);\n         ModelCurve modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB, norm);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n\n         ptA = new Autodesk.Revit.DB.XYZ(100, 0, 10);\n         ptB = new Autodesk.Revit.DB.XYZ(100, 100, 10);\n         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB, norm);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n\n         ptA = new Autodesk.Revit.DB.XYZ(100, 100, 10);\n         ptB = new Autodesk.Revit.DB.XYZ(0, 0, 10);\n         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB, norm);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n\n         // Create axis for revolve form\n         ptA = new Autodesk.Revit.DB.XYZ(-5, 0, 10);\n         ptB = new Autodesk.Revit.DB.XYZ(-5, 10, 10);\n         ModelCurve axis = FormUtils.MakeLine(commandData.Application, ptA, ptB, norm);\n         axis.ChangeToReferenceLine();\n\n         Autodesk.Revit.DB.FormArray form = doc.FamilyCreate.NewRevolveForms(true, ref_ar, axis.GeometryCurve.Reference, 0, Math.PI / 4);\n\n         transaction.Commit();\n\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n      #endregion\n   }\n\n   /// <summary>\n   /// A class inherits IExternalCommand interface.\n   /// This class show how to create swept blend form by Revit API.\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class MakeSweptBlendForm : IExternalCommand\n   {\n      #region Class Interface Implementation\n      /// <summary>\n      /// Implement this method as an external command for Revit.\n      /// </summary>\n      /// <param name=\"commandData\">An object that is passed to the external application \n      /// which contains data related to the command, \n      /// such as the application object and active view.</param>\n      /// <param name=\"message\">A message that can be set by the external application \n      /// which will be displayed if a failure or cancellation is returned by \n      /// the external command.</param>\n      /// <param name=\"elements\">A set of elements to which the external application \n      /// can add elements that are to be highlighted in case of failure or cancellation.</param>\n      /// <returns>Return the status of the external command. \n      /// A result of Succeeded means that the API external method functioned as expected. \n      /// Cancelled can be used to signify that the user cancelled the external operation \n      /// at some point. Failure should be returned if the application is unable to proceed with \n      /// the operation.</returns>\n      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         ExternalCommandData cdata = commandData;\n         Autodesk.Revit.ApplicationServices.Application app = commandData.Application.Application;\n         app = commandData.Application.Application;\n         Document doc = commandData.Application.ActiveUIDocument.Document;\n\n         Transaction transaction = new Transaction(doc, \"MakeSweptBlendForm\");\n         transaction.Start();\n\n         // Create first profile\n         ReferenceArray ref_ar = new ReferenceArray();\n         Autodesk.Revit.DB.XYZ ptA = new Autodesk.Revit.DB.XYZ(10, 10, 0);\n         Autodesk.Revit.DB.XYZ ptB = new Autodesk.Revit.DB.XYZ(50, 10, 0);\n         ModelCurve modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n\n         ptA = new Autodesk.Revit.DB.XYZ(50, 10, 0);\n         ptB = new Autodesk.Revit.DB.XYZ(10, 50, 0);\n         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n\n         ptA = new Autodesk.Revit.DB.XYZ(10, 50, 0);\n         ptB = new Autodesk.Revit.DB.XYZ(10, 10, 0);\n         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n\n         // Create second profile\n         ReferenceArray ref_ar2 = new ReferenceArray();\n         ptA = new Autodesk.Revit.DB.XYZ(10, 10, 90);\n         ptB = new Autodesk.Revit.DB.XYZ(80, 10, 90);\n         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         ref_ar2.Append(modelcurve.GeometryCurve.Reference);\n\n         ptA = new Autodesk.Revit.DB.XYZ(80, 10, 90);\n         ptB = new Autodesk.Revit.DB.XYZ(10, 50, 90);\n         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         ref_ar2.Append(modelcurve.GeometryCurve.Reference);\n\n         ptA = new Autodesk.Revit.DB.XYZ(10, 50, 90);\n         ptB = new Autodesk.Revit.DB.XYZ(10, 10, 90);\n         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         ref_ar2.Append(modelcurve.GeometryCurve.Reference);\n\n         // Add profiles\n         ReferenceArrayArray profiles = new ReferenceArrayArray();\n         profiles.Append(ref_ar);\n         profiles.Append(ref_ar2);\n\n         // Create path for swept blend form\n         ReferenceArray path = new ReferenceArray();\n         ptA = new Autodesk.Revit.DB.XYZ(10, 10, 0);\n         ptB = new Autodesk.Revit.DB.XYZ(10, 10, 90);\n         modelcurve = FormUtils.MakeLine(commandData.Application, ptA, ptB);\n         path.Append(modelcurve.GeometryCurve.Reference);\n\n         Autodesk.Revit.DB.Form form = doc.FamilyCreate.NewSweptBlendForm(true, path, profiles);\n\n         transaction.Commit();\n\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n      #endregion\n   }\n\n   /// <summary>\n   /// A class inherits IExternalCommand interface.\n   /// This class show how to create loft form by Revit API.\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class MakeLoftForm : IExternalCommand\n   {\n      #region Class Interface Implementation\n      /// <summary>\n      /// Implement this method as an external command for Revit.\n      /// </summary>\n      /// <param name=\"commandData\">An object that is passed to the external application \n      /// which contains data related to the command, \n      /// such as the application object and active view.</param>\n      /// <param name=\"message\">A message that can be set by the external application \n      /// which will be displayed if a failure or cancellation is returned by \n      /// the external command.</param>\n      /// <param name=\"elements\">A set of elements to which the external application \n      /// can add elements that are to be highlighted in case of failure or cancellation.</param>\n      /// <returns>Return the status of the external command. \n      /// A result of Succeeded means that the API external method functioned as expected. \n      /// Cancelled can be used to signify that the user cancelled the external operation \n      /// at some point. Failure should be returned if the application is unable to proceed with \n      /// the operation.</returns>\n      public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         ExternalCommandData cdata = commandData;\n         Autodesk.Revit.ApplicationServices.Application app = commandData.Application.Application;\n         app = commandData.Application.Application;\n         Document doc = commandData.Application.ActiveUIDocument.Document;\n\n         Transaction transaction = new Transaction(doc, \"MakeLoftForm\");\n         transaction.Start();\n\n         // Create profiles array\n         ReferenceArrayArray ref_ar_ar = new ReferenceArrayArray();\n\n         // Create first profile\n         ReferenceArray ref_ar = new ReferenceArray();\n\n         int y = 100;\n         int x = 50;\n         Autodesk.Revit.DB.XYZ ptA = new Autodesk.Revit.DB.XYZ(-x, y, 0);\n         Autodesk.Revit.DB.XYZ ptB = new Autodesk.Revit.DB.XYZ(x, y, 0);\n         Autodesk.Revit.DB.XYZ ptC = new Autodesk.Revit.DB.XYZ(0, y + 10, 10);\n         ModelCurve modelcurve = FormUtils.MakeArc(commandData.Application, ptA, ptB, ptC);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n         ref_ar_ar.Append(ref_ar);\n\n\n         // Create second profile\n         ref_ar = new ReferenceArray();\n\n         y = 40;\n         ptA = new Autodesk.Revit.DB.XYZ(-x, y, 5);\n         ptB = new Autodesk.Revit.DB.XYZ(x, y, 5);\n         ptC = new Autodesk.Revit.DB.XYZ(0, y, 25);\n         modelcurve = FormUtils.MakeArc(commandData.Application, ptA, ptB, ptC);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n         ref_ar_ar.Append(ref_ar);\n\n         // Create third profile\n         ref_ar = new ReferenceArray();\n\n         y = -20;\n         ptA = new Autodesk.Revit.DB.XYZ(-x, y, 0);\n         ptB = new Autodesk.Revit.DB.XYZ(x, y, 0);\n         ptC = new Autodesk.Revit.DB.XYZ(0, y, 15);\n         modelcurve = FormUtils.MakeArc(commandData.Application, ptA, ptB, ptC);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n         ref_ar_ar.Append(ref_ar);\n\n         // Create fourth profile\n         ref_ar = new ReferenceArray();\n\n         y = -60;\n         ptA = new Autodesk.Revit.DB.XYZ(-x, y, 0);\n         ptB = new Autodesk.Revit.DB.XYZ(x, y, 0);\n         ptC = new Autodesk.Revit.DB.XYZ(0, y + 10, 20);\n         modelcurve = FormUtils.MakeArc(commandData.Application, ptA, ptB, ptC);\n         ref_ar.Append(modelcurve.GeometryCurve.Reference);\n         ref_ar_ar.Append(ref_ar);\n\n         Autodesk.Revit.DB.Form form = doc.FamilyCreate.NewLoftForm(true, ref_ar_ar);\n\n         transaction.Commit();\n\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n      #endregion\n   }\n\n   /// <summary>\n   /// This class is utility class for form creation.\n   /// </summary>\n   public class FormUtils\n   {\n      #region Class Implementation\n      /// <summary>\n      /// Create arc element by three points\n      /// </summary>\n      /// <param name=\"app\">revit application</param>\n      /// <param name=\"ptA\">point a</param>\n      /// <param name=\"ptB\">point b</param>\n      /// <param name=\"ptC\">point c</param>\n      /// <returns></returns>\n      public static ModelCurve MakeArc(UIApplication app, Autodesk.Revit.DB.XYZ ptA, Autodesk.Revit.DB.XYZ ptB, Autodesk.Revit.DB.XYZ ptC)\n      {\n         Document doc = app.ActiveUIDocument.Document;\n         Arc arc = Arc.Create(ptA, ptB, ptC);\n         // Create three lines and a plane by the points\n         Line line1 = Line.CreateBound(ptA, ptB);\n         Line line2 = Line.CreateBound(ptB, ptC);\n         Line line3 = Line.CreateBound(ptC, ptA);\n         CurveLoop ca = new CurveLoop();\n         ca.Append(line1);\n         ca.Append(line2);\n         ca.Append(line3);\n\n            Plane plane = ca.GetPlane();// app.Application.Create.NewPlane(ca);\n         SketchPlane skplane = SketchPlane.Create(doc, plane);\n         // Create arc here\n         ModelCurve modelcurve = doc.FamilyCreate.NewModelCurve(arc, skplane);\n         return modelcurve;\n      }\n\n      /// <summary>\n      /// Create line element\n      /// </summary>\n      /// <param name=\"app\">revit application</param>\n      /// <param name=\"ptA\">start point</param>\n      /// <param name=\"ptB\">end point</param>\n      /// <returns></returns>\n      public static ModelCurve MakeLine(UIApplication app, Autodesk.Revit.DB.XYZ ptA, Autodesk.Revit.DB.XYZ ptB)\n      {\n         Document doc = app.ActiveUIDocument.Document;\n         // Create plane by the points\n         Line line = Line.CreateBound(ptA, ptB);\n         Autodesk.Revit.DB.XYZ norm = ptA.CrossProduct(ptB);\n         if (norm.GetLength() == 0) norm = Autodesk.Revit.DB.XYZ.BasisZ;\n         Plane plane = Plane.CreateByNormalAndOrigin(norm, ptB);\n         SketchPlane skplane = SketchPlane.Create(doc, plane);\n         // Create line here\n         ModelCurve modelcurve = doc.FamilyCreate.NewModelCurve(line, skplane);\n         return modelcurve;\n      }\n\n      /// <summary>\n      /// Create line element\n      /// </summary>\n      /// <param name=\"app\">revit application</param>\n      /// <param name=\"ptA\">start point</param>\n      /// <param name=\"ptB\">end point</param>\n      /// <returns></returns>\n      public static ModelCurve MakeLine(UIApplication app, Autodesk.Revit.DB.XYZ ptA, Autodesk.Revit.DB.XYZ ptB, Autodesk.Revit.DB.XYZ norm)\n      {\n         Document doc = app.ActiveUIDocument.Document;\n         // Create plane by the points\n         Line line = Line.CreateBound(ptA, ptB);\n         Plane plane = Plane.CreateByNormalAndOrigin(norm, ptB);\n         SketchPlane skplane = SketchPlane.Create(doc, plane);\n         // Create line here\n         ModelCurve modelcurve = doc.FamilyCreate.NewModelCurve(line, skplane);\n         return modelcurve;\n      }\n      #endregion\n   }\n}"
    },
    "documentation": {
      "ReadMe_NewForm.rtf": "Summary: This sample shows how to create form through Revit API\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Document\nAutodesk.Revit.DB.ModelCurve\nAutodesk.Revit.DB.Form\nAutodesk.Revit.Creation.FamilyItemFactory\n\nProject Files: \nCommand.cs\nThis file contains the class Command that inherits from IExternalCommand. The class implements the Execute method and be used to create forms in Revit.\n\nDescription: This sample mostly uses the FamilyItemFactory class for implementing the functionality: creating ExtrusionForm/ CapForm/ RevolveForm/ SweptBlendForm/ Loft Form elements.\n-\tTo create a profile, use MakeLine() or MakeArc() to create a ModelCurve and append it to a ReferenceArray.\n-\tTo create a path, use MakeLine() to create a ModelCurve.\n-\tUse Autodesk.Revit.Creation.FamilyItemFactory.NewXXXForm() to create forms.\n\nInstructions: \n1.\tIn order to create a form, user should manually create a family document by a template document  (For Imperial is: \\Imperial\\Templates\\Conceptual Mass\\ Mass.rft ; \n For Metric is: \\Metric\\Templates\\Conceptual Mass\\Metric Mass.rft)."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Massing\\PanelEdgeLengthAngle\\CS",
    "key_code": {
      "class_name": "SetLengthAngleParams",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         m_app = commandData.Application.Application;\n         m_doc = commandData.Application.ActiveUIDocument.Document;\n\n         // step 1: get all the divided surfaces in the Revit document\n         List<DividedSurface> dsList = GetElements<DividedSurface>();\n\n         foreach (DividedSurface ds in dsList)\n         {\n            // step 2: get the panel instances from the divided surface\n            List<FamilyInstance> fiList = GetFamilyInstances(ds);\n            foreach (FamilyInstance inst in fiList)\n            {\n               // step 3: compute the length and angle and set them to the parameters\n               InstParameters instParams = GetParams(inst);\n               EdgeArray edges = GetEdges(inst);\n               SetParams(m_doc, edges, instParams);\n            }\n         }\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n\n      /// <summary>\n      /// Get all the panel instances from a divided surface\n      /// </summary>\n      /// <param name=\"ds\">The divided surface with some panels</param>\n      /// <returns>A list containing all the panel instances</returns>\n      private List<FamilyInstance> GetFamilyInstances(DividedSurface ds)\n      {\n         List<FamilyInstance> fiList = new List<FamilyInstance>();\n\n         for (int u = 0; u < ds.NumberOfUGridlines; ++u)\n         {\n            for (int v = 0; v < ds.NumberOfVGridlines; ++v)\n            {\n               GridNode gn = new GridNode(u, v);\n               FamilyInstance familyInstance = ds.GetTileFamilyInstance(gn, 0);\n               if (familyInstance != null)\n               {\n                  fiList.Add(familyInstance);\n               }\n            }\n         }\n         return fiList;\n      }\n\n      /// <summary>\n      /// Get all the edges from the given family instance\n      /// </summary>\n      /// <param name=\"familyInstance\">The family instance with some edges</param>\n      /// <returns>Edges of the family instance</returns>\n      private EdgeArray GetEdges(FamilyInstance familyInstance)\n      {\n         Autodesk.Revit.DB.Options opt = m_app.Create.NewGeometryOptions();\n         opt.ComputeReferences = true;\n         Autodesk.Revit.DB.GeometryElement geomElem = familyInstance.get_Geometry(opt);\n         //foreach (GeometryObject geomObject1 in geomElem.Objects)\n         IEnumerator<GeometryObject> Objects = geomElem.GetEnumerator();\n         while (Objects.MoveNext())\n         {\n            GeometryObject geomObject1 = Objects.Current;\n\n            Solid solid = null;\n            // partial panels\n            if (geomObject1 is Solid)\n            {\n               solid = (Solid)geomObject1;\n               if (null == solid)\n                  continue;\n            }\n            // non-partial panels\n            else if (geomObject1 is Autodesk.Revit.DB.GeometryInstance)\n            {\n               GeometryInstance geomInst = geomObject1 as GeometryInstance;\n               //foreach (Object geomObj in geomInst.SymbolGeometry.Objects)\n               IEnumerator<GeometryObject> Objects1 = geomInst.SymbolGeometry.GetEnumerator();\n               while (Objects1.MoveNext())\n               {\n                  Object geomObj = Objects1.Current;\n\n                  solid = geomObj as Solid;\n                  if (solid != null)\n                     break;\n               }\n            }\n\n            if (null == solid ||    // the solid can't be null\n                null == solid.Faces || 0 == solid.Faces.Size ||   // the solid must have 1 or more faces\n                null == solid.Faces.get_Item(0) ||   // the solid must have a NOT-null face\n                null == solid.Faces.get_Item(0).EdgeLoops || 0 == solid.Faces.get_Item(0).EdgeLoops.Size) // the face must have some edges\n               continue;\n\n            return solid.Faces.get_Item(0).EdgeLoops.get_Item(0);\n         }\n\n         return null;\n      }\n\n      /// <summary>\n      /// Compute the length and angle data of the edges, then update the parameters with these values\n      /// </summary>\n      /// <param name=\"document\">The active document.</param>\n      /// <param name=\"edge_ar\">The edges of the curtain panel</param>\n      /// <param name=\"instParams\">The parameters which records the length and angle data</param>\n      private void SetParams(Document document, EdgeArray edge_ar, InstParameters instParams)\n      {\n         double length4 = 0d;\n         double angle3 = 0d;\n         double angle4 = 0d;\n         Edge edge1 = edge_ar.get_Item(0);\n         Edge edge2 = edge_ar.get_Item(1);\n         Edge edge3 = edge_ar.get_Item(2);\n         double length1 = edge1.ApproximateLength;\n         double length2 = edge2.ApproximateLength;\n         double length3 = edge3.ApproximateLength;\n         double angle1 = AngleBetweenEdges(edge1, edge2);\n         double angle2 = AngleBetweenEdges(edge2, edge3);\n\n         if (edge_ar.Size == 3)\n         {\n            angle3 = AngleBetweenEdges(edge3, edge1);\n         }\n         else if (edge_ar.Size > 3)\n         {\n            Edge edge4 = edge_ar.get_Item(3);\n            length4 = edge4.ApproximateLength;\n            angle3 = AngleBetweenEdges(edge3, edge4);\n            angle4 = AngleBetweenEdges(edge4, edge1);\n         }\n\n         using (Transaction transaction = new Transaction(document, \"Update family instance parameters\"))\n         {\n            transaction.Start();\n\n            instParams[\"Length1\"].Set(length1);\n            instParams[\"Length2\"].Set(length2);\n            instParams[\"Length3\"].Set(length3);\n            instParams[\"Length4\"].Set(length4);\n            instParams[\"Angle1\"].Set(angle1);\n            instParams[\"Angle2\"].Set(angle2);\n            instParams[\"Angle3\"].Set(angle3);\n            instParams[\"Angle4\"].Set(angle4);\n\n            transaction.Commit();\n         }\n      }\n\n      /// <summary>\n      /// Compute the angle between two edges\n      /// </summary>\n      /// <param name=\"edgeA\">The 1st edge</param>\n      /// <param name=\"edgeB\">The 2nd edge</param>\n      /// <returns>The angle of the 2 edges</returns>\n      private double AngleBetweenEdges(Edge edgeA, Edge edgeB)\n      {\n         Autodesk.Revit.DB.XYZ vectorA = null;\n         Autodesk.Revit.DB.XYZ vectorB = null;\n\n         // find coincident vertices\n         Autodesk.Revit.DB.XYZ A_0 = edgeA.Evaluate(0);\n         Autodesk.Revit.DB.XYZ A_1 = edgeA.Evaluate(1);\n         Autodesk.Revit.DB.XYZ B_0 = edgeB.Evaluate(0);\n         Autodesk.Revit.DB.XYZ B_1 = edgeB.Evaluate(1);\n         if (A_0.IsAlmostEqualTo(B_0))\n         {\n            vectorA = edgeA.ComputeDerivatives(0).BasisX.Normalize();\n            vectorB = edgeA.ComputeDerivatives(0).BasisX.Normalize();\n         }\n         else if (A_0.IsAlmostEqualTo(B_1))\n         {\n            vectorA = edgeA.ComputeDerivatives(0).BasisX.Normalize();\n            vectorB = edgeB.ComputeDerivatives(1).BasisX.Normalize();\n         }\n         else if (A_1.IsAlmostEqualTo(B_0))\n         {\n            vectorA = edgeA.ComputeDerivatives(1).BasisX.Normalize();\n            vectorB = edgeB.ComputeDerivatives(0).BasisX.Normalize();\n         }\n         else if (A_1.IsAlmostEqualTo(B_1))\n         {\n            vectorA = edgeA.ComputeDerivatives(1).BasisX.Normalize();\n            vectorB = edgeB.ComputeDerivatives(1).BasisX.Normalize();\n         }\n\n         if (A_1.IsAlmostEqualTo(B_0) || A_0.IsAlmostEqualTo(B_1)) vectorA = vectorA.Negate();\n\n         if (null == vectorA || null == vectorB)\n         {\n            return 0d;\n         }\n         double angle = Math.Acos(vectorA.DotProduct(vectorB));\n         return angle;\n      }\n\n      /// <summary>\n      /// Get all the parameters and store them into a list\n      /// </summary>\n      /// <param name=\"familyInstance\">The instance of a curtain panel</param>\n      /// <returns>A list containing all the required parameters</returns>\n      private InstParameters GetParams(FamilyInstance familyInstance)\n      {\n         InstParameters iParams = new InstParameters();\n         Parameter L1 = familyInstance.LookupParameter(\"Length1\");\n         Parameter L2 = familyInstance.LookupParameter(\"Length2\");\n         Parameter L3 = familyInstance.LookupParameter(\"Length3\");\n         Parameter L4 = familyInstance.LookupParameter(\"Length4\");\n         Parameter A1 = familyInstance.LookupParameter(\"Angle1\");\n         Parameter A2 = familyInstance.LookupParameter(\"Angle2\");\n         Parameter A3 = familyInstance.LookupParameter(\"Angle3\");\n         Parameter A4 = familyInstance.LookupParameter(\"Angle4\");\n\n         if (L1 == null || L2 == null || L3 == null || L4 == null || A1 == null || A2 == null || A3 == null || A4 == null)\n         {\n            string errorstring = \"Panel family: \" + familyInstance.Id.ToString() + \" '\" + familyInstance.Symbol.Family.Name + \"' must have instance parameters Length1, Length2, Length3, Length4, Angle1, Angle2, Angle3, and Angle4\";\n            TaskDialog.Show(\"Revit\", errorstring);\n            //   throw new ArgumentException(errorstring);\n         }\n\n         iParams[\"Length1\"] = L1;\n         iParams[\"Length2\"] = L2;\n         iParams[\"Length3\"] = L3;\n         iParams[\"Length4\"] = L4;\n         iParams[\"Angle1\"] = A1;\n         iParams[\"Angle2\"] = A2;\n         iParams[\"Angle3\"] = A3;\n         iParams[\"Angle4\"] = A4;\n\n         return iParams;\n      }\n\n      protected List<T> GetElements<T>() where T : Element\n      {\n         List<T> returns = new List<T>();\n         FilteredElementCollector collector = new FilteredElementCollector(m_doc);\n         ICollection<Element> founds = collector.OfClass(typeof(T)).ToElements();\n         foreach (Element elem in founds)\n         {\n            returns.Add(elem as T);\n         }\n         return returns;\n      }\n\n   }\n\n   /// <summary>\n   /// This class contains a dictionary which stores the parameter and parameter name pairs\n   /// </summary>\n   class InstParameters\n   {\n      private Dictionary<string, Parameter> m_parameters = new Dictionary<string, Parameter>(8);\n\n      /// <summary>\n      /// Get/Set the parameter by its name\n      /// </summary>\n      /// <param name=\"index\">the name of the parameter</param>\n      /// <returns>The parameter which matches the name</returns>\n      public Parameter this[string index]\n      {\n         get\n         {\n            return m_parameters[index];\n         }\n         set\n         {\n            m_parameters[index] = value;\n         }\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_PanelEdgeLengthAngle.rtf": "Summary: Measure the edge length and angle of curtain panels in divided surfaces. Save the length and angle data to the instance parameters of curtain panels.\n\nClasses: \n\tAutodesk.Revit.UI.IExternalCommand\n\tAutodesk.Revit.DB.DividedSurface\n\tAutodesk.Revit.DB.Panel\n\nProject Files:\n\nCommand.cs\n\tThis file contains the SetLengthAngleParams class and is invoked when the external command. This class is used to compute the length and angle data and update the parameters.\n\nDescription: 1.\tFind divided surfaces in the massing family\n2.\tFind all panels in the DividedSurface elements. The panels are FamilyInstance elements returned by the DividedSurface.GetTileFamilyInstance(GridNode, tileIndex) method.\n3.\tCheck the parameters of each panel, make sure the “Length1” to “Length4” and “Angle1” to “Angle4” parameters exist\n4.\tGet the edges of each panel using FamilyInstance.get_Geometry(opt)\na.\tFor partial border panels, get_Geometry returns the panel geometry in a Solid object\nb.\tFor uncut panels, their geometry is found through Instance.SymbolGeometry.Objects\n5.\tCompute the length of each edge and the angle between 2 edges, store the data to the length and angle parameters.\n\nInstructions: \n1.\tOpen a curtain panel by pattern family from the Data folder, for example, “Rectangle Surface.rfa” (at .\\ Data\\Platform\\Imperial\\Library\\Architectural\\Curtain Panel By Pattern\\Rectangle Surface.rfa)\n2.\tAdd 8 instance parameters: “Length1” to “Length4” with the type of Length, and “Angle1” to “Angle4” with the type of Angle\n3.\tCreate one or more massing forms with divided surfaces, load the panel family into this massing family, and apply “Rectangle Surface” pattern to the divided surfaces\n4.\tRun this command\n5.\tThe length and angle values are computed and set to the “Length1” to “Length4” and “Angle1” to “Angle4” parameters\n\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\ModelLines\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n                                               ref string message,\n                                               ElementSet elements)\n        {\n            try\n            {\n                Transaction documentTransaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Document\");\n                documentTransaction.Start();\n                // Get the application of revit\n                Autodesk.Revit.UI.UIApplication revit = commandData.Application;\n\n                // New a real operation class.\n                ModelLines deal = new ModelLines(revit);\n\n                // The main deal operation\n                deal.Run();\n                documentTransaction.Commit();\n\n                // if everything goes well, return succeeded.\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception ex)\n            {\n                // If any error, give error information and return failed\n                message = ex.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }           \n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_ModelLines.rtf": "Summary: This sample shows how to get model lines of all kinds and how to create model lines using Revit API.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.ModelArc\nAutodesk.Revit.DB.ModelLine\nAutodesk.Revit.DB.ModelCurveArray\nAutodesk.Revit.DB.ModelCurve\nAutodesk.Revit.DB.SketchPlane\nAutodesk.Revit.Creation.Application\nAutodesk.Revit.DB.Arc\nAutodesk.Revit.DB.XYZ\nAutodesk.Revit.DB.Line\n\nProject Files:\n\nModelLines.cs\nThis file contains the ModelLines Class which is the main class and takes charge of showing the number of each model line type and creating one instance for each type using Revit API.\n\nModelLinesForm.cs\nThis is the main form to show all the model lines and allow user to create model lines and sketch plan.\n\nDescription: -\tGet the number of each model line type in a list. ModelLines can be located by iterating through the document elements, such as ModelArc, ModelEllipse and ModelLine and so forth.\n-\tFor creating a ModelArc type model line, input three points to create it.\n-\tFor creating a ModelLine type model line, input two points to create it.\n-\tFor the other types, select a base model curve which provides the corresponding curve and then input offset vector from the selected base model curve.\n-\tSelect a sketch plane to place the created model curve and you can also create a new sketch plane if you want. The creation of sketch plane can be done with NewSketchPlane() method in Autodesk.Revit.Creation.Document class.\n-\tThe creation of model lines can be done with NewModelCurve() and NewModelCurveArray() methods in Autodesk.Revit.Creation.Document class.\n\nInstructions: \n1.\tDraw some model lines in Revit.\n2.\tLoad the ModelLines.dll and run the command, it will get all model lines in Revit and display the number of each type.\n3.\tYou can create a model line type by inputting some information on a sketch plan. Such as input three points to create a ModelArc type model line and then click the create button.\n4.\tYou can also create a new sketch plan using the “New” button. You should supply two model lines to create it.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\MultistoryStairs\\CS",
    "key_code": {
      "class_name": "AddStairsCommand",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n          ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         Transaction newTran = null;\n         try\n         {\n            UIDocument uiDoc = commandData.Application.ActiveUIDocument;\n            if (null == uiDoc)\n            {\n               message = \"this command needs to be run in an active document.\";\n               return Result.Failed;\n            }\n            Document doc = uiDoc.Document;\n\n            ICollection<ElementId> selectedId = uiDoc.Selection.GetElementIds();\n            if (1 != selectedId.Count)\n            {\n               message = \"Please select a multistory stairs before running this command.\";\n               return Result.Failed;\n            }\n            MultistoryStairs mStairs = doc.GetElement(selectedId.ElementAt(0)) as MultistoryStairs;\n            if (null == mStairs)\n            {\n               message = \"Please select a multistory stairs before running this command.\";\n               return Result.Failed;\n            }\n\n            View currentView = doc.ActiveView;\n            if (null == currentView || currentView.ViewType != ViewType.Elevation || !currentView.CanBePrinted)\n            {\n               message = \"The current view should be an elevation view to allow user to select levels.\";\n               return Result.Failed;\n            }\n\n            // allow the user to select the stairs to add stairs.\n            LevelSelectionFilter selectionFilter = new LevelSelectionFilter(mStairs, OperationAction.Add);\n            IList<Reference> userSelectedRefs = uiDoc.Selection.PickObjects(Autodesk.Revit.UI.Selection.ObjectType.Element, selectionFilter);\n            IEnumerable<ElementId> userSelectedIds = from refer in userSelectedRefs select refer.ElementId;\n\n            // start the transaction and add the stairs into the multistory stairs.\n            newTran = new Transaction(doc, \"Add Stairs to Multistory Stairs\");\n            newTran.Start();\n            mStairs.AddStairsByLevelIds(new HashSet<ElementId>(userSelectedIds));\n            newTran.Commit();\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n         }\n         catch (Exception e)\n         {\n            message = e.Message;\n            if ((newTran != null) && newTran.HasStarted() && !newTran.HasEnded())\n               newTran.RollBack();\n            return Autodesk.Revit.UI.Result.Failed;\n         }\n      }\n      #endregion IExternalCommand Members Implementation\n   }\n\n\n   /// <summary>\n   /// A command that remove the stairs from multistory stairs by picking the levels (have aligned stairs to)\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   [Autodesk.Revit.Attributes.Journaling(Autodesk.Revit.Attributes.JournalingMode.NoCommandData)]\n   public class RemoveStairsCommand : IExternalCommand\n   {\n      #region IExternalCommand Members Implementation\n      /// <summary>\n      /// Implement this method as an external command for Revit.\n      /// </summary>\n      /// <param name=\"commandData\">An object that is passed to the external application \n      /// which contains data related to the command, \n      /// such as the application object and active view.</param>\n      /// <param name=\"message\">A message that can be set by the external application \n      /// which will be displayed if a failure or cancellation is returned by \n      /// the external command.</param>\n      /// <param name=\"elements\">A set of elements to which the external application \n      /// can add elements that are to be highlighted in case of failure or cancellation.</param>\n      /// <returns>Return the status of the external command. \n      /// A result of Succeeded means that the API external method functioned as expected. \n      /// Cancelled can be used to signify that the user canceled the external operation \n      /// at some point. Failure should be returned if the application is unable to proceed with \n      /// the operation.</returns>\n      public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n          ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         Transaction newTran = null;\n         try\n         {\n            UIDocument uiDoc = commandData.Application.ActiveUIDocument;\n            if (null == uiDoc)\n            {\n               message = \"this command needs to be run in an active document.\";\n               return Result.Failed;\n            }\n            Document doc = uiDoc.Document;\n\n            ICollection<ElementId> selectedId = uiDoc.Selection.GetElementIds();\n            if (1 != selectedId.Count)\n            {\n               message = \"Please select a multistory stairs before running this command.\";\n               return Result.Failed;\n            }\n            MultistoryStairs mStairs = doc.GetElement(selectedId.ElementAt(0)) as MultistoryStairs;\n            if (null == mStairs)\n            {\n               message = \"Please select a multistory stairs before running this command.\";\n               return Result.Failed;\n            }\n\n            View currentView = doc.ActiveView;\n            if (null == currentView || currentView.ViewType != ViewType.Elevation || !currentView.CanBePrinted)\n            {\n               message = \"The current view should be an elevation view to allow user to select levels.\";\n               return Result.Failed;\n            }\n\n            // allow the user to select the levels to remove stairs.\n            LevelSelectionFilter selectionFilter = new LevelSelectionFilter(mStairs, OperationAction.Remove);\n            IList<Reference> userSelectedRefs = uiDoc.Selection.PickObjects(Autodesk.Revit.UI.Selection.ObjectType.Element, selectionFilter);\n            IEnumerable<ElementId> userSelectedIds = from refer in userSelectedRefs select refer.ElementId;\n\n            // start the transaction and remove stairs from the multistory stairs.\n            newTran = new Transaction(doc, \"Remove Stairs from Multistory Stairs\");\n            newTran.Start();\n            mStairs.RemoveStairsByLevelIds(new HashSet<ElementId>(userSelectedIds));\n            newTran.Commit();\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n         }\n         catch (Exception e)\n         {\n            message = e.Message;\n            if ((newTran != null) && newTran.HasStarted() && !newTran.HasEnded())\n               newTran.RollBack();\n            return Autodesk.Revit.UI.Result.Failed;\n         }\n      }\n      #endregion IExternalCommand Members Implementation\n   }\n}"
    },
    "documentation": {
      "Readme_MultistoryStairs.rtf": "Summary: MultistoryStairs editing utilities, including creating multistory stairs by a standard stairs, adding/removing stairs by picking level.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.UI.Selection.ISelectionFilter\nAutodesk.Revit.DB.Architecture.MultistoryStairs\n\nProject Files: \nApplication.cs - Implements the Revit add-in interface IExternalApplication\nCreationCommand.cs – A command that creates a multistory stairs by giving a stairs element.\nAddRemoveStairsCommand.cs – two commands for stairs operation: \nA command that add the stairs into multistory stairs by picking the levels (which can align stairs to).\nA command that remove the stairs from multistory stairs by picking the levels (have aligned stairs to).\nMySelctionFilter.cs – a selection filters which are used to filter out selectable levels.\n\nDescription: This sample provides following functionalities.\nCreate a multistory stairs by a standard stairs.\nPicking some levels to add aligned stairs into the multistory stairs.\nPicking some levels to remove aligned stairs from the multistory stairs.\n\nInstructions: \nOpen a Revit project; draw a component stairs into the project.  Switch to the Add-ins tab.\nSelect a component stairs and click the “Create single multistory stairs” button on “API_MultistoryStairs” tab to create a multistory stairs element for the selected component stairs.\nSelect a multistory stairs and click the “Add stairs by picking levels” button on “API_MultistoryStairs” tab, and then select some levels which can align stairs to add stairs into the selected multistory stairs.\nSelect a multistory stairs and click the “Remove stairs by picking levels” button on “API_MultistoryStairs” tab, and then select some levels have aligned stairs to remove stairs from the selected multistory stairs."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\NetworkPressureLossReport\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n\n            // Get the application and document from external command data.\n            Document activeDoc = commandData.Application.ActiveUIDocument.Document;\n\n            NetworkDialog dlg = new NetworkDialog(activeDoc);\n            dlg.ShowDialog();\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_NetworkPressureLossReport.rtf": "Summary: This addin sample shows how to access the MEP analytical model data and traverse the network. The flow and pressure loss results are exported to a csv file or displayed in Analysis Visualization Framework (AVF).\n\nClasses: \nAutodesk.Revit.DB.Analysis.MEPAnalyticalModelData\nAutodesk.Revit.DB.Analysis.MEPAnalyticalSegment\nAutodesk.Revit.DB.Analysis.MEPAnalyticalNode\nAutodesk.Revit.DB.Analysis.MEPNetworkSegementId\nAutodesk.Revit.DB.Analysis.MEPNetworkIterator\nAutodesk.Revit.DB.Analysis.MEPNetworkSegmentData\n\nAutodesk.Revit.DB.Analysis.SpatialFieldManager\nAutodesk.Revit.DB.Analysis.AnalysisResultSchema\nAutodesk.Revit.DB.Analysis.AnalysisDisplayStyle\nAutodesk.Revit.DB.Analysis.AnalysisDisplayColorSettings\nAutodesk.Revit.DB.Analysis.AnalysisDisplayVectorSettings\nAutodesk.Revit.DB.Analysis.AnalyssiDisplayLegendSettings\nAutodesk.Revit.DB.Analysis.FieldDomainPointsByXYZ\nAutodesk.Revit.DB.Analysis.FieldValue\n\nAutodesk.Revit.DB.ConnectorDomainType\nAutodesk.Revit.DB.FabricationService\nAutodesk.Revit.DB.ForgeTypeId\nAutodesk.Revit.DB.FormatOptions\nAutodesk.Revit.DB.MEPSystem\nAutodesk.Revit.DB.OverrideGraphicSettings\nAutodesk.Revit.DB.UnitFormatUtils\nAutodesk.Revit.DB.SpecTypeId\nAutodesk.Revit.DB.UnitUtils\nAutodesk.Revit.DB.View\n\nAutodesk.Revit.UI.IExternalCommand \n\nProject Files: \n·\tCommand.cs\nIt contains the command interface to start the dialog.\n\n·\tNetworkDialog.xaml\nIt contains the dialog window in the WPF xaml format.\n\n·\tNetworkDialog.xaml.cs\nIt contains the dialog initialization and interface to other functions.\n\n·\tNetworkInfo.cs\nIt contains the information of one network. The static method FindValidNetworks starts from all mechanical or terminal elements, iterates the connected analytical segments, and establishes the Network/Section/Segment information for later operations.\n\n·\tSectionInfo.cs\nA section contains multiple analytical segments that share the same size and velocity. The network is typically organized by sections in the pressure loss report.\n\n·\tSegmentInfo.cs\nThis class contains all relevant information of analytical segment for pressure loss report, gathered from MEPAnalyticalModelData, MEPAnalyticalSegement, MEPAnalyticalNode, and MEPNetworkSegmentData.\n\n·\tCSVExporter.cs\nIt wraps a few data objects relevant to the pressure loss report, including the StreamWriter that writes out the CSV file, and other convenient method to convert units.\n\n·\tAVFViewer.cs\nIt wraps the data objects relevant to the AVF, including the SpatialFieldManager that oversees the visualization work.\n\nDescription: Run the command “Pressure Loss Report” under the Add-Ins once the dll is loaded into Revit. It finds all valid networks that show up in the dialog. \n\n\n\nThe selected network can be exported into a csv file. It may be loaded into applications like Excel to better visualize the table, as shown below. Notice that the secton has the straight and fitting subtotal. If users want to have the breakdown of individual analytical segments, they may check the “Itemized” to export the table. \n\n\n\nUsers may also click the View button on the dialog to display the flow direction and values. It is important to note that the flow vector length is scaled to the flow value. So is the color of these flow arrows. Since this is based on the AVF, the colors and other visualization settings can be modified in Revit."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\NewHostedSweep\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, \n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            try\n            {\n                CreationMgr mgr = new CreationMgr(commandData.Application.ActiveUIDocument);\n                mgr.Execute();\n            }\n            catch(Exception e)\n            {\n                message += e.StackTrace;\n                return Autodesk.Revit.UI.Result.Cancelled;\n            }            \n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_NewHostedSweep.rtf": "Summary: This sample will demonstrate how to create hosted sweep (includes Fascia, Gutter and SlabEdge), and how to modify their properties.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.DB.Document\nAutodesk.Revit.Creation.Document\nAutodesk.Revit.DB.HostedSweep\nAutodesk.Revit.DB.HostedSweepType\nAutodesk.Revit.DB.SlabEdge\nAutodesk.Revit.DB.SlabEdgeType\nAutodesk.Revit.DB.Architecture.Fascia\nAutodesk.Revit.DB.Architecture.Gutter\nAutodesk.Revit.DB.Architecture.FasciaType\nAutodesk.Revit.DB.Architecture.GutterType\nAutodesk.Revit.DB.Solid\nAutodesk.Revit.DB.Edge\nAutodesk.Revit.DB.Reference\nAutodesk.Revit.DB.Transform\n\nProject Files: \nCommand.cs\nThis is the entrance of this sample. It implements IExternalCommand Execute method.\n\nHostedSweepCreator.cs\nThis is an abstract class and is the base class of FasciaCreator, GutterCreator, and SlabEdgeCreator.\n\nFasciaCreator.cs\nThis class inherits base class HostedSweepCreator, and it is intent to create Fascia.\n\nGutterCreator.cs\nThis class inherits base class HostedSweepCreator, and it is intent to create Gutter.\n\nSlabEdgeCreator.cs\nThis class inherits base class HostedSweepCreator, and it is intent to create SlabEdge.\n\nCreationMgr.cs\nThis is the manager of all hosted sweep creators, it contains all the creators and each creator can be used to create corresponding hosted sweep. Its \"Execute” method will show the main dialog for user to create hosted sweeps.\n\n\nCreationData.cs\nThis class contains the data for hosted sweep creation.\n\nModificationData.cs\nThis class contains the data for hosted sweep modification.\n\nEdgeFetchForm.cs\nThis form is intent to fetch edges for hosted sweep creation or modification. It contains a picture box for geometry preview and a tree view to list all the edges which hosted sweep can be created on.\n\nHostedSweepModifyForm.cs\nThis form contains a property grid control to modify the property of hosted sweep.\n\nMainForm.cs\nThis is the main form. It is the entry to create a new hosted sweep or to modify a created hosted sweep.\n\nElementGeometry.cs\nThis class is intent to display element's wire-frame with C# GDI. It contains a solid and a bounding box of an element. It also contains transformation (translation, rotation and scale) to transform the geometry edges.\n\nTrackBall.cs\nThis class is intent to facilitate the geometry transformations. It can produce rotation and scale transformations.\n\nDescription: This sample let user create hosted sweep and modify the created hosted sweep. \nIts Implementation lists as below:\nØ\tTypes can be gotten via Document properties FasciaTypes, GutterTypes, and SlabEdgeTypes. These types can be used to create Fascia, Gutter, and SlabEdge.\nØ\tFascia will be created with NewFascia (FasciaType, ReferenceArray), Gutter with NewGutter (GutterType, ReferenceArray) and SlabEdge with NewSlabEdge (SlabEdgeType, ReferenceArray). The first parameter can be null (the default type will be used) or the types from Document and the second parameter will be the edges’ references of a roof or a floor.\nØ\tSegments can be added via method AddSegment (Reference) of each subclass of HostedSweep. \nØ\tSegments can be removed via method RemoveSegment (Reference) of HostedSweep.\nØ\tAngle, HorizontalOffset and VerticalOffset are get/set properties of HostedSweep, and their value can be get and set easily. \nØ\tFlip states in horizontal or vertical direction of HostedSweep can be changed via method HorizontalFlip (), and VerticalFlip (). Properties of HorizontalFlipped and VerticalFlipped can query the flip states in horizontal or vertical direction.\nØ\tTransaction will be used in each operation (eg. creating HostedSweep or changing HostedSweep properties) in order to see the result immediately in Revit after each operation. Methods of Document’s BeginTransaction (), EndTransaction () and AbortTransaction () will be used to do transaction operation.\nØ\tThe edges are filtered via method AddSegment (). If AddSegment () throws exception, then this edge will be discarded otherwise this edge will be treated as an eligible edge.\n\n\nLimitations:\nIn order to filter out the edges which hosted sweep can be created on, this sample uses below methods which may not be supported in future version:\nFascia fascia = NewFascia (null, new ReferenceArray ());\nGutter gutter = NewGutter (null, new ReferenceArray ());\nSlabEdge slabEdge = NewSlabEdge (null, new ReferenceArray ()).\n\nInstructions: \n1.\tOpen or new a Revit project and make sure some Roofs or Floors are placed. A sample project file NewHostedSweep.rvt is available in the sample’s folder.\n2.\tRun this Command, the main dialog will be presented.\n3.\tIn the main dialog, select a hosted sweep type in the combo-box list and click the button Create. A dialog will be presented for the user to fetch edges and select a type in the combo-box list for the hosted sweep creation. After fetching some edges and selecting a type, click OK button will create a hosted sweep, otherwise Cancel button will cancel this creation operation.\nEdge fetching operation details:\nØ\tIf the user mouse-over an edge where a hosted sweep can be created, the edge will be highlighted in yellow.\nØ\tIf the user clicks on the highlighted edge, the edge will be selected with red color or click again to un-select. \nØ\tEdge selection from preview box will be reflected in the edge list and vice versa. \nØ\tThe geometry displayed in the picture box can be rotated by holding down the left mouse button and turning, or zoom by holding down the right button to move. \nØ\tPressing arrow keys will also rotate the geometry round X-axis or Y-axis.\n4.\tTo modify, select a hosted sweep type in the combo-box list and select a created hosted sweep in the list box from the main dialog, then click the button Modify to popup the form to modify the properties of the selected sweep. In the modification form, user can change the value in the property grid and the changes will reflect in Revit immediately.\n5.\tUser can create more than one hosted sweep, and each created hosted sweep will be listed in the list box based on category and grouped by their type. After user click OK button in the main form, this command will exit.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\NewMacro\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n      ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         try\n         {\n            UIMacroManager uiMacroManager = UIMacroManager.GetMacroManager(commandData.Application);\n            //Create new MacroModule, if exists old MacroModule with same name,return old.\n            MacroModule module = GetModule(uiMacroManager, ModuleMaker.ProjectName);\n\n            if (module == null)\n            {\n               ModuleSettings ms = new ModuleSettings(ModuleMaker.ProjectName, MacroLanguageType.CSharp);\n               module = uiMacroManager.AddModule(ms, MacroEnvironment.UI, new ModuleMaker());\n            }\n\n            Macro macro = GetMacro(module, ModuleMaker.MacroName);\n            if (macro != null)\n            {\n               macro.Execute();\n            }\n            else\n            {\n               TaskDialog.Show(\"Error\", $\"can't found Macro:{ModuleMaker.MacroName}\");\n               return Result.Failed;\n            }\n\n         }\n         catch (Exception e)\n         {\n            message = e.Message;\n            return Result.Failed;\n         }\n         return Result.Succeeded;\n      }\n\n\n      /// <summary>\n      /// Get MacroModule from UIMacroManager.\n      /// </summary>\n      /// <param name=\"manager\">UIMacroManager, manage all UI MacroModules.</param>\n      /// <param name=\"moduleName\">Used to identify the module.</param>\n      private MacroModule GetModule(UIMacroManager uiMacroManager, string moduleName)\n      {\n\n         foreach (var module in uiMacroManager.MacroManager)\n         {\n            if (module == null || module.Name != moduleName)\n               continue;\n            return module;\n         }\n         return null;\n      }\n\n      /// <summary>\n      /// Get Macro from MacroModule.\n      /// </summary>\n      /// <param name=\"module\">MacroModule, manage all Macro in current Module.</param>\n      /// <param name=\"macroName\">Used to identify the Macro.</param>\n      private Macro GetMacro(MacroModule module, string macroName)\n      {\n         if (module == null)\n            return null;\n         foreach (var macroMethod in module)\n         {\n            if (macroMethod != null && macroMethod.Name == macroName)\n               return macroMethod;\n         }\n         return null;\n      }\n      #endregion IExternalCommand Members Implementation\n   }\n}"
    },
    "documentation": {
      "ReadMe_NewMacro.rtf": "Summary: This sample demonstrates how to generate a new Macro that includes basic codes. It also demonstrates how to build Macro and how to get excute Macro by MacroManager. \n\nClasses: \nAutodesk.Revit.DB.Macros.MacroModule.\nAutodesk.Revit.UI.Macros.UIMacroManager.\nAutodesk.Revit.DB.Macros. ModuleSettings.\nAutodesk.Revit.DB.Macros. Macro.\n\n\nProject Files:\nNewMacro.cs\nIt contains one class:\n-\tThe class Command which implements interface IExternalCommand, it is the entry of this external command.\nModuleMaker.cs\nIt contains one class:\nThe class ModuleMaker Implements the Revit Macro interface IModuleMaker.\n\nDescription: This sample demonstrates the following functionalities:\n-\tCreate a new  Macro by defualt code.\n-    Excute this Macro. \n\nInstructions:\nUse case “New Macro”:\nCopy ” NewMacro” dir to addin folder.\nRun this external command.\nIt will show a “Hello World” Dialog.GenerateD by Macro."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\NewPathReinforcement\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         try\n         {\n            Wall wall = null;\n            Floor floor = null;\n\n            ElementSet elems = new ElementSet();\n            foreach (ElementId elementId in commandData.Application.ActiveUIDocument.Selection.GetElementIds())\n            {\n               elems.Insert(commandData.Application.ActiveUIDocument.Document.GetElement(elementId));\n            }\n            #region selection handle -- select one Slab (or Structure Wall)\n            //if user had some wrong selection, give user an Error message\n            string errorMessage =\n                \"Please select one Slab (or Structure Wall) to create PathReinforcement.\";\n            if (1 != elems.Size)\n            {\n               message = errorMessage;\n               return Autodesk.Revit.UI.Result.Cancelled;\n            }\n\n            Autodesk.Revit.DB.Element selectElem = null;\n            IEnumerator iter = elems.GetEnumerator();\n            iter.Reset();\n            if (iter.MoveNext())\n            {\n               selectElem = (Autodesk.Revit.DB.Element)iter.Current;\n            }\n\n            if (selectElem is Wall)\n            {\n               wall = selectElem as Wall;\n            }\n            else if (selectElem is Floor)\n            {\n               floor = selectElem as Floor;\n            }\n            else\n            {\n               message = errorMessage;\n               return Autodesk.Revit.UI.Result.Cancelled;\n            }\n            #endregion\n            try\n            {\n               if (null != wall)\n               {\n                  ProfileWall profileWall = new ProfileWall(wall, commandData);\n                  NewPathReinforcementForm newPathReinforcementForm =\n                      new NewPathReinforcementForm(profileWall);\n                  newPathReinforcementForm.ShowDialog();\n               }\n               else if (null != floor)\n               {\n                  ProfileFloor profileFloor = new ProfileFloor(floor, commandData);\n                  NewPathReinforcementForm newPathReinforcementForm =\n                      new NewPathReinforcementForm(profileFloor);\n                  newPathReinforcementForm.ShowDialog();\n               }\n            }\n            catch (Exception ex)\n            {\n               message = ex.Message;\n               return Autodesk.Revit.UI.Result.Cancelled;\n            }\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n         }\n         catch (Exception e)\n         {\n            message = e.Message;\n            return Autodesk.Revit.UI.Result.Failed;\n         }\n      }\n      #endregion\n   }\n}"
    },
    "documentation": {
      "ReadMe_NewPathReinforcement.rtf": "Summary: This sample demonstrates how to create PathReinforcement by API.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Structure.PathReinforcement \nAutodesk.Revit.DB.Structure.PathReinforcementType\nAutodesk.Revit.DB.Face\nAutodesk.Revit.DB.Edge\nAutodesk.Revit.DB.Solid\nAutodesk.Revit.Creation.Document\n\nProject Files: \nCommand.cs\nThis file contains a class Command that implements the IExternalCommand, gets the selected wall or floor and creates PathReinforcement on it.\n\nNewPathReinforcementForm.cs\nThis file contains a class NewPathReinforcementForm which inherits from Form, the function of this class is to display the selected Wall or Floor profile and let user draw path of PathReinforcement on it.\n\nProfile.cs\nThis file contains an abstract class Profile which is derived by ProfileWall and ProfileFloor. Profile includes two methods Draw2D() and CreatePathReinforcement(), Draw2D() is used to draw profile on the form, and CreatePathReinforcement() is used to create PathReinforcement on the selected Wall or Floor.\n\nLineTool.cs\nThis file contains a class named LineTool which provides some methods to draw lines on the form and store the data of drawn lines.\n\nMathTools.cs\nThis file contains Verctor4 and Matrix4 two classes. These two classes are used to transform points between 3D and 2D.\n\nDescription: This sample shows user how to create PathReinforcement by \nNewPathReinforcement(PathReinforcementType, Element, CurveArray, bool) method:\n-\tUse Document.Create.NewPathReinforcementType() method to create one PathReinforcementType if there is no PathReinforcementType in current document.\n-\tElement here stands for the host of the PathReinforcement, a wall or a floor.\n-\tCurveArray stores the Path of the PathReinforcement.\n-\tbool value indicates the PathReinforcement lies to which side of Path.\n\nInstructions: \n1.\tDraw a Structure Wall or Slab (or open NewPathReinforcement.rvt) and select it.\n2.\tRun this command.\n3.\tDraw the path of PathReinforcement you want to create, user can click right mouse button to finish drawing.\n4.\tClick the “Preview” will preview the path reinforcement will be created.\n5.\tSelect or unselect “Flip” check box to create PathReinforcement on the left or right side of the path which you drawn.\n6.\tClick “Create” button will create PathReinforcement when you finish the path.\n7.\tUser can clean and redraw the sketch of path when click “Clean” button.\n\n\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\NewRebar\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n\n            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"External Tool\");\n            try\n            {\n                transaction.Start();\n                RebarCreator creator = new RebarCreator(commandData);\n                creator.Execute();\n            }\n            catch(Exception e)\n            {\n                message = e.Message.ToString();\n                return Autodesk.Revit.UI.Result.Cancelled;\n            }\n            finally\n            {\n                transaction.Commit();\n            }\n            return Autodesk.Revit.UI.Result.Succeeded;\n        } \n    }\n}"
    },
    "documentation": {
      "ReadMe_NewRebar.rtf": "Summary: This sample will demonstrate how to create rebar via NewRebar (RebarShape rebarShape, RebarBarType rebarType, Element host, XYZ origin, XYZ xVec, XYZ yVec) and how to customize RebarShape (include straight segment and arc shape).\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.Creation.Document\nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.Structure.Rebar\nAutodesk.Revit.DB.Structure.RebarShape\nAutodesk.Revit.DB.Structure.RebarShapeDefinition\nAutodesk.Revit.DB.Structure.RebarShapeDefinitionByArc\nAutodesk.Revit.DB.Structure.RebarShapeDefinitionBySegments\nAutodesk.Revit.DB.Structure.StructuralType\nAutodesk.Revit.DB.Parameter\nAutodesk.Revit.DB.DefinitionGroup\nAutodesk.Revit.DB.ExternalDefinition\nAutodesk.Revit.DB.Solid\n\nProject Files: \nCommand.cs\nThis is the entrance of this sample. It implements IExternalCommand Execute method.\n\nRebarCreator.cs\nClass RebarCreator is defined in this file and it wraps the creation of Rebar. Its \"Execute\" method shows the main dialog for user and after that a Rebar will be created if user click OK button on the main dialog.\n\nRebarShapeDef.cs\nClass RebarShapeDef is defined in this file and it wraps RebarShapeDefinition object. It will be inherited by two classes: RebarShapeDefByArc and RebarShapeDefBySegment.\n\nRebarShapeDefByArc.cs\nClass RebarShapeDefByArc is defined in this file and it wraps RebarShapeDefinitionByArc object.\n\nRebarShapeDefBySegment.cs\nClass RebarShapeDefBySegment is defined in this file and it wraps RebarShapeDefinitionBySegments object.\n\nRebarShapeParameter.cs\nClass RebarShapeParameter is defined in this file and it wraps an Autodesk.Revit.Parameter object which will be added to RebarShape definition. This is an abstract class and it will be inherited by two classes: RebarShapeParameterDouble and RebarShapeParameterFormula.\n\nRebarShapeParameterDouble.cs\nClass RebarShapeParameterDouble is defined in this file and it wraps a double parameter which will be added to RebarShape definition.\n\nRebarShapeParameterFormula.cs\nClass RebarShapeParameterFormula is defined in this file and it wraps a formula parameter which will be added to RebarShape definition.\n\nConstraintOnRebarShape.cs\nClass ConstraintOnRebarShape is defined in this file and it wraps a constraint on Rebar Shape. It will be inherited by two classes: ConstraintOnSegmentShape and ConstraintOnArcShape.\n\nConstraintOnSegmentShape.cs\nThis file defines a series of classes which inherits from ConstraintOnSegmentShape. Each one can add a constraint to RebarShapeDefinitionBySegments.\n\nConstraintOnArcShape.cs\nThis file defines a series of classes which inherits from ConstraintOnArcShape. Each one can add a constraint to RebarShapeDefinitionByArc.\n\nGeometrySupport.cs\nClass GeometrySupport is defined in this file and it can be used to compute and store geometry information.\n\nGeomUtil.cs\nClass GeomUtil is defined in this file and it provides the basic geometry operations.\n\nNewRebarForm.cs\nThis form is the main entrance for user to operate the Rebar creation.\n\nNewRebarShapeForm.cs\nThis form is provided for user to define a new RebarShape.\n\nAddParameterForm.cs\nThis form provides an entrance for user to add parameters to RebarShape.\n\nAddConstraintForm.cs\nThis form provides an entrance for user to add constraints to RebarShape.\n\nDescription: This sample will demonstrate how to create rebar via NewRebar (RebarShape rebarShape, RebarBarType rebarType, Element host, XYZ origin, XYZ xVec, XYZ yVec) and how to customize RebarShape (include straight segment and arc shape). This sample will cover methods ScaleToBox and SetLayoutRuleWithoutExaminingHost of Rebar and almost all methods and properties of RebarShape. \n\nInstructions: \n1.\tHow to create a rebar?\n1)\tOpen or new a Revit project and make sure some concrete Beams or Columns without any rebar and with a rectangular shape are placed. A sample project file NewRebar.rvt is available in the sample’s folder.\n2)\tSelect a concrete Beam or Column without any rebar and with a rectangular shape.\n3)\tInvoke this command and the main dialog will be shown.\n4)\tIn the main dialog, select a RebarShape and a RebarBarType from the ComboBox, then click OK button, a rebar will be created on the selected Beam or Column.\n2.\tHow to customize a rebar shape by segments?\n1)\tIn the main dialog, give a rebar shape name and click radio Button by segments and input the segments number in the Text Box, then click “Create Rebar Shape” button, a form named “Create RebarShape” will be shown.\n2)\tIn the “Create RebarShape” form, parameters and constraints can be added to customize the rebar shape. Click button “Add parameter” will present a dialog to add parameter and click button “Add Constraint” will present a dialog to add constraint. After that, the parameter or the constraint will be displayed in the property grid, the parameter value and the constraints value can be changed from the property grid.\n3)\tAs for how to add parameters and constraints, here are some advice: \na)\tEach edge must have a length constraint and a direction constraint.\nb)\tEach vertex must have a bend constraint.\nc)\tListening constraints are not necessary.\n\n4)\tAfter parameters and constraints are added, click OK button to submit the customize rebar shape.\n \n3.\tHow to customize a rebar shape by arc?\n1)\tIn the main dialog, give a rebar shape name and click radio Button by arc and select the arc type from the ComboBox, then click “Create rebar shape” button, a form named “Create RebarShape” will be shown.\n2)\tIn the “Create RebarShape” form, parameters and constraints can be added to customize the rebar shape. Click button “Add Parameter” will present a dialog to add parameter and click button “Add Constraint” will present a dialog to add constraint. After that, the parameter or the constraint will be displayed in the property grid, the parameter value and the constraints value can be changed from the property grid.\n3)\tAfter parameters and constraints are added, click OK button to submit the customize rebar shape.\n\nCustomize Rebar Shapes Step by step:\nUnder folder “Customize RebarShapes Step by step”, there are four help doc to help user customize Rebar Shapes step by step. \n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\NewRoof\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n                                               ref string message,\n                                               ElementSet elements)\n        {\n            try\n            {\n                m_activeView = commandData.Application.ActiveUIDocument.Document.ActiveView;\n\n                //// Create a new instance of class DataManager\n                RoofsManager.CS.RoofsManager roofsManager = new RoofsManager.CS.RoofsManager(commandData);\n                LevelConverter.SetStandardValues(roofsManager.Levels);\n\n                // Create a form to create and edit a roof.\n                DialogResult result = System.Windows.Forms.DialogResult.None;\n                while (result == DialogResult.None || result == DialogResult.Retry)\n                {\n                    if (result == DialogResult.Retry)\n                    {\n                        roofsManager.WindowSelect();\n                    }\n                    \n                    using (RoofForms.CS.RoofForm mainForm = new RoofForms.CS.RoofForm(roofsManager))\n                    {\n                        result = mainForm.ShowDialog();\n                    }\n                }\n\n                if (result == System.Windows.Forms.DialogResult.OK)\n                {\n                    return Autodesk.Revit.UI.Result.Succeeded;\n                }\n                else\n                {\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n            }\n            catch (Exception ex)\n            {\n                // If there are something wrong, give error information and return failed\n                message = ex.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_NewRoof.rtf": "Summary: This sample demonstrates four main features:\n1.\tHow to create a new footprint roof.\n2.\tHow to create an extrusion roof.\n3.\tHow to edit an existed footprint roof.\n4.\tHow to edit an existed extrusion roof.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.FootPrintRoof\nAutodesk.Revit.DB.ExtrusionRoof\nAutodesk.Revit.DB.Level\nAutodesk.Revit.DB.RoofType\nAutodesk.Revit.DB.Wall\nAutodesk.Revit.DB.Curve\nAutodesk.Revit.Creation.Document\n\n\nProject Files: \nCommand.cs\nThis file contains the class “Command” which inherits from “IExternalCommand” interface and implements the “Execute” method.\n\nRoofsManager.cs\nIt contains a class named “RoofsManager” which is used to manage the operation between Revit and the Add-In UI. It have the functionalities to create footprint roof, create extrusion roof, select footprint to create footprint roof and select profile to create extrusion roof in Revit.\n\nFootPrintRoofManager.cs\nIt contains a class named “FootPrintRoofManager” which is used to manage the creation of footprint roof.\n\nExtrusionRoofManager.cs\nIt contains a class named “ExtrusionRoofManager” which is used to manage creation of extrusion roof.\n\nRoofForm.cs\nIt contains a class named “RoofForm” which is the main UI of the Add-In application. \n\nRoofEditorForm.cs\nIt contains a class named “RoofEditorForm” which is the edit UI to edit a selected roof in the RoofForm. It contains a PropertyGrid to allow user modify the properties or parameters of the selected roof.\n\nGraphicsControl.cs\nIt contains a class named “GraphicsControl” which is used to display the footprint roof lines in a picture box control when the user is editing a footprint roof. The modifying footprint roof line will be highlighted in the control.\n\nCustomTypeConverter.cs\nIt contains a LevelConverter class and a FootPrintRoofLineConverter class. They are used to custom the display of the some properties in the PropertyGrid control.\n\nFootPrintRoofWrapper.cs\nIt contains a FootPrintRoofWrapper class and a FootPrintRoofLine class. The FootPrintRoofWrapper class is used to wrapper a footprint roof to edit the roof in a PropertyGrid control. The FootPrintRoofLine is used to edit the footprint roof line in a PropertyGrid and the line can be drawn in GDI.\n\nExtrusionRoofWrapper.cs\nIt contains a class named “ExtrusionRoofWrapper” which is used to wrapper an extrusion roof to edit the roof in a PropertyGrid control.\n\nDescription: Functionalities:\n-\tGet all footprint roofs and extrusion roofs in active document and list them grouped by the creation way.\n-\tCreate a footprint roof with default properties by specifying a curve loop, or a wall loop, or loops combination of walls and curves, a level and a roof type.\n-\tCreate an extruded roof by providing a profile which is a series of connected lines or arcs, not closed in a loop, a roof type, a reference plane, an extrusion start value and an extrusion end value. Note that the reference plane should be a vertical plane.\n-\tSelect a footprint roof in the list, then user can define a footprint roof line is slope-defining and can change the slope angel of the selected roof, Also other properties of roof line can be changed respectively, such as overhang, offset from base, extend into wall. The roof’s type can be changed just select a different type.\n-\tSelect an extrusion roof in the list, and then user can change the value of extrusion start, extrusion end, and the roof type and the reference level of the extrusion roof.\n\nImplementations:\n-\tUsing Element Filter to get all kinds roofs.\n-\tCreate footprint roof by the FootPrintRoof NewFootPrintRoof(CurveArray footPrint, Level level, RoofType roofType, ElementIdSet footPrintToModelCurvesMapping) method. The footprint can be specified by WindowsSelect() method of Selection class. The roof types can be obtained by the Autodesk.Revit.DB.Document.RoofTypes property.\n-\tCreate extrusion roof by the ExtrusionRoof NewExtrusionRoof(CurveArray profile, ReferencePlane refPlane, Level level, RoofType roofType, double extrusionStart, double extrusionEnd) method. The profile can be specified by WindowsSelect method and the reference plane should be vertical and can be obtained by using Element filtering functionality\n-\tEdit the footprint roof or extrusion roof by accessing the properties or parameters of the selected roof.\n\nInstructions: \n1.\tOpen a Revit Architecture 2009 file. A sample project file NewRoof.rvt is available in the sample’s folder.\n2.\tDraw a curve loop or a wall loop or loops combination of walls and curves to create a footprint roof in Revit. \n3.\tRun this command.\n4.\tA dialog will be shown to display all the existed roofs. The footprint roofs will be listed in the footprint roof tab page and the extrusion roofs will be listed in the extrusion tab page.\n5.\tIn the footprint roof tab page, click “Select footprint in Revit” button to select the footprint you just created. Select a base level and roof type then click the “Create” button; a footprint roof will be created in Revit and will be listed in the footprint roof tab page. Click “OK” button to accept the creation or click the “Cancel” button to abort.\n6.\tDraw a series of connected lines or arcs, not closed in a loop to create a profile in Revit. Draw a reference plane in Revit for extrude the profile to create an extrusion roof. Make sure the reference plan is vertical or the extrusion roof will be not creating successfully. If there are many reference planes in Revit, you’d better create a good name for each plane to distinguish them.\n7.\tIn the extrusion roof tab page, click “Select profile in Revit” button to select the profile you just created. Select a reference plane, reference level, roof type and specify the extrusion start and extrusion end value, and then click the “Create” button; an extrusion roof will be created in Revit and will be listed in the extrusion roof tab page. For more information of extrusion start and extrusion end, you’d better refer the extrusion roof part of the help document supplied by Revit. Click “OK” button to accept the creation or click the “Cancel” button to abort.\n8.\tEdit a footprint roof. You can select a footprint roof and click the “Edit” button or you just double click the roof in the in the footprint roof tab page; a roof editor form will be displayed. The properties of the roof you can edit in the PropertyGird. The footprint roof lines will be displayed also; the current selected roof line in PropertyGird will be highlighted in red color. You can modify the roof type in the roof type combo box. After the finish the modification you can click the “OK” button to accept the change or click the “Cancel” button to abort.\n9.\tEdit an extrusion roof. You can select an extrusion roof and click the “Edit” button or you just double click the roof in the in the extrusion roof tab page; a roof editor form will be displayed. You can edit the parameters of the extrusion roof in the PropertyGird. After the finish the modification you can click the “OK” button to accept the change or click the “Cancel” button to abort.\n\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Openings\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, \n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"External Tool\");\n            try\n            {\n                transaction.Start();\n                Application app = commandData.Application.Application;\n                bool haveOpening = false;\n\n                //search Opening in Revit\n                List<OpeningInfo> openingInfos = new List<OpeningInfo>();\n                FilteredElementIterator iter = (new FilteredElementCollector(commandData.Application.ActiveUIDocument.Document)).OfClass(typeof(Opening)).GetElementIterator();\n                iter.Reset();\n                while (iter.MoveNext())\n                {\n                    Object obj = iter.Current;\n                    if (obj is Opening)\n                    {\n                        haveOpening = true;\n                        Opening opening = obj as Opening;\n                        OpeningInfo openingInfo = new OpeningInfo(opening, commandData.Application);\n                        openingInfos.Add(openingInfo);\n                    }\n                }\n\n                if (!haveOpening)\n                {\n                    message = \"don't have opening in the project\";\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n\n                //show dialogue\n                using (OpeningForm openingForm = new OpeningForm(openingInfos))\n                {\n                    openingForm.ShowDialog();\n                }\n            }\n            catch (Exception e)\n            {\n                message = e.ToString();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            finally\n            {\n                transaction.Commit();\n            }\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_Openings.rtf": "Summary: Shows how to get geometry profile and properties of an opening and how to add x model lines to opening bounding box.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Opening\nAutodesk.Revit.DB.Document\n\nProject Files: \nCommand.cs\nThis file defines a Command class which inherits from IExternalCommand. The class implements the Execute method. The main functionality of the class is to get all openings in the project and gain information from it.\n\nOpeningInfo.cs\nThis file defines an OpeningInfo class to store information of openings in active document.\n\nOpeningProperty.cs\nThis file defines an OpeningProperty class which contains the properties. And the properties will be displayed in PropertyGrid of Form.\n\nOpeningForm.cs\nThis file defines an OpeningForm class which consists of a PictureBox and a PropertyGrid controls. The picture box displays the profile of the selected opening and the PropertyGrid control shows the properties of the selected opening.\n\nCreateModelLineOptionsForm.cs\nThis file defines a CreateModelLineOptionsForm class which inherits from Form. The functionality of this class is creating ModelLine for opening bounding box.\n\nDescription: This sample retrieves all openings in active document and displays the profile and properties of the selected opening. The openings can be retrieved by iterating the document’s elements. And then the profile will be shown in a PictureBox control and the properties will be shown in a PropertyGrid control. The ModelLine can be created by NewModelCurve method of Document.\n\nInstructions: \n1.\tOpen or new a Revit project and make sure some Openings are placed. A sample project file Openings.rvt is available in the sample’s folder.\n2.\tRun the command, a form will pop up.\n3.\tTo review the profile and properties of one Opening, select it from the ComboBox control.\n4.\tClick “Add X Model Line” button to add x model lines for opening bounding box. \n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\ParameterUtils\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message,\n            ElementSet elements)\n        {\n            // set out default result to failure.\n            Autodesk.Revit.UI.Result retRes = Autodesk.Revit.UI.Result.Failed;\n\n            Autodesk.Revit.UI.UIApplication app = commandData.Application;\n\n            // get the elements selected\n            // The current selection can be retrieved from the active \n            // document via the selection object\n            ElementSet seletion = new ElementSet();\n            foreach (ElementId elementId in app.ActiveUIDocument.Selection.GetElementIds())\n            {\n               seletion.Insert(app.ActiveUIDocument.Document.GetElement(elementId));\n            }\n\n            // we need to make sure that only one element is selected.\n            if (seletion.Size == 1)\n            {\n                // we need to get the first and only element in the selection. Do this by getting \n                // an iterator. MoveNext and then get the current element.\n                ElementSetIterator it = seletion.ForwardIterator();\n                it.MoveNext();\n                Element element = it.Current as Element;\n\n                // Next we need to iterate through the parameters of the element,\n                // as we iterating, we will store the strings that are to be displayed\n                // for the parameters in a string list \"parameterItems\"\n                List<string> parameterItems = new List<string>();\n                ParameterSet parameters = element.Parameters;\n                foreach (Parameter param in parameters)\n                {\n                    if (param == null) continue;\n\n                    // We will make a string that has the following format,\n                    // name type value\n                    // create a StringBuilder object to store the string of one parameter\n                    // using the character '\\t' to delimit parameter name, type and value \n                    StringBuilder sb = new StringBuilder();\n\n                    // the name of the parameter can be found from its definition.\n                    sb.AppendFormat(\"{0}\\t\", param.Definition.Name);\n\n                    // Revit parameters can be one of 5 different internal storage types:\n                    // double, int, string, Autodesk.Revit.DB.ElementId and None. \n                    // if it is double then use AsDouble to get the double value\n                    // then int AsInteger, string AsString, None AsStringValue.\n                    // Switch based on the storage type\n                    switch (param.StorageType)\n                    {\n                        case Autodesk.Revit.DB.StorageType.Double:\n                            // append the type and value\n                            sb.AppendFormat(\"double\\t{0}\", param.AsDouble());\n                            break;\n                        case Autodesk.Revit.DB.StorageType.ElementId:\n                            // for element ids, we will try and retrieve the element from the \n                            // document if it can be found we will display its name.\n                            sb.Append(\"Element\\t\");\n\n                            // using ActiveDocument.GetElement(the element id) to \n                            // retrieve the element from the active document\n                            Autodesk.Revit.DB.ElementId elemId = param.AsElementId();\n                            Element elem = app.ActiveUIDocument.Document.GetElement(elemId);\n\n                            // if there is an element then display its name, \n                            // otherwise display the fact that it is not set\n                            sb.Append(elem != null ? elem.Name : \"Not set\");\n                            break;\n                        case Autodesk.Revit.DB.StorageType.Integer:\n                            // append the type and value\n                            sb.AppendFormat(\"int\\t{0}\", param.AsInteger());\n                            break;\n                        case Autodesk.Revit.DB.StorageType.String:\n                            // append the type and value\n                            sb.AppendFormat(\"string\\t{0}\", param.AsString());\n                            break;\n                        case Autodesk.Revit.DB.StorageType.None:\n                            // append the type and value\n                            sb.AppendFormat(\"none\\t{0}\", param.AsValueString());\n                            break;\n                        default:\n                            break;\n                    }\n\n                    // add the completed line to the string list\n                    parameterItems.Add(sb.ToString());\n                }\n\n                // Create our dialog, passing it the parameters array for display.\n                PropertiesForm propertiesForm = new PropertiesForm(parameterItems.ToArray());\n                propertiesForm.StartPosition = FormStartPosition.CenterParent;\n                propertiesForm.ShowDialog();\n                retRes = Autodesk.Revit.UI.Result.Succeeded;\n            }\n            else\n            {\n                message = \"Please select only one element\";\n            }\n            return retRes;\n        }\n\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_ParameterUtils.rtf": "Summary: This sample demonstrates how to get the parameters of a Revit element.\n\nClasses: \nAutodesk.Revit.DB.Element \nAutodesk.Revit.DB.Parameter\nAutodesk.Revit.DB.Document\n\nProject Files: \nCommand.cs\nThis file contains the class Command which inherits from IExternalCommand. The function of it is to retrieve all the parameters which a selected element has, and then show them in a list view of a form.\n\nPropertiesForm.cs\nThis file contains a Form class which consists of ok, cancel buttons and a list view which lists the information of parameters of the selected element.\n\nDescription: -\tTo get the collection of selected elements, use Document.Selection.Elements.\n-\tTo get the collection of parameters that the element has, use Element.Parameters.\n-\tUse Parameter.StorageType to get the parameter storage type and with the corresponding function (such as AsDouble() if the storage type is double) to get the value of it.\n-\tTo retrieve the element with its id, use Document.get_Element(ElementId id).\n-\tTo get the name of element, use Element.Name.\n-\tListView is used to show the string array in which each string stands for single parameter information.\n\nInstructions: \n1.\tSelect only one element, such as a wall or floor and so on. (Note: if none or more than one element is selected, command will return failed and give an error message).\n2.\tRun the command.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\PathReinforcement\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"External Tool\");\n            try\n            {\n                transaction.Start();\n                ElementSet elems = new ElementSet();\n                foreach (ElementId elementId in commandData.Application.ActiveUIDocument.Selection.GetElementIds())\n                {\n                   elems.Insert(commandData.Application.ActiveUIDocument.Document.GetElement(elementId));\n                }\n                #region selection error handle\n                //if user have some wrong selection, give user an Error message\n                if (1 != elems.Size)\n                {\n                    message = \"please select one PathReinforcement.\";\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n\n                Autodesk.Revit.DB.Element selectElem = null;\n                foreach (Autodesk.Revit.DB.Element e in elems)\n                {\n                    selectElem = e;\n                }\n\n                if (!(selectElem is Autodesk.Revit.DB.Structure.PathReinforcement))\n                {\n                    message = \"please select one PathReinforcement.\";\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n                #endregion\n\n                //clear all rebar bar type.\n                if (s_rebarBarTypes.Count > 0)\n                {\n                    s_rebarBarTypes.Clear();\n                }\n\n                //get all bar type.\n                FilteredElementCollector collector = new FilteredElementCollector(commandData.Application.ActiveUIDocument.Document);\n                FilteredElementIterator itor = collector.OfClass(typeof(RebarBarType)).GetElementIterator();\n                itor.Reset();\n                while (itor.MoveNext())\n                {\n                    RebarBarType bartype = itor.Current as RebarBarType;\n                    if (null != bartype)\n                    {\n                        Autodesk.Revit.DB.ElementId id = bartype.Id;\n                        String name = bartype.Name;\n                        s_rebarBarTypes.Add(name, id);\n                    }\n                }\n\n                //Create a form to view the path reinforcement.\n                Autodesk.Revit.DB.Structure.PathReinforcement pathRein = selectElem as\n                                       Autodesk.Revit.DB.Structure.PathReinforcement;\n                using (PathReinforcementForm form = new PathReinforcementForm(pathRein, commandData))\n                {\n                    form.ShowDialog();\n                }\n            }\n            catch (Exception e)\n            {\n                transaction.RollBack();\n                message = e.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            finally\n            {\n                transaction.Commit();\n            }\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_PathReinforcement.rtf": "Summary: This sample demonstrates how to retrieve curves, profile and properties of path reinforcement object.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.DB.Structure.PathReinforcement\nAutodesk.Revit.DB.Structure.RebarBarType\nAutodesk.Revit.DB.ModelCurve\n\nProject Files: \nCommand.cs\nThis file defines a Command class which inherits from IExternalCommand and implements the Execute method. The main function of the class is to show the main dialog.\n\nPathReinforcementForm.cs\nThis file defines a PathReinforcementForm class which inherits from Form. The class is the main dialog which contains a picture box and a property grid. The picture box is used to display the curves of the path reinforcement and the property grid is used to display the properties of the path Reinforcement.\n\t\nProfile.cs\nThis file defines a Profile class to store geometry information of path reinforcement. The class contains a public method “Draw” to draw the curves and profile of the path reinforcement.\n\nPathReinProperties.cs\nThis file defines a PathReinProperties class which contains the path reinforcement properties. And the properties will be displayed in property grid of PathReinforcementForm.\n\nBarTypeConverter.cs\nThis file defines a BarTypeConverter class used to convert types between ElementId and String.\n\nMathTools.cs\nThis file defines a Vector4 and a Matrix4 class used to transform geometry data between 2D and 3D.\n\nDescription: This sample will get path reinforcement from active document and display its properties in a dialog. Curves of path reinforcement will be displayed in picture box and other data be displayed in property grid. The geometry data can be got by “Curves” property of path reinforcement and other properties can be got by “get_Parameter” and “Parameters” methods.\n\nInstructions: \n1.\tOpen or new a Revit project and make sure some PathReinforcemanes are placed. A sample project file PathReinforcement.rvt is available in the sample’s folder.\n2.\tSelect one PathReinforcement, Run the command, a form will pop up.\n3.\tThe path and the profile of the selected path reinforcement will be displayed in picture box: path in blue color, profile in red color.  \n4.\tThe properties of path reinforcement will be displayed in properties grid; user can change some parameters of the path reinforcement via this property grid.\n5.\tThe changed parameters of path will be updated when clicking Ok button.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\PlaceFamilyInstanceByFace\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n                                               ref string message,\n                                               ElementSet elements)\n        {\n            // Quit if active document is null\n            if (null == commandData.Application.ActiveUIDocument.Document)\n            {\n                message = \"Active document is null.\";\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            try\n            {\n                FamilyInstanceCreator creator = new FamilyInstanceCreator(commandData.Application);\n\n                // an option dialog for user choosing based type of creating\n                BasedTypeForm baseTypeform = new BasedTypeForm();\n                if (DialogResult.OK == baseTypeform.ShowDialog())\n                {\n                    PlaceFamilyInstanceForm placeForm = new PlaceFamilyInstanceForm(creator\n                        , baseTypeform.BaseType);\n                    placeForm.ShowDialog();\n                }\n\n                // if everything goes well, return succeeded.\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception ex)\n            {\n                // If any error, give error information and return failed\n                message = ex.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_PlaceFamilyInstanceByFace.rtf": "Summary: This sample demonstrates how to create family instance on face.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.FamilySymbol \nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.Face\nAutodesk.Revit.DB.Options\nAutodesk.Revit.DB.Solid\n\nProject Files: \nCommand.cs\nThis file contains the class Command which inherits from IExternalCommand interface and implements the Execute method.\n\nFamilyInstanceCreator.cs\nThis is main data class for creating family Instance by face. It contains all operations in Revit.\n\nPointUserControl.cs\nThis class defines a user control for specifying point data which contains three text boxes for X, Y and Z coordinates of a point.\n \nBasedType.cs\nThis class contains a dialog which provides two options for user to choose the type to create the family instance. It provides two types - Point-based and Line-based. \n\nPlaceFamilyInstanceForm.cs\nThis file contains a dialog which provides options to specify positions and face on which the family instance will be placed.\n\nDescription: This sample will demonstrate how to create family instance on face.\n\nInstructions: \n1.\tDraw some elements with face geometry in current document.\n2.\tSelect an element and execute the command.\n3.\tChoose a type in the “Based Type” dialog and click “Next” button. \n4.\tSpecify the face, family symbol and positions information. \n5.\tClick “Create” button to create a family instance.\n\nNotes: \n1.\tPrepare your Revit project. \nOpen or new a Revit project and make sure there are some face-based and point-based family symbols in the project. A sample project file PlaceFamilyInstanceByFace.rvt is available in the sample’s folder.\n2.\tCurrently in API there is no good way to check whether a family symbol is face-based and point-based/line based. User must know clear about the family symbol selected to create a family instance. The sample will skip validating that and just provide message if creation fails. \n3.\tThe default family symbol is the one provided in this sample.    (Line: “Line-based”; Point: “Point-based”)\n4.\tThe default value of start point is the minimum point of this selected face. The default value of end point is the maximum point of this selected face. \n5.\tThe default value of location point is the center point in bounding box of the selected face\n6.\tPlease copy the rfa files to the Revit installation folder or load them into current document if you use the DLL of this sample directly in Revit. Nothing to do when you debug this project."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\PowerCircuit\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n        ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            try\n            {\n                // Quit if active document is null\n                if (null == commandData.Application.ActiveUIDocument.Document)\n                {\n                    message = Properties.Resources.ResourceManager.GetString(\"NullActiveDocument\");\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                // Quit if no elements selected\n                if (commandData.Application.ActiveUIDocument.Selection.GetElementIds().Count == 0)\n                {\n                    message = Properties.Resources.ResourceManager.GetString(\"SelectPowerElements\");\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                // Collect information from selected elements and show operation dialog\n                CircuitOperationData optionData = new CircuitOperationData(commandData);\n                using (CircuitOperationForm mainForm = new CircuitOperationForm(optionData))\n                {\n                    if (mainForm.ShowDialog() == DialogResult.Cancel)\n                    {\n                        return Autodesk.Revit.UI.Result.Cancelled;\n                    }\n                }\n\n                // Show the dialog for user to select a circuit if more than one circuit available\n                if (optionData.Operation != Operation.CreateCircuit && \n                    optionData.ElectricalSystemCount > 1)\n                {\n                    using (SelectCircuitForm selectForm = new SelectCircuitForm(optionData))\n                    {\n                        if (selectForm.ShowDialog() == DialogResult.Cancel)\n                        {\n                            return Autodesk.Revit.UI.Result.Cancelled;\n                        }\n                    }\n                }\n\n                // If user choose to edit circuit, display the circuit editing dialog\n                if (optionData.Operation == Operation.EditCircuit)\n                {\n                    using (EditCircuitForm editForm = new EditCircuitForm(optionData))\n                    {\n                        if (editForm.ShowDialog() == DialogResult.Cancel)\n                        {\n                            return Autodesk.Revit.UI.Result.Cancelled;\n                        }\n                    }\n                }\n\n                // Perform the operation\n                optionData.Operate();\n            }\n            catch (Exception ex)\n            {\n                message = ex.ToString();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_PowerCircuit.rtf": "Summary: This sample shows how to operate power circuits.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB\n\nProject Files: \nCommand.cs\nIt contains the class Command which inherits from interface IExternalCommand and implements the Execute method.\n\nCircuitOperationData.cs\nData class which stores the information for operating circuits.\n\nCircuitOperationForm.cs\nIt contains a dialog which provides the options of operating circuits.\n\nElectricalSystemItem.cs\nThe class is used for displaying electrical systems in circuit selecting dialog. An electrical system item contains the name and id of an electrical system.\n\nEditCircuitForm.cs\nIt contains a dialog which provides the options of editing circuits.\n\nSelectCircuitForm.cs\nIt contains a dialog which let user select a circuit to operate.\n\nEnum.cs\nThis file contains two Enumerations.\n-\tOperation enumeration lists the options to operate circuits.\n-\tEditOption enumeration lists the options to edit a circuit.\n\nDescription: This sample provides following functionalities.\n-\tLet user create a power circuit with selected elements. The elements should have unused electrical connectors within same voltage definition and with same pole numbers.\n-\tLet user edit a power circuit.\n-\tLet user add an element to a circuit. The element should have unused electrical connectors within same voltage definition and with same pole numbers as the circuit elements. \n-\tLet user remove an element from the circuit.\n-\tLet user select a panel for a circuit. \n-\tLet user disconnect panel from a circuit if the circuit has a panel。\n\nInstructions: \nOpen or new a Revit project and make sure needed electrical elements are placed. A sample project file PowerCircuit.rvt is available in the sample’s folder. Then execute the command.\n1.\tCreate a power circuit\na.   Select elements which all have unused electrical connectors within same voltage definition and with same pole numbers in current project.\nb.   Execute the command.\nc.   Click the  button.\nExpected result: A power circuit is created with the selected elements and highlighted. \nNote: 1. Currently in API there is no good way to check whether the connectors have the same voltage definition or pole numbers, therefore the sample skips validating this information and just provides message if creation fails. User must know clear whether the voltage and pole numbers of connectors of selected elements match with each other. 2. In this sample it is not allowed to create a power circuit with elements which are all lighting devices.\n\n2.\tEdit a power circuit.\na.\tSelect a power circuit or an element belongs to one or more circuits.\nb.\tExecute the command.\nc.\tClick the  button.\nd.\tIf the selected element belongs to more than one power circuits, select a circuit from its circuits to edit in the “Select a Circuit” dialog. If not, go to next step.\ne.\tChoose an option to edit the circuit in the “Edit Circuit” dialog.\n-\tClick  button to add an element to the circuit. Then select an element which has unused electrical connectors within same voltage definition and with same pole numbers as the other circuit elements. For the same reason as Note in step 1, the sample just skips validating the voltage and pole numbers and provides message if creation fails.\nExpected result: The selected element is added to the circuit and the circuit is highlighted.\n-\tClick  button to remove an element from the circuit. Then select the element to remove.\nExpected result: The selected element is removed from the circuit and the circuit is highlighted. \n-\tClick  button to select a panel for the circuit. The same as step 3.\n\n3.\tSelect a panel for a circuit.\na.\tSelect a power circuit or an element belongs to one or more circuits. \nb.\tExecute the command.\nc.\tClick  button to select a panel for the circuit.\nd.\tIf the selected element belongs to more than one power circuits, select a circuit from its circuits to edit in the “Select a Circuit” dialog. If not, go to next step.\ne.\tSelect a panel to assign it to the circuit. The panel must be assigned to distribution system with the same voltage definition as the other circuit elements.  Also the panel must have same pole numbers as the other circuit elements. For the same reason as Note in step 1, the sample just skips validating the voltage and pole numbers and provides message if creation fails. \nExpected result: The selected panel is assigned to the circuit and the circuit is highlighted.\n \n4.\tDisconnect the panel from a circuit.\na.\tSelect a power circuit or an element belongs to one or more circuits. \nb.\tExecute the command.\nc.\tClick  button to disconnect the panel from the circuit.\nd.\tIf the selected element belongs to more than one power circuits, select a circuit from its circuits to edit in the “Select a Circuit” dialog. If not, go to next step.\nExpected result: The panel of the circuit is removed from the circuit and the circuit is highlighted."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\RebarContainerAnyShapeType\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"External Tool\");\n            try\n            {\n                transaction.Start();\n                // create a factory to create the corresponding FrameReinMaker\n                FrameReinMakerFactory factory = new FrameReinMakerFactory(commandData);\n\n                // Do some data checks, such whether the user select concrete beam or column\n                if (!factory.AssertData())\n                {\n                    message = \"Please select a concrete beam or column without reinforcement.\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                // Invoke work() method to create corresponding FrameReinMaker,\n                // and create the reinforcement rebars\n                factory.work();\n\n                // if everything goes well, return succeeded.\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception ex)\n            {\n                message = ex.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            finally\n            {\n                transaction.Commit();\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_RebarContainerAnyShapeType.rtf": "Summary: Show how to create a Rebar Container in a concrete element (Beam or Column) which does not currently host reinforcement.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.Creation.Document\nAutodesk.Revit.DB.Structure.Rebar\nAutodesk.Revit.DB.Structure.StructuralType\n\nProject Files: \nCommand.cs\nDefines the class Command which inherits from IExternalCommand interface and implements the Execute method. The function of Execute is to display a model dialog to create Rebar Container for the selected element.\n\nFramReinMaker.cs\nDefines the FramReinMaker class which is derived by BeamFramReinMaker and ColumnFramReinMaker. The function of these classes is to create a Rebar Container for the selected host elements. If the selected element is a Beam, the maker is BeamFramReinMaker. If the selected element is a Column, the maker is ColumnFramReinMaker.\n\nBeamFramReinMaker.cs\nDefines the BeamFramReinMaker class which inherits from FramReinMaker. It is used to create a Rebar Container for Beams.\n\nColumnFramReinMaker.cs\nDefines the ColumnFramReinMaker class which inherits from FramReinMaker. It is used to create a Rebar Container for a Column.\n\nBeamFramReinMakerForm.cs\nDefines the BeamFramReinMakerForm class which inherits from Form. The function of this class is to prepare parameters for Beam creation.\n\nColumnFramReinMakerForm.cs\nDefines the ColumnFramReinMakerForm class which inherits from Form. The function of this class is to prepare parameters for Column creation.\n\nGeomData.cs\nDefines the BeamRebarData and ColumnRebarData classes. They store information for support beams and for column reinforcement creation.\n\nGeometrySupport.cs\nAs the base class, it supports the BeamGeometrySupport and ColumnGeometrySupport classes, and could store common geometry information. This class also gives some helper functions.\n\nBeamGeometrySupport.cs\nAs the geometry support class for the reinforcement creation for beams, it prepares the geometry information for top and bottom reinforcement bars, and transverse reinforcement bar creation.\n\nColumnGeometrySupport.cs\t\nAs the geometry support class for the reinforcement creation for columns, it prepares the geometry information for transverse and vertical reinforcement bar creation.\n\nGeomUtil.cs\nDefines the GeomUtil class which provides the base geometry operation. It is a static class.\n\nParameterUtil.cs\nDefines the ParameterUtil class which contains utility methods to find or set certain parameters. It is a static class.\n\nDescription: This sample uses method RebarContainer.Create to create a Rebar Container for the selected host. The RebarContainer,Create method requires the RebarContainerType parameter which is called by the RebarContainerType.CreateDefaultContainerType. \t\n\nInstructions: \n1.\tOpen an existing project or create a new Revit project containing concrete beams or columns without reinforcement. A sample project file RebarContainerAnyShapeType.rvt is available in the samples folder.\n2.\tSelect a concrete Beam or Column, Run the command.\n3.\tSet the parameters for the rebar in the pop up dialog.\n4.\tClick Ok, Rebar Container for the selected element (Beam or Column) will be created."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\ReferencePlane\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message,\n            ElementSet elements)\n        {\n            Transaction trans = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Revit.SDK.Samples.ReferencePlane\");\n            trans.Start();\n            try\n            {\n                // Generate an object of Revit reference plane management.\n                ReferencePlaneMgr refPlaneMgr = new ReferencePlaneMgr(commandData);\n\n                using (ReferencePlaneForm dlg = new ReferencePlaneForm(refPlaneMgr))\n                {\n                    if (dlg.ShowDialog() == System.Windows.Forms.DialogResult.OK)\n                    {\n                        // Done some actions, ask revit to execute it.\n                        trans.Commit();\n                        return Autodesk.Revit.UI.Result.Succeeded;\n                    }\n                    else\n                    {\n                        // Revit need to do nothing.\n                        trans.RollBack();\n                        return Autodesk.Revit.UI.Result.Cancelled;\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                // Exception raised, report it by revit error reporting mechanism. \n                message = e.ToString();\n                trans.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            \n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_ReferencePlane.rtf": "Summary: This sample shows how to create Reference Plane by Revit API.\n\nClasses: \n\tAutodesk.Revit.DB.Document\nAutodesk.Revit.DB.Floor\nAutodesk.Revit.DB.Wall\nAutodesk.Revit.DB.Options\nAutodesk.Revit.DB.Line\nAutodesk.Revit.DB.Solid\nAutodesk.Revit.DB.Mesh\nAutodesk.Revit.Creation.Document\n\nProject Files:\nCommand.cs\nThis file contains a class Command which inherits from IExternalCommand interface and implements the Execute method.\n\nReferencePlaneMgr.cs\nThis file contains a class ReferencePlaneMgr which consists of some methods about Reference Plane, such as create Reference Plane on wall (or floor), get the parameters of Reference Plane and get the coordinate from wall (or floor) used to create Reference Plane.\n\nReferencePlaneForm.cs\nThis file contains a class ReferencePlaneForm inherits from Form class; the form consists of a DataGridView used to display some parameters of all Reference Plane in project.\n\nGeomHelper.cs\nThis file contains a class GeomHelper which provides utility methods to get geometry data used to create Reference Plane on wall or floor, such as determine whether a face is vertical, find out the three points which makeup a plane and calculate the length between two points.\n\nDescription: This sample provides the following functionalities:\n-\tReport all reference planes in current project, show its ID, bubble end, free end and normal. \n-\tAllow user to create a reference plane:\n-\tIf user selected wall in Revit then create Reference Plane at the left face of the wall.\n-\tIf user selected floor in Revit then create Reference Plane at the bottom of the floor.\n\nInstructions: \n1.\tDraw some Reference Planes. (or open ReferencePlane.rvt)\n2.\tDraw a Slab or a Wall and Select it.\n3.\tRun this command.\n4.\tUser can see ID, bubble end, free end, and normal of all Reference Plane in a table.\n5.\tClick “Create” button to create a new Reference Plane.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Reinforcement\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                                ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Transaction transaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"External Tool\");\n            try\n            {\n                transaction.Start();\n                // create a factory to create the corresponding FrameReinMaker\n                FrameReinMakerFactory factory = new FrameReinMakerFactory(commandData);\n\n                // Do some data checks, such whether the user select concrete beam or column\n                if (!factory.AssertData())\n                {\n                    message = \"Please select a concrete beam or column without reinforcement.\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                // Invoke work() method to create corresponding FrameReinMaker,\n                // and create the reinforcement rebars\n                factory.work();\n\n                // if everything goes well, return succeeded.\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception ex)\n            {\n                message = ex.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            finally\n            {\n                transaction.Commit();\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_Reinforcement.rtf": "Summary: Show how to create Rebar in concrete element (Beam or Column) which does not have any reinforcement.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.Creation.Document\nAutodesk.Revit.DB.Structure.Rebar\nAutodesk.Revit.DB.Structure.StructuralType\n\nProject Files: \nCommand.cs\nThis file defines the class Command which inherits from IExternalCommand interface and implements the Execute method. The function of Execute method is to display a model dialog to create Rebar for the selected element.\n\nFramReinMaker.cs\nThis file defines FramReinMaker class which is derived by BeamFramReinMaker and ColumnFramReinMaker. The function of these classes is to create Rebar for the selected host elements. If the selected element is a Beam, the maker is BeamFramReinMaker. If the selected element is a Column, the maker is ColumnFramReinMaker.\n\nBeamFramReinMaker.cs\nThis file defines BeamFramReinMaker class which inherits from FramReinMaker. it is used to create Rebar for Beam.\n\nColumnFramReinMaker.cs\nThis file defines ColumnFramReinMaker class which inherits from FramReinMaker. It is used to create Rebar for Column.\n\nBeamFramReinMakerForm.cs\nThis file defines BeamFramReinMakerForm class which inherits from Form. The function of this class is to prepare parameters for Beam creation.\n\nColumnFramReinMakerForm.cs\nThis file defines ColumnFramReinMakerForm class which inherits from Form. The function of this class is to prepare parameters for Column creation.\n\nGeomData.cs\nThis file defines classes BeamRebarData and ColumnRebarData. They could store information support beam and column reinforcement creation.\n\nGeometrySupport.cs\nAs The base class, it could support BeamGeometrySupport and ColumnGeometrySupport.and the class also could store some common geometry information. And give some helper functions.\n\nBeamGeometrySupport.cs\nAs the geometry support for reinforcement creation on beam, it could prepare the geometry information for top rebar, bottom and transverse rebar creation.\n\nColumnGeometrySupport.cs\t\nAs the geometry support for reinforcement creation on column, it could prepare the geometry information for transverse and vertical rebar creation.\n\nGeomUtil.cs\nThis file defines GeomUtil class which provides the base geometry operation and it is a static class.\n\nParameterUtil.cs\nThis file defines ParameterUtil class which contains utility methods to find or set certain parameter and it is a static class.\n\nDescription: This sample use Rebar.CreateFromCurves method to create Rebar for the selected host. Rebar.CreateFromCurves method needs RebarBarType parameter which can be got by iterating the active document elements. Another parameter that is needed is BarTerminationsData that stores Ids for hooks or end treatments or cranks. These ones can also be obtained by iterating the active document elements.\n\nInstructions: \n1.\tOpen or new a Revit project and make sure some Concrete Beams or Columns without any Reinforcement are placed. A sample project file Reinforcement.rvt is available in the sample’s folder.\n2.\tSelect a concrete Beam or Column, Run the command.\n3.\tSet the parameters for the rebar in the pop up dialog.\n4.\tClick Ok, Rebar for the selected element (Beam or Column) will be created."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Ribbon\\CS",
    "key_code": {
      "class_name": "CreateWall",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,\n                                             ref string message,\n                                             ElementSet elements)\n      {\n         Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, \"CreateWall\");\n         trans.Start();\n         Autodesk.Revit.UI.UIApplication app = revit.Application;\n\n         WallType newWallType = GetNewWallType(app); //get WallType from RadioButtonGroup - WallTypeSelector\n         Level newWallLevel = GetNewWallLevel(app); //get Level from Combobox - LevelsSelector\n         List<Curve> newWallShape = GetNewWallShape(app); //get wall Curve from Combobox - WallShapeComboBox\n         String newWallMark = GetNewWallMark(app); //get mark of new wall from Text box - WallMark\n\n         Wall newWall = null;\n         if (\"CreateStructureWall\" == this.GetType().Name) //decided by SplitButton\n         { newWall = Wall.Create(app.ActiveUIDocument.Document, newWallShape, newWallType.Id, newWallLevel.Id, true); }\n         else { newWall = Wall.Create(app.ActiveUIDocument.Document, newWallShape, newWallType.Id, newWallLevel.Id, false); }\n         if (null != newWall)\n         {\n            newWall.get_Parameter(BuiltInParameter.ALL_MODEL_MARK).Set(newWallMark); //set new wall's mark\n            CreatedWalls.Insert(newWall);\n         }\n         trans.Commit();\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n\n      #endregion IExternalCommand Members Implementation\n\n      #region protected methods\n      protected WallType GetNewWallType(Autodesk.Revit.UI.UIApplication app)\n      {\n         RibbonPanel myPanel = app.GetRibbonPanels()[0];\n         RadioButtonGroup radioGroupTypeSelector =\n             GetRibbonItemByName(myPanel, \"WallTypeSelector\") as RadioButtonGroup;\n         if (null == radioGroupTypeSelector) { throw new InvalidCastException(\"Cannot get Wall Type selector!\"); }\n         String wallTypeName = radioGroupTypeSelector.Current.ItemText;\n         WallType newWallType = null;\n         FilteredElementCollector collector = new FilteredElementCollector(app.ActiveUIDocument.Document);\n         ICollection<Element> founds = collector.OfClass(typeof(WallType)).ToElements();\n         foreach (Element elem in founds)\n         {\n            WallType wallType = elem as WallType;\n            if (wallType.Name.StartsWith(wallTypeName))\n            {\n               newWallType = wallType; break;\n            }\n         }\n\n         return newWallType;\n      }\n\n      protected Level GetNewWallLevel(Autodesk.Revit.UI.UIApplication app)\n      {\n         RibbonPanel myPanel = app.GetRibbonPanels()[0];\n         Autodesk.Revit.UI.ComboBox comboboxLevel =\n             GetRibbonItemByName(myPanel, \"LevelsSelector\") as Autodesk.Revit.UI.ComboBox;\n         if (null == comboboxLevel) { throw new InvalidCastException(\"Cannot get Level selector!\"); }\n         String wallLevel = comboboxLevel.Current.ItemText;\n         //find wall type in document\n         Level newWallLevel = null;\n         FilteredElementCollector collector = new FilteredElementCollector(app.ActiveUIDocument.Document);\n         ICollection<Element> founds = collector.OfClass(typeof(Level)).ToElements();\n         foreach (Element elem in founds)\n         {\n            Level level = elem as Level;\n            if (level.Name.StartsWith(wallLevel))\n            {\n               newWallLevel = level; break;\n            }\n         }\n\n         return newWallLevel;\n      }\n\n      protected List<Curve> GetNewWallShape(Autodesk.Revit.UI.UIApplication app)\n      {\n         RibbonPanel myPanel = app.GetRibbonPanels()[0];\n         Autodesk.Revit.UI.ComboBox comboboxWallShape =\n             GetRibbonItemByName(myPanel, \"WallShapeComboBox\") as Autodesk.Revit.UI.ComboBox;\n         if (null == comboboxWallShape) { throw new InvalidCastException(\"Cannot get Wall Shape Gallery!\"); }\n         String wallShape = comboboxWallShape.Current.ItemText;\n         if (\"SquareWall\" == wallShape) { return GetSquareWallShape(app.Application.Create); }\n         else if (\"CircleWall\" == wallShape) { return GetCircleWallShape(app.Application.Create); }\n         else if (\"TriangleWall\" == wallShape) { return GetTriangleWallShape(app.Application.Create); }\n         else { return GetRectangleWallShape(app.Application.Create); }\n      }\n\n      protected String GetNewWallMark(Autodesk.Revit.UI.UIApplication app)\n      {\n         RibbonPanel myPanel = app.GetRibbonPanels()[0];\n         Autodesk.Revit.UI.TextBox textBox =\n             GetRibbonItemByName(myPanel, \"WallMark\") as Autodesk.Revit.UI.TextBox;\n         if (null == textBox) { throw new InvalidCastException(\"Cannot get Wall Mark TextBox!\"); }\n         String newWallMark;\n         int newWallIndex = 0;\n         FilteredElementCollector collector = new FilteredElementCollector(app.ActiveUIDocument.Document);\n         ICollection<Element> founds = collector.OfClass(typeof(Wall)).ToElements();\n         foreach (Element elem in founds)\n         {\n            Wall wall = elem as Wall;\n            string wallMark = wall.get_Parameter(BuiltInParameter.ALL_MODEL_MARK).AsString();\n            if (wallMark.StartsWith(textBox.Value.ToString()) && wallMark.Contains('_'))\n            {\n               //get the index for new wall (wall_1, wall_2...)\n               char[] chars = { '_' };\n               string[] strings = wallMark.Split(chars);\n               if (strings.Length >= 2)\n               {\n                  try\n                  {\n                     int index = Convert.ToInt32(strings[strings.Length - 1]);\n                     if (index > newWallIndex) { newWallIndex = index; }\n                  }\n                  catch (System.Exception)\n                  {\n                     continue;\n                  }\n               }\n            }\n         }\n         newWallMark = textBox.Value.ToString() + '_' + (newWallIndex + 1);\n         return newWallMark;\n      }\n\n      protected List<Curve> GetRectangleWallShape(Autodesk.Revit.Creation.Application creApp)\n      {\n         //calculate size of Structural and NonStructural walls\n         int WallsSize = CreateStructureWall.CreatedWalls.Size + CreatedWalls.Size;\n         List<Curve> curves = new List<Curve>();\n         //15: distance from each wall, 60: wall length , 60: wall width \n         Line line1 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 60, 0));\n         Line line2 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 60, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 60, 40));\n         Line line3 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 60, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 40));\n         Line line4 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 0));\n         curves.Add(line1);\n         curves.Add(line2);\n         curves.Add(line3);\n         curves.Add(line4);\n         return curves;\n      }\n\n      protected List<Curve> GetSquareWallShape(Autodesk.Revit.Creation.Application creApp)\n      {\n         //calculate size of Structural and NonStructural walls\n         int WallsSize = CreateStructureWall.CreatedWalls.Size + CreatedWalls.Size;\n         List<Curve> curves = new List<Curve>();\n         //15: distance from each wall, 40: wall length  \n         Line line1 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 0));\n         Line line2 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 40));\n         Line line3 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 40));\n         Line line4 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 0));\n         curves.Add(line1);\n         curves.Add(line2);\n         curves.Add(line3);\n         curves.Add(line4);\n         return curves;\n      }\n\n      protected List<Curve> GetCircleWallShape(Autodesk.Revit.Creation.Application creApp)\n      {\n         //calculate size of Structural and NonStructural walls\n         int WallsSize = CreateStructureWall.CreatedWalls.Size + CreatedWalls.Size;\n         List<Curve> curves = new List<Curve>();\n         //15: distance from each wall, 40: diameter of circle  \n         Arc arc = Arc.Create(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 20, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 20, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 20));\n         Arc arc2 = Arc.Create(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 20, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 20, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 20));\n         curves.Add(arc);\n         curves.Add(arc2);\n         return curves;\n      }\n\n      protected List<Curve> GetTriangleWallShape(Autodesk.Revit.Creation.Application creApp)\n      {\n         //calculate size of Structural and NonStructural walls\n         int WallsSize = CreateStructureWall.CreatedWalls.Size + CreatedWalls.Size;\n         List<Curve> curves = new List<Curve>();\n         //15: distance from each wall, 40: height of triangle  \n         Line line1 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 0));\n         Line line2 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 40, 0), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 20, 40));\n         Line line3 = Line.CreateBound(new Autodesk.Revit.DB.XYZ(WallsSize * 15, 20, 40), new Autodesk.Revit.DB.XYZ(WallsSize * 15, 0, 0));\n         curves.Add(line1);\n         curves.Add(line2);\n         curves.Add(line3);\n         return curves;\n      }\n      #endregion\n\n      /// <summary>\n      /// return the RibbonItem by the input name in a specific panel\n      /// </summary>\n      /// <param name=\"panelRibbon\">RibbonPanel which contains the RibbonItem </param>\n      /// <param name=\"itemName\">name of RibbonItem</param>\n      /// <return>RibbonItem whose name is same with input string</param>\n      public RibbonItem GetRibbonItemByName(RibbonPanel panelRibbon, String itemName)\n      {\n         foreach (RibbonItem item in panelRibbon.GetItems())\n         {\n            if (itemName == item.Name)\n            {\n               return item;\n            }\n         }\n\n         return null;\n      }\n   }\n\n   /// <summary>\n   /// Implements the Revit add-in interface IExternalCommand,create a structural wall\n   /// all the properties for new wall comes from user selection in Ribbon\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class CreateStructureWall : CreateWall\n   {\n   }\n\n   /// <summary>\n   /// Implements the Revit add-in interface IExternalCommand, \n   /// delete all the walls which create by Ribbon sample\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class DeleteWalls : IExternalCommand\n   {\n      #region IExternalCommand Members Implementation\n      public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,\n                                             ref string message,\n                                             ElementSet elements)\n      {\n         // delete all the walls which create by RibbonSample\n         ElementSet wallSet = CreateWall.CreatedWalls;\n         Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, \"DeleteWalls\");\n         trans.Start();\n         foreach (Element e in wallSet)\n         {\n             revit.Application.ActiveUIDocument.Document.Delete(e.Id);\n         }\n         CreateWall.CreatedWalls.Clear();\n         trans.Commit();\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n      #endregion IExternalCommand Members Implementation\n   }\n\n   /// <summary>\n   /// Implements the Revit add-in interface IExternalCommand,Move walls, X direction\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class XMoveWalls : IExternalCommand\n   {\n      #region IExternalCommand Members Implementation\n\n      public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,\n                                             ref string message,\n                                             ElementSet elements)\n      {\n         Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, \"XMoveWalls\");\n         trans.Start();\n         IEnumerator iter = CreateWall.CreatedWalls.GetEnumerator();\n         iter.Reset();\n         while (iter.MoveNext())\n         {\n            Wall wall = iter.Current as Wall;\n            if (null != wall)\n            {\n               wall.Location.Move(new Autodesk.Revit.DB.XYZ(12, 0, 0));\n            }\n         }\n         trans.Commit();\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n      #endregion IExternalCommand Members Implementation\n   }\n\n   /// <summary>\n   /// Implements the Revit add-in interface IExternalCommand,Move walls, Y direction\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class YMoveWalls : IExternalCommand\n   {\n      #region IExternalCommand Members Implementation\n\n      public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,\n                                             ref string message,\n                                             ElementSet elements)\n      {\n         Transaction trans = new Transaction(revit.Application.ActiveUIDocument.Document, \"YMoveWalls\");\n         trans.Start();\n         IEnumerator iter = CreateWall.CreatedWalls.GetEnumerator();\n         iter.Reset();\n         while (iter.MoveNext())\n         {\n            Wall wall = iter.Current as Wall;\n            if (null != wall)\n            {\n               wall.Location.Move(new Autodesk.Revit.DB.XYZ(0, 12, 0));\n            }\n         }\n        trans.Commit();\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n      #endregion IExternalCommand Members Implementation\n   }\n\n   /// <summary>\n   /// Implements the Revit add-in interface IExternalCommand,\n   /// Reset all the Ribbon options to default, such as level, wall type...\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class ResetSetting : IExternalCommand\n   {\n      #region IExternalCommand Members Implementation\n\n      public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,\n                                             ref string message,\n                                             ElementSet elements)\n      {\n         RibbonPanel myPanel = revit.Application.GetRibbonPanels()[0];\n         //reset wall type\n         RadioButtonGroup radioGroupTypeSelector =\n             GetRibbonItemByName(myPanel, \"WallTypeSelector\") as RadioButtonGroup;\n         if (null == radioGroupTypeSelector) { throw new InvalidCastException(\"Cannot get Wall Type selector!\"); }\n         radioGroupTypeSelector.Current = radioGroupTypeSelector.GetItems()[0];\n\n         //reset level\n         Autodesk.Revit.UI.ComboBox comboboxLevel =\n             GetRibbonItemByName(myPanel, \"LevelsSelector\") as Autodesk.Revit.UI.ComboBox;\n         if (null == comboboxLevel) { throw new InvalidCastException(\"Cannot get Level selector!\"); }\n         comboboxLevel.Current = comboboxLevel.GetItems()[0];\n\n         //reset wall shape\n         Autodesk.Revit.UI.ComboBox comboboxWallShape =\n             GetRibbonItemByName(myPanel, \"WallShapeComboBox\") as Autodesk.Revit.UI.ComboBox;\n         if (null == comboboxLevel) { throw new InvalidCastException(\"Cannot get wall shape combo box!\"); }\n         comboboxWallShape.Current = comboboxWallShape.GetItems()[0];\n\n         //get wall mark\n         Autodesk.Revit.UI.TextBox textBox =\n             GetRibbonItemByName(myPanel, \"WallMark\") as Autodesk.Revit.UI.TextBox;\n         if (null == textBox) { throw new InvalidCastException(\"Cannot get Wall Mark TextBox!\"); }\n         textBox.Value = \"new wall\";\n\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n\n      /// <summary>\n      /// return the RibbonItem by the input name in a specific panel\n      /// </summary>\n      /// <param name=\"panelRibbon\">RibbonPanel which contains the RibbonItem </param>\n      /// <param name=\"itemName\">name of RibbonItem</param>\n      /// <return>RibbonItem whose name is same with input string</param>\n      public RibbonItem GetRibbonItemByName(RibbonPanel panelRibbon, String itemName)\n      {\n         foreach (RibbonItem item in panelRibbon.GetItems())\n         {\n            if (itemName == item.Name)\n            {\n               return item;\n            }\n         }\n\n         return null;\n      }\n\n      #endregion IExternalCommand Members Implementation\n   }\n\n   /// <summary>\n   /// Do Nothing, \n   /// Create this just because ToggleButton have to bind to a ExternalCommand\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class Dummy : IExternalCommand\n   {\n      #region IExternalCommand Members Implementation\n\n      public Autodesk.Revit.UI.Result Execute(ExternalCommandData revit,\n                                             ref string message,\n                                             ElementSet elements)\n      {\n         return Autodesk.Revit.UI.Result.Succeeded;\n      }\n\n      #endregion IExternalCommand Members Implementation\n   }\n}"
    },
    "documentation": {
      "ReadMe_Ribbon.rtf": "Summary: This sample demonstrates how to create customized ribbon for Add-In and how to create different types of ribbon items (RibbonPanel, PushButton, PulldownButton, Stackable Buttons, RadioButtonGroup, TextBox, SplitButton).\n\n\n\nClasses: \nAutodesk.Revit.ApplicationServices.ControlledApplication\nAutodesk.Revit.UI.RibbonPanel\nAutodesk.Revit.UI.PushButton\nAutodesk.Revit.UI.PulldownButton\nAutodesk.Revit.UI.PushButtonData\nAutodesk.Revit.UI.PulldownButtonData\nAutodesk.Revit.UI.IExternalCommand \nAutodesk.Revit.UI.IExternalApplication\n\nProject Files: \nRibbonSample.cs\nThis file contains the class RibbonSample which inherited from interface IExternalApplication and implemented method OnStartUp. The class will add some customized ribbon buttons with some simple functions attached to each of them. And these functions will be implemented in the AddInCommands class. \n\nAddInCommands.cs\n       This file contains several classes named CreateWall, CreateStructuralWall, DeleteWalls, XMoveWalls, YMoveWalls. These classes are corresponding to the buttons which created on ‘Add-In’ Ribbon panels.\n\nDescription: This sample should provide the following functionalities:\n·\tAdd different kinds of Ribbon Buttons into Revit: (just like the screenshot below)\nØ\tFirst Part of the Panel is use to create walls or structural walls.\nØ\tSecond Part is used to select on which level the new wall with what shape will be built. Also, you can undo you changes made on those choosing by “Reset” button. \nØ\tThird Part is used to select the wall type. \nØ\tFourth Part is used to set the “Mark” of the new wall. \nØ\tFifth Part is used to delete or move walls.\nØ\tFourth and fifty parts are added into the Slide-Out panel.\n\n\n·\tThe First Part contains one SplitButton which consists with two PushButtons.\nØ\tCreate Wall is used to create a wall in the center of the Revit canvas.\nØ\tCreate Wall is used to create a structural wall in the center of the Revit canvas.\n·\tThe Second Part contains one StackedButton which is consisted of one PushButton and two Comboboxes.\nØ\tThe first button is used to reset the choosing changes made by user.\nØ\tThe other two Combo-boxes are used to select the level and wall’s shape. \n·\tThe Third Part contains a RadioButtonGroup for user to select WallType.\n ·\tThe Fourth Part contains a Text box which is used to set the “Mark” for the new wall. \n ·\tThe Fifth Part contains a StackedButton which consisted of a PushButton (delete all the walls) and a PulldownButton (move all the walls in X or Y direction)\n\n\nImplementation Notes\n·\tTo add RibbonPanel in Revit, user need to implement the IExternalApplication interface, and call the corresponding method to create RibbonItems in OnStartup(ControlledApplication) method.\n·\tEach button in every Panel should have a corresponding command to execute. The command corresponding to each button should implement the IExternalCommand interface.\n·\tUse ControlledApplication.CreateRibbonPanel(string ribbonName) to add new Panel to Revit.\n·\tUse RibbonPanel.AddPushButton() to add single PushButton to each Panel.\n·\tUse RibbonPanel.AddStackedButtons() to add stackable buttons to each panel.\n·\tUse PulldownButton.AddItem() to add sub button to each PulldownButton.\n·\tSet the Image or LargeImage properties, user must new an ImageSource class first, but ImageSource is an abstract class, so user must new the subclass of ImageSource, such as BitmapImage.\nFor instance:  PushButton.Image = new BitmapImage(new Uri(imagePath, UriKind.Absolute))\n\n\n\nInstructions: \n1.\tCopy .addin file to the corresponding Addins folder for the Revit. You can found out the location of this folder by RevitAddUtility.dll, we also provided a sample named ExternalCommand for it.\n    (For example, folder location for XP user is here: \\\\Documents and Settings\\All Users\\Application Data\\Autodesk\\Revit\\Addins\\2012)\n2.\tCopy the Ribbon.dll and image files (bmp) to the same directory of this sample dll.\n3.\tRun Revit, then you can see the customized ribbon panel in Revit. \n4.\tClick each button to run this sample.\n·\tClick the ‘Structural Wall’ PushButton several times to create some walls in Revit. \n·\tClick on Combo-box and RadioButtonGroup to select what kind of wall you want to create.\n·\tClick the ‘Delete Walls’ button will delete all the walls created by Create Wall command.\n·\tClick the two sub buttons in the ‘Move Walls’ PulldownButton to move the wall."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\RoofsRooms\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            string assemblyLocation = Assembly.GetExecutingAssembly().Location;\n            string log = assemblyLocation + \".\" + DateTime.Now.ToString(\"yyyyMMdd\") + \".log\";\n            if (File.Exists(log)) File.Delete(log);\n            TraceListener txtListener = new TextWriterTraceListener(log);\n            Trace.Listeners.Add(txtListener);\n            try\n            {\n                // variable initialization\n                m_application = commandData.Application.Application;\n                m_document = commandData.Application.ActiveUIDocument.Document;\n                Environment.CurrentDirectory = Path.GetDirectoryName(assemblyLocation);\n\n                FindRoomBoundingRoofs(ref message, elements);\n\n                // Not show TaskDialog in regression mode\n                if (0 == commandData.JournalData.Count)\n                {\n                    TaskDialog.Show(\"Roofs Rooms\", message);\n                }\n\n                // Insert result to journal data for regression purpose.\n                const string DataKey = \"Results\";\n                if (!commandData.JournalData.ContainsKey(DataKey))\n                {\n                    // In normal/recording mode \n                    commandData.JournalData.Add(DataKey, message);\n                }\n                else\n                {\n                    // In regression/replaying mode\n                    commandData.JournalData[DataKey] = message;\n                }\n\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception ex)\n            {\n                Trace.WriteLine(ex.ToString());\n                message = ex.ToString();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            finally\n            {\n                Trace.Flush();\n                txtListener.Close();\n                Trace.Close();\n                Trace.Listeners.Remove(txtListener);\n            }\n        }\n\n        /// <summary>\n        /// Test whether each room has a roof to bound it.\n        /// </summary>\n        /// <param name=\"message\">Error message to be dumped.</param>\n        /// <param name=\"elements\">Some elements to return.</param>\n        /// <returns></returns>\n        private bool FindRoomBoundingRoofs(ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            // Get all rooms\n            List<Element> rooms = GetRoomsElements();\n            if (rooms.Count == 0)\n            {\n                message = \"Unable to identify any rooms, please create room first!\";\n                return false;\n            }\n\n            // Represents the criteria for boundary elements to be considered bounding roofs\n            LogicalOrFilter categoryFilter = new LogicalOrFilter(new ElementCategoryFilter(BuiltInCategory.OST_Roofs),\n                                                                    new ElementCategoryFilter(BuiltInCategory.OST_RoofSoffit));\n\n            // Calculator for room/space geometry.\n            SpatialElementGeometryCalculator calculator = new SpatialElementGeometryCalculator(m_document);\n\n            // Stores the resulting room->roof relationships\n            Dictionary<Element, List<ElementId>> roomsAndRoofs = new Dictionary<Element, List<ElementId>>();\n\n            foreach (Element room in rooms)\n            {\n                // Get room geometry & boundaries          \n                SpatialElementGeometryResults results = calculator.CalculateSpatialElementGeometry((SpatialElement)room);\n\n                // Get solid geometry so we can examine each face\n                Solid geometry = results.GetGeometry();\n\n                foreach (Face face in geometry.Faces)\n                {\n                    // Get list of roof boundary subfaces for a given face\n                    IList<SpatialElementBoundarySubface> boundaryFaces = results.GetBoundaryFaceInfo(face);\n                    foreach (SpatialElementBoundarySubface boundaryFace in boundaryFaces)\n                    {\n                        // Get boundary element\n                        LinkElementId boundaryElementId = boundaryFace.SpatialBoundaryElement;\n\n                        // Only considering local file room bounding elements\n                        ElementId localElementId = boundaryElementId.HostElementId;\n\n                        // Evaluate if element meets criteria using PassesFilter()\n                        if (localElementId != ElementId.InvalidElementId && categoryFilter.PassesFilter(m_document, localElementId))\n                        {\n                            // Room already has roofs, add more\n                            if (roomsAndRoofs.ContainsKey(room))\n                            {\n                                List<ElementId> roofs = roomsAndRoofs[room];\n                                if (!roofs.Contains(localElementId))\n                                    roofs.Add(localElementId);\n                            }\n                            // Room found first roof\n                            else\n                            {\n                                List<ElementId> roofs = new List<ElementId>();\n                                roofs.Add(localElementId);\n                                roomsAndRoofs.Add(room, roofs);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n\n            // Format results\n            if (roomsAndRoofs.Count > 0)\n            {\n                String logs = String.Format(\"Rooms that have a bounding roof:\");\n                message += logs + \"\\t\\r\\n\";\n                Trace.WriteLine(logs);\n                foreach (KeyValuePair<Element, List<ElementId>> kvp in roomsAndRoofs)\n                {\n                    // remove this room from all rooms list\n                    rooms.Remove(kvp.Key);\n\n                    List<ElementId> roofs = kvp.Value;\n                    String roofsString;\n\n                    // Single roof boundary\n                    if (roofs.Count == 1)\n                    {\n                        Element roof = m_document.GetElement(roofs[0]);\n                        roofsString = String.Format(\"Roof: Id = {0}, Name = {1}\", roof.Id.ToString(), roof.Name);\n                    }\n                    // Multiple roofs\n                    else\n                    {\n                        roofsString = \"Roofs ids = \" + string.Join(\", \", Array.ConvertAll<ElementId, string>(roofs.ToArray(), i => i.ToString()));\n                    }\n\n                    // Save results\n                    logs = String.Format(\n                        \"  Room: Id = {0}, Name = {1} --> {2}\",\n                        kvp.Key.Id.ToString(), kvp.Key.Name, roofsString);\n                    message += logs + \"\\t\\r\\n\";\n                    Trace.WriteLine(logs);\n                }\n            }\n\n            // Format the rooms that have no bounding roof\n            Trace.WriteLine(\"Geometry relationship checking finished...\");\n            if (rooms.Count != 0)\n            {\n                String logs = String.Format(\"Below rooms don't have bounding roofs:\");\n                message += logs + \"\\t\\r\\n\";\n                Trace.WriteLine(logs);\n                foreach (Element room in rooms)\n                {\n                    elements.Insert(room);\n                    logs = String.Format(\"  Room Id: {0}, Room Name: {1}\",\n                        room.Id.ToString(), room.Name);\n                    message += logs + \"\\t\\r\\n\";\n                    Trace.WriteLine(logs);\n                }\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Retrieve all Rooms and Spaces elements from active document.\n        /// </summary>\n        /// <returns>Element list retrieved from current document.</returns>\n        private List<Element> GetRoomsElements()\n        {\n            List<Element> array = new List<Element>();\n            ElementFilter roomSpaceFilter = new LogicalOrFilter(new RoomFilter(), new SpaceFilter());\n            FilteredElementCollector collector = new FilteredElementCollector(m_document);\n            array.AddRange(collector.WherePasses(roomSpaceFilter).ToElements());\n            return array;\n        }\n\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_RoofsRooms.rtf": "Summary: This sample demonstrates how to check whether a Room/Space has a bounding Roof.\n\nClasses: \nAutodesk.Revit.DB.Mechanical.SpaceFilter \nAutodesk.Revit.DB.Architecture.RoomFilter\nAutodesk.Revit.DB.ElementCategoryFilter\nAutodesk.Revit.DB.FilteredElementCollector\nAutodesk.Revit.DB.LogicalOrFilter\nAutodesk.Revit.DB.Architecture.Room\nAutodesk.Revit.DB.Mechanical.Space\nAutodesk.Revit.DB.BuiltInCategory\nAutodesk.Revit.DB.SpatialElementGeometryCalculator\nAutodesk.Revit.DB.SpatialElementGeometryResults\nAutodesk.Revit.DB.SpatialElementBoundarySubface\n    Autodesk.Revit.DB.Solid\nAutodesk.Revit.DB.Face\n\nProject Files: \nCommand.cs\nThis file contains a class RoofsRooms which inherits from IExternalCommmand interface and implements the Execute method; some methods of class are used to retrieve Room/Space and Roof elements.\n\nDescription: Functionalities:\nRetrieve all Rooms (Space) and Roofs from current project and check them separately.\nUse SparialElementGeometryCalculator to obtain the boundary faces of the room/space. \nCheck if boundary faces related element is a roof.\n\nImplementation: \nTo retrieve all Room and Space elements together in current document create separated RoomFilter and SpaceFilter, and then create LogicalOrFilter for them.\nTo retrieve the geometry of rooms and spaces use SpatialElementGeometryCalculator.  Construct this object and pass each element to its CalculateSpatialElementGeometry() method.\nObtain the solid representing the room/space from SpatialElementGeometryResults.GetGeometry()\nTo get Faces of solid object use Solid.Faces property. \nFor each face, get the related SpatialElementBoundarySubface(s) from SpatialElementGeometryResults.GetBoundaryFaceInfo().\nTo see if the boundary element is a roof ElementFilter.PassesElement() - usin ElementCategoryFilter (BuiltInCategory for Roof and Roof Soffit are OST_Roofs and OST_RoofSoffit separately).\nElements.Face is a base class; the derived classes are PlanarFace, PlanarFace, ConicalFace, CylindricalFace, RevolvedFace, HermiteFace and RuledFace. \nPlanarFace.Origin and Normal properties will be used to check if two Planar Faces are coincident. Maybe the Normals of faces are opposite, and then we can calculate the project distance by using Face.Project(XYZ) method to check if point is in face.  \nConicalFace.Axis, Origin properties and get_Radius(int) method will be used to check if two ConicalFaces are coincident.\nCylindricalFace.Axis, Origin properties and get_Radius(int) method will be used to check if two CylindricalFaces are coincident.\nRevolvedFace.Axis, Origin properties andCurve properties will be used to check if two RevolvedFace are coincident; to get points of curve use Curve.Tessellate() method.\nHermiteFace.Points and MixedDerivs properties can be used to check if two HermiteFaces are coincident. \nRuledFace.get_Curve(int) and get_Point(int) methods can be used to retrieve the curve and points of RuledFace, and then use those points and curves to check if two RuledFaces are coincident.\n\nInstructions: \n1.\tRun Revit, draw some Rooms (Spaces) and then bind Roofs to them, you can adjust the “Upper Limit” and “Limit Offset” parameters of Rooms (Spaces), “Base Level” and “Base Offset from Level” parameters of Roofs. One Architecture sample model (RoofsRooms.rvt) with Rooms and one MEP sample model (MEPRoofsRooms.rvt) with Space are provided under sample project folder. \n2.\tRun the external command, command will pop up the bounding check results. \n\nNote: \n1.\tBefore running this external command, please ensure you have turned on “Areas and Volumes” option in [Settings] - [Area and Volume Computations…] - “Computations” tab.\n2.\tEnsure the “Room Bounding” parameter is checked in element properties dialog of Roof, otherwise the Roof will not be bounding of Room. \n3.\tCurrently, Sloped Glazing Roof is not supported by this sample."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Rooms\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n                                               ref string message,\n                                               ElementSet elements)\n        {\n            try\n            {\n                Transaction tran = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Rooms\");\n                tran.Start();\n                // create a new instance of class data\n                RoomsData data = new RoomsData(commandData);\n\n                // create a form to display the information of rooms\n                using (roomsInformationForm infoForm = new roomsInformationForm(data))\n                {\n                    infoForm.ShowDialog();\n                }\n                tran.Commit();\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception ex)\n            {\n                // If there are something wrong, give error information and return failed\n                message = ex.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_Rooms.rtf": "Summary: This sample demonstrates how to get Room’s information (Number, Area, Department, etc), add room tags and change Room numbers.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Creation.Document\nAutodesk.Revit.DB.Architecture.Room\nAutodesk.Revit.DB.Architecture.RoomTag\nAutodesk.Revit.DB.Parameters.BuiltInParameter\n\nProject Files: \nCommand.cs\nThis file contains the class Command which inherits from IExternalCommand interface and implements the Execute method.\n\nRoomsData.cs\nThis class defines a data class for implementing all the functionalities of this sample, such as: get Room’s information (Area, Department, etc), add Room Tags, change Room Number and so on.\n\nRoomInfoForm.cs\nThis file contains a Form class which consists of two ListView controls: one is for showing the Number, Area, and Department information of Rooms, the other one is for showing the total Area of different Room Departments.\n\nDescription: This sample uses Rooms and Creation classes mostly to implement the functionality: get Room’s information (Number, Department, Tags, etc), add Tags to Room and change Room’s number.\n-\tRoom objects can be gotten via ActiveDocument.Elements property.\n-\tTo add Tags for Room, use Document.Create.NewRoomTag method.\n-\tTo get department and area of Room, use BuiltInParameter.ROOM_DEPARTMENT and BuiltInParameter.ROOM_AREA as parameters for Room.get_Parameter() methods.\n-\tNumber property of Room can be used to get/set the Room’s Number.\n\nInstructions: \n1.\tDraw some Walls and Rooms in Revit firstly (you can define different Departments for Rooms or delete some Rooms’ tags for the following steps).\n2.\tClick the extern command, the Rooms Information form will be popped up: information (Name, Number, Department, etc) of all Rooms will be listed in upper ListView control, the lower ListView control will list total areas for different Departments.\n3.\tClick “Add Tags” button to add tags for the Rooms which don’t have Tags.\n4.\tClick the “Reorder” button, the Numbers of all Rooms will be sorted by ascending order according to Room’s Location coordinate value (first is Z, next is X, the last is Y).\n5.\tClick “Export” button to export the Department summary Area to a .csv file.\n\nNotes: \nBecause we need location of room when adding tag, this sample will skip those rooms which don’t locate at level yet (Room.Location property is null for those rooms)."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\RoomSchedule\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n                                               ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Transaction tranSample = null;\n            try\n            {\n                tranSample = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Sample Start\");\n                tranSample.Start();\n                // create a form to display the information of Revit rooms and xls based rooms\n                using (RoomScheduleForm infoForm = new RoomScheduleForm(commandData))\n                {\n                    infoForm.ShowDialog();\n                }\n                tranSample.Commit();\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception ex)\n            {\n                if (null != tranSample) tranSample.RollBack();\n                // if there are something wrong, give error information and return failed\n                message = ex.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n    }\n    #endregion\n}"
    },
    "documentation": {
      "ReadMe_RoomSchedule.rtf": "Summary: This sample demonstrates: how to retrieve spread sheet data, how to create rooms without placing them and how to update spreadsheet data with data of rooms mapped to.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Document\nAutodesk.Revit.DB.Architecture.Room\nAutodesk.Revit.DB.Level\nAutodesk.Revit.DB.Phase\nAutodesk.Revit.DB.Category\nAutodesk.Revit.DB.Parameters.BuildInParameter\nAutodesk.Revit.DB.Parameters.Definition\nAutodesk.Revit.DB.Parameters.DefinitionGroup\nAutodesk.Revit.DB.Parameters.InstanceBinding\n\nAutodesk.Revit.DB.Events.DocumentSaving\nAutodesk.Revit.DB.Events.DocumentSavingAs\nAutodesk.Revit.DB.Events.DocumentClosed\n\nSystem.Data.OleDb.OleDbConnection\nSystem.Data.OleDb.OleDbCommand\nSystem.Data.DataTable\n\n\nProject Files: \nCommand.cs\nThis file contains the class Command which inherits from IExternalCommand interface and implements the Execute method, this class will pop up Room Schedule form.\n\nCtrlApplication.cs\nThis file contains the class CrtlApplication which implements IExternalApplication interface, this class will subscribe DocumentSaving/SavingAs event in OnStartup method and unregister these events in OnShutdown method.\nThe OnStartup method will subscribe \n\nRoomScheduleForm.cs\nThis file contains a Form class which consists of two DataGridView controls and three ComboBox controls. The data from spreadsheet and available rooms, levels and phases will be displayed in these controls. \n\nRoomsData.cs\nThis file will be used to retrieve available rooms, levels and phases data from current Revit project and generate rooms DataTable data for display in DataGridView control.\n\nXlsDBConnector.cs\nThis file will be used to connect to Excel spreadsheet file (.xls), retrieve available tables and generate DataTable data for display in DataGridView control; besides, this class will be used to update spreadsheet data or insert new data to spreadsheet.\n\nEventsReactor.cs\nThis file defines the class EventsReactor which contains three delegates methods for DocumentSaving/SavingAs/Closing events, the delegate methods will implement accordingly update when they are raised.\nClass EventsReactor also includes methods which implement update for spreadsheet and Revit rooms; when update, related logging information will be dumped to log file(RoomSchedule.log) for your review later.\n\nDescription: This sample uses OleDb.OleDbConnection, OleDb.OleDbCommand and relevant Revit classes mostly to synchronize spreadsheet based room schedule with Revit rooms. This sample implements two functionalities: import room schedule from spreadsheet and update room area fields in spreadsheet by using data from Revit.\n-\tTo deal with .xls file (read, update), use OleDb.OleDbConnection, OleDbCommand, DataTable classes of .NET.\n-\tTo create rooms in specified phase, use Creation.Document.NewRoom(Phase).\n-\tTo get specified element you want, use Document.get_Elements(Filter) method.\n-\tTo get parameters of room, use Room.get_Parameter(String paramName) method.\n-\tTo get all rooms in each PlanTopology, use PlanTopology.Rooms property.\n-\tDocumenSaving/DocumentSavedAs/DocumentClosed of controlled application level subscribed and implements related functionality.\n-\tClass DefinitionFile, DefinitionGroup, Definition and InstanceBinding will be used to create shared parameter for rooms.\n\nInstructions: \n1.\tCopy the provided .addin file under sample folder to install folder of your Revit and specify full paths for dll. .  \n2.\tBefore running this sample, please make sure the Excel file has a work sheet which must contain “ID”, “Room Area “, “Room Name”, “Room Number”, “Room Comments” columns at first row, the ID and Area columns should be number values, the other columns should be text value, and the spreadsheet should be writeable too. Under project folder there is one Excel file named RoomSchedule.xls, you can use this file as example to define your data or import this file directly in below steps.  \n3.\tRun this sample directly, the “Room Schedule” form will pop up, all the available levels and phases will be listed in ComboBox controls separately.\n4.\tClick “Import Excel...” button will allow you to select one spreadsheet file. This sample will retrieve all available work sheets in this sheet file and list them in ComboBox control. \n5.\tSelect the work sheet which defines the rooms, and then all room data in this sheet will be displayed in DataGridView control.\n6.\tSelect one phase and click “Create Unplaced Rooms” will create rooms (without placing them) according to the spread sheet rooms’ data (The new unplaced rooms’ properties will set by the relevant columns in spreadsheet data). A shared parameter named “External Room ID” will be added to Room category and the parameter value is mapped to spread sheet rooms’ ID. Document Save, SaveAs events will be subscribed too after rooms’ creation.\n7.\tCheck “Show All Rooms” will display all available rooms (placed and unplaced rooms) in current project; select one level will filter all rooms which are in selected level.\n8.\tExit this sample, click the “Room” in Revit Basic tab, select the created rooms in above steps and place them. Click Save/SaveAs command to save project: After Save dialog this sample will update the “Room Area”, “Room Name”, “Room Number” and “Room Comments” column data of work sheet by the actual values of mapped and placed room. You can open log file(RoomSchedule.log) to review details of update.\n9.\tIf there are new rooms which were created and placed by user manually, these rooms will be added into spreadsheet when save or save as is called, the “Room Comments” column in spread will be set to “<Added from Revit>” if the room doesn’t have comments. Besides, the “External Room ID” parameter of new room will be set to room’s id value after adding.\n10.\tWhen creating unplaced rooms, the new rooms’ name, number and comments properties will be set by the “Room Name”, “Room Number” and “Room Comments” column values in room sheet automatically. \n11.\tIf spreadsheet room was already mapped by Revit room, new creation will be skipped (some message will be popped up), because more than one Revit room maps to same one spreadsheet room is not allowed. Click “Clear External Room ID” button will clear the existing maps (all values of shared parameter will to set to null) and allow user to create more unplaced rooms.\n\nNotes: \n1.\tThe sample is not supported with 64-bit Revit since there is no 64-bit Jet OLE DB Provider available.\n2.\tBecause of limitations of Excel ISAM driver, if there is both number data and text data in Name, Number or Comments columns in Excel file, please format number data to text type by adding a single quotation in front of data as prefix, text format will make sample’s read and update operations work well. Again, generally the Rooms created manually or by API will have text Name, and the Comments column will be filled with text “<null>” if Revit room doesn’t have Comments value, so you’d better make sure there is no number data in Name and Comments column.  \n3.\tThe Name and Comments of Room should not contain single quote (‘) because it will conflict with SQL query line."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\ShaftHolePuncher\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Transaction trans = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Revit.SDK.Samples.ShaftHolePuncher\");\n            trans.Start();\n            try\n            {\n                Wall wall = null;\n                Floor floor = null;\n                FamilyInstance familyInstance = null;\n                ElementSet elems = new ElementSet();\n                foreach (ElementId elementId in commandData.Application.ActiveUIDocument.Selection.GetElementIds())\n                {\n                   elems.Insert(commandData.Application.ActiveUIDocument.Document.GetElement(elementId));\n                }\n\n                #region selection handle -- select one floor, wall, beam or nothing\n                //if user had some wrong selection, give user an Error message\n                string errorMessage =\n                    \"Please select one Floor (Beam or Wall) to create opening or select nothing to create Shaft Opening\";\n                if (elems.Size > 1)\n                {\n                    message = errorMessage;\n                    trans.RollBack();\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n\n                Autodesk.Revit.DB.Element selectElem = null;\n                if (1 == elems.Size)\n                {\n                    IEnumerator iter = elems.GetEnumerator();\n                    iter.Reset();\n                    if (iter.MoveNext())\n                    {\n                        selectElem = (Autodesk.Revit.DB.Element)iter.Current;\n                    }\n\n                    if (selectElem is Wall)\n                    {\n                        wall = selectElem as Wall;\n                    }\n                    else if (selectElem is Floor)\n                    {\n                        floor = selectElem as Floor;\n                    }\n                    else if (selectElem is FamilyInstance)\n                    {\n                        familyInstance = selectElem as FamilyInstance;\n                        if (familyInstance.StructuralType !=\n                            Autodesk.Revit.DB.Structure.StructuralType.Beam)\n                        {\n                            message = errorMessage;\n                            trans.RollBack();\n                            return Autodesk.Revit.UI.Result.Cancelled;\n                        }\n                    }\n                    else\n                    {\n                        message = errorMessage;\n                        trans.RollBack();\n                        return Autodesk.Revit.UI.Result.Cancelled;\n                    }\n                }\n                #endregion\n\n                try\n                {\n                    if (null != wall)\n                    {\n                        ProfileWall profileWall = new ProfileWall(wall, commandData);\n                        ShaftHolePuncherForm shaftHolePuncherForm = \n                            new ShaftHolePuncherForm(profileWall);\n                        shaftHolePuncherForm.ShowDialog();\n                    }\n                    else if (null != floor)\n                    {\n                        ProfileFloor profileFloor = new ProfileFloor(floor, commandData);\n                        ShaftHolePuncherForm shaftHolePuncherForm =\n                            new ShaftHolePuncherForm(profileFloor);\n                        shaftHolePuncherForm.ShowDialog();\n                    }\n                    else if (null != familyInstance)\n                    {\n                        ProfileBeam profileBeam = new ProfileBeam(familyInstance, commandData);\n                        ShaftHolePuncherForm shaftHolePuncherForm =\n                            new ShaftHolePuncherForm(profileBeam);\n                        shaftHolePuncherForm.ShowDialog();\n                    }\n                    else\n                    {\n                        ProfileNull profileNull = new ProfileNull(commandData);\n                        ShaftHolePuncherForm shaftHolePuncherForm =\n                            new ShaftHolePuncherForm(profileNull);\n                        shaftHolePuncherForm.ShowDialog();\n                    }\n                }\n                catch (Exception ex)\n                {\n                    message = ex.Message;\n                    trans.RollBack();\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n                trans.Commit();\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception e)\n            {\n                message = e.Message;\n                trans.RollBack();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_ShaftHolePuncher.rtf": "Summary: This sample demonstrates how to create single or Shaft Opening on a wall, floor or beam.\n \nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Opening\nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.Level\nAutodesk.Revit.DB.Face\nAutodesk.Revit.DB.Edge\nAutodesk.Revit.DB.Solid\nAutodesk.Revit.DB.Instance\nAutodesk.Revit.DB.Transform\nAutodesk.Revit.DB.CurveArray\nAutodesk.Revit.Creation.Document\n\nProject Files: \nCommand.cs\nThis file contains a class Command that implements the IExternalCommand, gets the selected wall, floor or beam and creates Opening on it.\n\nShaftHolePuncherForm.cs\nThis file contains a class ShaftHolePuncherForm which inherits from Form. The function of this class is to display profile of the selected wall, floor or beam and let user draw profile of Opening on it. If user wants to create a Shaft Opening, a coordinate system will be shown.\n\nProfile.cs\nThis file contains a class Profile which is derived by ProfileWall, ProfileFloor, ProfileBeam ProfileNull. Profile includes methods Draw2D() and CreateOpening(). Draw2D() is used to draw profile on the form, and CreateOpening() is used to create Opening on the corresponding host.\n\nProfileNull.cs\nThis file contains a class ProfileNull derived from Profile. ProfileNull overrides Draw2D() and CreateOpening(). Draw2D() is used to draw the coordinate system to help user to draw a curve loop for Shaft Opening, and CreateOpening() is used to create Shaft Opening.\n\nProfileBeam.cs\nThis file contains a class ProfileBeam derived from Profile. ProfileBeam overrides GetTo2DMatrix(), Draw2D() and CreateOpening() methods. Draw2D() is used to draw the profile of a beam (user can change the direction to create opening via a combo box), and CreateOpening() is used to create opening on a beam.\n\nLineTool.cs\nThis file contains a class named LineTool which provides some methods to draw lines on the form and store the data of drawn lines.\n\nRectangleTool.cs\nThis file contains a class named RectangleTool which provides some methods to draw rectangle on the form and store the data of drawn rectangle.\n\nMathTools.cs\nThis file contains Verctor4 and Matrix4 two classes. These two classes are used to transform points between 3D and 2D.\n\nDescription: This sample shows user how to create Opening by \nAutodesk.Revit.Creation.Document.NewOpening(…) method, this method has four overloads:\n-\tNewOpening(Element, CurveArray, eRefFace) is used to create Opening in a beam, brace or column. eRefFace is used to define a face which opening is based on.\n-\tNewOpening(Element, CurveArray, bool) <mk:@MSITStore:C:\\Program%20Files\\Autodesk%20Revit%20Building%2010\\Program\\RevitAPI.chm::/Autodesk.Revit.Creation.Document.NewOpening_overload_2.html> is used to create Opening on roof, floor or ceiling, bool value is used to indicate whether it is to cut perpendicular to the face or cut vertically.\n-\tNewOpening(Level, Level, CurveArray) is used to create Shaft Opening.\n-\tNewOpening(Wall, ref XYZ, ref XYZ) is used to create Opening on Wall.\n\nInstructions: \n1.\tDraw a wall, floor or beam and select it. Do not select anything if you want to create a Shaft Opening. (or open ShaftHolePuncher.rvt)\n2.\tRun this command.\n3.\tDraw the profile of Opening you want to create, click right mouse button to close the curve and finish drawing.\n4.\tIf user wants to create Opening on beam, user can change the direction to create opening by the combo box. And picture box will draw the profile of beam in the corresponding direction.\n5.\tIf this is a Shaft Opening, user can draw a curve in the displayed coordinate system, and select the scale coefficient in the combo box to scale it. Command will create a shaft opening from level1 to level2.\n6.\tUser can clean and redraw the profile of opening by clicking “Clean” button.\n7.\tClick “Create” button will create Opening in Revit when you finish the curve.\n\n\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\SharedCoordinateSystem\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n                                             ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n           \n         try\n         {\n            Transaction trans = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Revit.SDK.Samples.SharedCoordinateSystem\");\n            trans.Start();\n            CoordinateSystemData Data = new CoordinateSystemData(commandData);\n            Data.GatData();\n\n            using (CoordinateSystemDataForm displayForm =\n                                    new CoordinateSystemDataForm(Data, commandData.Application.Application.Cities,\n                                                commandData.Application.ActiveUIDocument.Document.SiteLocation))\n            {\n               if (DialogResult.OK != displayForm.ShowDialog())\n               {\n                  trans.RollBack();\n                  return Autodesk.Revit.UI.Result.Cancelled;\n               }\n            }\n            trans.Commit();\n            return Autodesk.Revit.UI.Result.Succeeded;\n         }\n         catch (Exception ex)\n         {\n            message = ex.Message;            \n            return Autodesk.Revit.UI.Result.Failed;\n         }\n\n     }\n     #endregion IExternalCommand Members Implementation\n }\n}"
    },
    "documentation": {
      "ReadMe_SharedCoordinateSystem.rtf": "Summary: This sample demonstrates how to get place, location of project, and change their values.\n\nClasses:  \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Element\nAutodesk.Revit.DB.GeometryElement\nAutodesk.Revit.DB.Parameter\nAutodesk.Revit.DB.GeometryObject\nAutodesk.Revit.DB.Transform\nAutodesk.Revit.DB.Structure.AnalyticalModel\nAutodesk.Revit.DB.SiteLocation\nAutodesk.Revit.DB.CitySet\n\nProject Files: \nCommand.cs\nThis file contains the class “Command” that inherits from “IExternalCommand” interface and implements the “Execute” method.\n\nCoordinateSystemData.cs\nIt contains a class “CoordinateSystemData” which is used to deal with Location information, such as operation “get”, “change” and “duplicate” Location.\n\nCoordinateSystemDataForm.cs\nIt contains a class “CoordinateSystemDataForm” which is used to display and set Location and Place information in a TabControl that has two TabPages “Locations” and “Place”.\n\nDuplicateForm.cs\nIt contains a class “DuplicateForm” which is used to duplicate Location.\n\nPlaceInfo.cs\nIt consists of:\nA class “PlaceInfo” which is used to store information of all cities includes its name, Latitude, longitude, and timezone;\nA struct “CityInfo” is used to describe information about a city;\nA struct “CityInfoString” is used to describe the information about city, and all its members are string type.\n\nUnitConversion.cs\nIt contains a class “UnitConversion” which is a utility class that provides unit information and some unit conversion functions, such as converting a string to Double.\n\nDescription: This sample demonstrates the following functionality:\n-\tGet place of the current document, and get the data from place (in the active document):\n-\tCity name.\n-\tLatitude.\n-\tLongitude.\n-\tTime zone.\n-\tGet location of the current document, and get the data from location:\n-\tName\n-\tTransform (from this point to origin)\n-\tPresent a dialog to show the data of place and location for current document, and modify the following information:\n-\tLatitude, Longitude and Time zone for active place\n-\tActive Place for the active document (City Name, Latitude and Longitude) to defined list AR-CITY.UNI file on disk\n-\tTransform for current Location\n-\tCurrent Location from list of defined locations\n-\tAdd new location to list.\n\nImplementations:\n-\tThe Location of an active project can be retrieved by using “Document.ActiveProjectLocation” property.\n-\tThe Place of the active project can be retrieved by using “Document.SiteLocation” property. The latitude, longitude and time zone can be retrieved via properties Latitude, Longitude and TimeZone of class “Autodesk.Revit.Site.SiteLocation <mk:@MSITStore:C:\\Documents%20and%20Settings\\llzhou\\Desktop\\revit\\RevitAPI%202008.chm::/Autodesk.Revit.Site.html>”.\n\nInstructions: \n1.\tCopy “timezone.txt” file in project folder to same folder directory of the file “SharedCoordinateSystem.dll”, then run the command.\n2.\tA dialog with a tab control will be shown to display information about place and location, it is allowed to set or change location and place values.\n3.\tFurthermore, this sample is similar to menu command “Manage Place and Locations” under Revit “Settings”, former one can almost do what the latter can do.\n\u0000",
      "timezone.txt": "(GMT-12:00) International Date Line West\n(GMT-11:00) Midway Island, Samoa\n(GMT-10:00) Hawaii\n(GMT-09:00) Alaska\n(GMT-08:00) Pacific Time (US/Canada)\n(GMT-08:00) Tijuana, Baja California\n(GMT-07:00) Arizona\n(GMT-07:00) Chihuahua, La Paz, Mazatlan - New\n(GMT-07:00) Chihuahua, La Paz, Mazatlan - Old\n(GMT-07:00) Mountain Time (US/Canada)\n(GMT-06:00) Central America\n(GMT-06:00) Central Time (US/Canada)\n(GMT-06:00) Guadalajara, Mexico City, Monterrey - New\n(GMT-06:00) Guadalajara, Mexico City, Monterr..."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\SheetToView3D\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n        ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         if (null == commandData)\n         {\n            throw new ArgumentNullException(\"commandData\");\n         }\n\n         Result result = Result.Succeeded;\n         try\n         {\n            result = MakeView3D.MakeFromViewportClick(commandData.Application.ActiveUIDocument);\n         }\n         catch (Exception e)\n         {\n            message = e.Message;\n            return Autodesk.Revit.UI.Result.Failed;\n         }\n\n         return result;\n      }\n\n      #endregion IExternalCommand Members Implementation\n   }\n\n   /// <summary>\n   /// Generates a View3D from a click on a viewport on a sheet.\n   /// </summary>\n   public class MakeView3D\n   {\n      private static double CLICK_TOLERANCE = 0.0001;\n\n      /// <summary>\n      /// Makes a View3D from a click on a viewport on a sheet.\n      /// </summary>\n      /// <param name=\"uidoc\">the currently active uidocument</param>\n      /// <param name=\"doc\">the currently active document</param>\n      public static Autodesk.Revit.UI.Result MakeFromViewportClick(UIDocument uidoc)\n      {\n         if (null == uidoc)\n         {\n            throw new ArgumentNullException(\"uidoc\");\n         }\n\n         Document doc = uidoc.Document;\n         if (null == doc)\n         {\n            throw new InvalidOperationException(\"The document can't be found.\");\n         }\n\n         Result result = Result.Succeeded;\n\n         // Have the user click on a plan view viewport on a sheet.\n         XYZ click = uidoc.Selection.PickPoint(\"Click on a plan view viewport on a sheet to create a perspective View3D with its camera at that point.\");\n         if (null == click)\n         {\n            throw new InvalidOperationException(\"Please click on a plan view viewport on a sheet.\");\n         }\n\n         // Make sure the active view was a sheet view.\n         ViewSheet viewSheet = uidoc.ActiveGraphicalView as ViewSheet;\n         if (null == viewSheet)\n         {\n            throw new InvalidOperationException(\"The click was not on a sheet.\");\n         }\n\n         // Find which viewport was clicked.\n         Viewport clickedViewport = GetViewportAtClick(viewSheet, click);\n         if (null == clickedViewport)\n         {\n            throw new InvalidOperationException(\"The click was not on a viewport.\");\n         }\n\n         // Verify that the transforms are reported by the viewport and its view.\n         View clickedView = doc.GetElement(clickedViewport.ViewId) as View;\n         if (null == clickedView || !clickedView.HasViewTransforms() || !clickedViewport.HasViewportTransforms())\n         {\n            throw new InvalidOperationException(\"The clicked viewport doesn't report 3D model space to sheet space transforms.\");\n         }\n\n         // Restrict application to plan view types.  \n         // Note: Sections and Elevations report transforms but are not covered in this demo.\n         if (ViewType.AreaPlan != clickedView.ViewType &&\n             ViewType.CeilingPlan != clickedView.ViewType &&\n             ViewType.EngineeringPlan != clickedView.ViewType &&\n             ViewType.FloorPlan != clickedView.ViewType)\n         {\n            throw new InvalidOperationException(\"Only plan views are supported by this demo application.\");\n         }\n\n         ViewPlan plan = clickedView as ViewPlan;\n         if (null == plan)\n         {\n            throw new InvalidOperationException(\"Only plan views are supported by this demo application.\");\n         }\n\n         // Convert the viewport click into a ray through 3d model space.\n         // Note: The output XYZ needs to be projected onto the view's cut plane before use.\n         XYZ clickAsModelRay = CalculateClickAsModelRay(clickedViewport, click);\n         if (null == clickAsModelRay)\n         {\n            throw new InvalidOperationException(\"The click was outside the view crop regions.\");\n         }\n\n         // Project the ray onto the view's cut plane.  \n         // This picks a reasonable height in the model for the View3D camera.\n         Plane cutPlane = GetViewPlanCutPlane(plan);\n         if (null == cutPlane)\n         {\n            throw new InvalidOperationException(\"An error occured when getting the view's cut plane.\");\n         }\n         XYZ view3dCameraLocation = ProjectPointOnPlane(cutPlane, clickAsModelRay);\n         if (null == view3dCameraLocation)\n         {\n            throw new InvalidOperationException(\"An error occured when calculating the View3D camera position.\");\n         }\n\n         using (Transaction tran = new Transaction(doc, \"New 3D View\"))\n         {\n            tran.Start();\n\n            // Create a new perspective 3D View with its camera at the point.\n            View3D view3d = Create3DView(doc, view3dCameraLocation, XYZ.BasisZ, XYZ.BasisY);\n            if (null != view3d)\n            {\n               tran.Commit();\n\n               // Activate the new 3D view.\n               uidoc.ActiveView = view3d;\n            }\n            else\n            {\n               tran.RollBack();\n               throw new InvalidOperationException(\"Failed to generate the 3D view.\");\n            }\n         }\n\n         return result;\n      }\n\n      /// <summary>\n      /// Find the viewport at a point on a sheet.\n      /// </summary>\n      /// <param name=\"viewSheet\">The ViewSheet that was clicked</param>\n      /// <param name=\"click\">The click point</param>\n      /// <returns>The viewport which was clicked, or null if no viewport was clicked.</returns>\n      private static Viewport GetViewportAtClick(ViewSheet viewSheet, XYZ click)\n      {\n         if (null == viewSheet || null == click)\n            return null;\n\n         Document doc = viewSheet.Document;\n         if (null == doc)\n            return null;\n\n         foreach (var vpId in viewSheet.GetAllViewports())\n         {\n            Viewport viewport = doc.GetElement(vpId) as Viewport;\n\n            if (null != viewport && viewport.GetBoxOutline().Contains(click, CLICK_TOLERANCE))\n            {\n               // Click is within the viewport\n               return viewport;\n            }\n         }\n\n         // Click was not contained by any viewport\n         return null;\n      }\n\n      /// <summary>\n      /// Makes the sheet space --> 3D model space transform.\n      /// </summary>\n      /// <param name=\"trfModelToProjection\">The 3D model space --> view projection space transform.</param>\n      /// <param name=\"trfProjectionToSheet\">The view projection space --> sheet space transform.</param>\n      /// <returns>The sheet space --> 3D model space transform.</returns>\n      private static Transform MakeSheetToModelTransform(Transform trfModelToProjection, Transform trfProjectionToSheet)\n      {\n         if (null == trfModelToProjection || null == trfProjectionToSheet)\n            return null;\n\n         Transform modelToSheetTrf = trfProjectionToSheet.Multiply(trfModelToProjection);\n         return modelToSheetTrf.Inverse;\n      }\n\n      /// <summary>\n      /// Projects a point on a plane.\n      /// </summary>\n      /// <param name=\"plane\">The plane on which the point will be projected</param>\n      /// <param name=\"point\">The point to projected onto the plane.</param>\n      /// <returns>The point projected onto the plane.</returns>\n      private static XYZ ProjectPointOnPlane(Plane plane, XYZ point)\n      {\n         UV uv = new UV();\n         double ignored;\n         plane.Project(point, out uv, out ignored);\n         return plane.Origin + (plane.XVec * uv.U) + (plane.YVec * uv.V);\n      }\n\n      private static double RANDOM_X_SCALE = 5631;\n      private static double RANDOM_Y_SCALE = 4369;\n\n      /// <summary>\n      /// Tests if a point is within a curveloop.  The point wil be projected onto the \n      /// plane which holds the curveloop before the test is executed.\n      /// </summary>\n      /// <param name=\"point\">The point to test.</param>\n      /// <param name=\"curveloop\">A curveloop that lies in a plane.</param>\n      /// <returns>True, if the point was inside the curveloop after the \n      /// point was projected onto the curveloop's plane. False, otherwise.</returns>\n      private static bool IsPointInsideCurveLoop(XYZ point, CurveLoop curveloop)\n      {\n         // Starting at the point, shoot an infinite ray in one direction and count how many\n         // times the ray intersects the edges of the curveloop.  If the ray intersects\n         // an odd number of edges, then the point was inside the curveloop.  If it \n         // intersects an even number of times, then the point was outside the curveloop.\n         //\n         // Note: Revit doesn't have an infinite ray class, so a very long Line is used instead.\n         // This test can fail if the curveloop is wider than the very long line.\n\n         // Calculate the plane on which the edges of the curveloop lie.\n         Plane plane = Plane.CreateByThreePoints(curveloop.ElementAt(0).GetEndPoint(0),\n                                                 curveloop.ElementAt(1).GetEndPoint(0),\n                                                 curveloop.ElementAt(2).GetEndPoint(0));\n\n         // Project the test point on the plane.\n         XYZ projectedPoint = ProjectPointOnPlane(plane, point);\n\n         // Create a very long bounded line that starts at projectedPoint and runs \n         // along the plane's surface.\n         Line veryLongLine = Line.CreateBound(projectedPoint,\n            projectedPoint + (RANDOM_X_SCALE * plane.XVec) + (RANDOM_Y_SCALE * plane.YVec));\n\n         // Count how many edges of curveloop intersect veryLongLine.\n         int intersectionCount = 0;\n         foreach (var edge in curveloop)\n         {\n            try\n            {\n               CurveIntersectResult res = veryLongLine.Intersect(edge, CurveIntersectResultOption.Detailed);\n               if (SetComparisonResult.Overlap == res?.Result)\n               {\n                  if (res.GetOverlaps() == null)\n                  {\n                     throw new ArgumentException(\"Bad Input.\");\n                  }\n\n                  intersectionCount += res.GetOverlaps().Count;\n               }\n            }\n            catch (Autodesk.Revit.Exceptions.ArgumentNullException)\n            {\n               Trace.WriteLine(\"An ArgumentNullException occured in veryLongLine.Intersect(edge)\");\n            }\n         }\n\n         // If the intersection count is ODD, then the point is inside the curveloop.\n         return 1 == (intersectionCount % 2);\n      }\n\n      /// <summary>\n      /// Starting with a click on a viewport on a sheet, this method calculates the corresponding\n      /// ray through 3D model.\n      /// </summary>\n      /// <param name=\"viewport\">The viewport on a sheet that was clicked.</param>\n      /// <param name=\"click\">The clicked point.</param>\n      /// <returns>An XYZ that represents a ray through the model in the direction of the viewport view's\n      /// view direction vector.</returns>\n      private static XYZ CalculateClickAsModelRay(Viewport viewport, XYZ click)\n      {\n         if (null == viewport || null == click)\n            return null;\n\n         Document doc = viewport.Document;\n         if (null == doc)\n            return null;\n\n         View view = doc.GetElement(viewport.ViewId) as View;\n         if (null == view)\n            return null;\n\n         // Transform for view projection space --> sheet space\n         Transform trfProjectionToSheet = new Transform(viewport.GetProjectionToSheetTransform());\n\n         // Most views have just one model space --> view projection space transform. \n         // However, views whose view crops are broken into multiple regions\n         // have more than one transform.\n         //\n         // Iterate all the model space --> view projection space transforms.  \n         // Look for the region that contains the click as a model point.\n         foreach (TransformWithBoundary trfWithBoundary in view.GetModelToProjectionTransforms())\n         {\n            // Make the sheet space --> 3D model space transform for the current crop region.\n            Transform trfSheetToModel = MakeSheetToModelTransform(trfWithBoundary.GetModelToProjectionTransform(), trfProjectionToSheet);\n            if (null == trfSheetToModel)\n            {\n               throw new InvalidOperationException(\"An error occured when calculating the sheet-to-model transforms.\");\n            }\n\n            // Transform the click point into 3D model space.\n            XYZ clickAsModelRay = trfSheetToModel.OfPoint(click);\n\n            // Get the edges of the current crop region.\n            CurveLoop modelCurveLoop = trfWithBoundary.GetBoundary();\n\n            if (null == modelCurveLoop)\n            {\n               // Views that are uncropped will have just one TransformWithBoundary and its\n               // curveloop will be null.  All sheet points will be subject to the transform\n               // from this TransformWithBoundary.\n               return clickAsModelRay;\n            }\n            else if (IsPointInsideCurveLoop(clickAsModelRay, modelCurveLoop))\n            {\n               return clickAsModelRay;\n            }\n         }\n\n         // The clicked point on the sheet is outside of all of the TransformWithBoundary crop regions.\n         // The model ray can't be calculated.\n         return null;\n      }\n\n      /// <summary>\n      /// Gets the cut plane from a plan view.\n      /// </summary>\n      /// <param name=\"plan\">The plan view containing the cut plane.</param>\n      /// <returns>A plane representing the plan view's cut plane.</returns>\n      private static Plane GetViewPlanCutPlane(ViewPlan plan)\n      {\n         if (null == plan)\n            return null;\n\n         double levelElevation = 0.0;\n         if (null != plan.GenLevel)\n            levelElevation = plan.GenLevel.Elevation;\n         double cutPlaneOffset = plan.GetViewRange().GetOffset(PlanViewPlane.CutPlane);\n         double viewCutPlaneElevation = levelElevation + cutPlaneOffset;\n\n         return Plane.CreateByNormalAndOrigin(plan.ViewDirection, new XYZ(0.0, 0.0, viewCutPlaneElevation));\n      }\n\n      /// <summary>\n      /// Creates a perspective View3D.\n      /// </summary>\n      /// <param name=\"doc\">The document.</param>\n      /// <param name=\"eyePosition\">The eye position in 3D model space for the new 3D view.</param>\n      /// <param name=\"upDir\">The up direction in 3D model space for the new 3D view.</param>\n      /// <param name=\"forwardDir\">The forward direction in 3D model space for the new 3D view.</param>\n      /// <returns>The new View3D.</returns>\n      private static View3D Create3DView(Document doc, XYZ eyePosition, XYZ upDir, XYZ forwardDir)\n      {\n         if (null == doc || null == eyePosition || null == upDir || null == forwardDir)\n            return null;\n\n         var vft = new FilteredElementCollector(doc)\n            .OfClass(typeof(ViewFamilyType))\n            .Cast<ViewFamilyType>()\n            .FirstOrDefault(t => t.ViewFamily == ViewFamily.ThreeDimensional);\n\n         View3D view3d = View3D.CreatePerspective(doc, vft.Id);\n         if (null == view3d)\n         {\n            return null;\n         }\n\n         view3d.SetOrientation(new ViewOrientation3D(eyePosition, upDir, forwardDir));\n\n         return view3d;\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_SheetToView3D.rtf": "Summary: This sample demonstrates how to use the View and Viewport transforms to map a point on a sheet to a location in the 3D model. It also demonstrates how to use TransformWithBoundary to inspect the view crop regions if the view crop has been broken (split) into many pieces.\n\nClasses: \nAutodesk.Revit.DB.Curveloop\nAutodesk.Revit.DB.Plane\nAutodesk.Revit.DB.Transform\nAutodesk.Revit.DB.TransformWithBoundary\nAutodesk.Revit.DB.View\nAutodesk.Revit.DB.View3D.CreatePerspective\nAutodesk.Revit.DB.Viewport\nAutodesk.Revit.DB.ViewSheet\n\n\nProject Files:\nSheetToView3D.cs\nIt contains two classes:\n-\tThe class Command which implements interface IExternalCommand, it is the entry of this external command.\n-\tThe class MakeView3D is responsible for creating a new 3D view when the user clicks on a ViewPlan viewport on a sheet.\n\nDescription: This sample demonstrates the following functionalities:\n-\tIt captures a click on a sheet from the user, then verifies that a view plan viewport was clicked.  Then it collects transforms from the clicked viewport and view and builds a transform from sheet space to 3D model space. (If the view has a broken (split) crop region, then the crop region and transform for the click’s location is found.)  The click point is then converted into 3D model space and projected onto the view plan’s cut plane.  A new perspective 3D view is created with its camera at this point.\n-\tThe most important class is MakeView3D. It shows how to get the transforms from the viewports and views, how to get crop region boundaries from TransformWithBoundary, and how to generate a new 3D view via RevitAPI.\n\nInstructions:\nTo use the “Sheet To 3D View” command:\nOpen a sheet view that contains plan views.\nRun this external command.\nClick in the viewport of a plan view at the location you want to create the 3D view."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\SlabProperties\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Autodesk.Revit.UI.UIApplication revit = commandData.Application;\n\n            try\n            {\n                // function initialization and find out a slab's Level, Type name, and set the Span Direction properties.\n                bool isInitialization = this.Initialize(revit);\n                if (false == isInitialization)\n                {\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n\n                // show a displayForm to display the properties of the slab\n                SlabPropertiesForm slabForm = new SlabPropertiesForm(this);\n                if (DialogResult.OK != slabForm.ShowDialog())\n                {\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n            }\n            catch (Exception displayProblem)\n            {\n                TaskDialog.Show(\"Revit\", displayProblem.ToString());\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n        #endregion\n\n\n        #region Class propertied\n        /// <summary>\n        /// Level property, read only.\n        /// </summary>\n        public string Level\n        {\n            get\n            {\n                return m_level;\n            }\n        }\n\n\n        /// <summary>\n        /// TypeName property, read only.\n        /// </summary>\n        public string TypeName\n        {\n            get\n            {\n                return m_typeName;\n            }\n        }\n\n\n        /// <summary>\n        /// SpanDirection property, read only.\n        /// </summary>\n        public string SpanDirection\n        {\n            get\n            {\n                return m_spanDirection;\n            }\n        }\n\n\n        /// <summary>\n        /// NumberOfLayers property, read only.\n        /// </summary>\n        public int NumberOfLayers\n        {\n            get\n            {\n                return m_numberOfLayers;\n            }\n        }\n\n\n        /// <summary>\n        /// LayerThickness property, read only.\n        /// </summary>\n        public string LayerThickness\n        {\n            get\n            {\n                return m_thickness;\n            }\n        }\n\n\n        /// <summary>\n        /// LayerMaterialName property, read only.\n        /// </summary>\n        public string LayerMaterialName\n        {\n            get\n            {\n                return m_materialName;\n            }\n        }\n\n\n        /// <summary>\n        /// LayerYoungModulusX property, read only.\n        /// </summary>\n        public string LayerYoungModulusX\n        {\n            get\n            {\n                return m_youngModulusX;\n            }\n        }\n\n\n        /// <summary>\n        /// LayerYoungModulusY property, read only.\n        /// </summary>\n        public string LayerYoungModulusY\n        {\n            get\n            {\n                return m_youngModulusY;\n            }\n        }\n\n\n        /// <summary>\n        /// LayerYoungModulusZ property, read only.\n        /// </summary>\n        public string LayerYoungModulusZ\n        {\n            get\n            {\n                return m_youngModulusZ;\n            }\n        }\n        #endregion\n\n\n        #region Public class method\n        /// <summary>\n        /// SetLayer method\n        /// </summary>\n        /// <param name=\"layerNumber\">The layerNumber for the number of the layers</param>\n        public void SetLayer(int layerNumber)\n        {\n            // Get each layer.\n            // An individual layer can be accessed by Layers property and its thickness and material can then be reported.\n            m_slabLayer = m_slabLayerCollection[layerNumber];\n\n            // Get the Thickness property and change to the metric millimeter\n            m_thickness = ((m_slabLayer.Width) * ToMetricThickness * ToMillimeter).ToString() + \" mm\";\n\n            // Get the Material name property\n            if (ElementId.InvalidElementId != m_slabLayer.MaterialId)\n            {\n                Material material = m_document.GetElement(m_slabLayer.MaterialId) as Material;\n                m_materialName = material.Name;\n            }\n            else\n            {\n                m_materialName = \"Null\";\n            }\n\n            // The Young modulus can be found from the material by using the following generic parameters: \n            // PHY_MATERIAL_PARAM_YOUNG_MOD1, PHY_MATERIAL_PARAM_YOUNG_MOD2, PHY_MATERIAL_PARAM_YOUNG_MOD3\n            if (ElementId.InvalidElementId != m_slabLayer.MaterialId)\n            {\n                Material material = m_document.GetElement(m_slabLayer.MaterialId) as Material;\n                Parameter youngModuleAttribute = null;\n                youngModuleAttribute = material.get_Parameter(BuiltInParameter.PHY_MATERIAL_PARAM_YOUNG_MOD1);\n                if (null != youngModuleAttribute)\n                {\n                    m_youngModulusX = (youngModuleAttribute.AsDouble() / ToMetricYoungmodulus).ToString(\"F2\") + \" MPa\";\n                }\n                youngModuleAttribute = material.get_Parameter(BuiltInParameter.PHY_MATERIAL_PARAM_YOUNG_MOD2);\n                if (null != youngModuleAttribute)\n                {\n                    m_youngModulusY = (youngModuleAttribute.AsDouble() / ToMetricYoungmodulus).ToString(\"F2\") + \" MPa\";\n                }\n                youngModuleAttribute = material.get_Parameter(BuiltInParameter.PHY_MATERIAL_PARAM_YOUNG_MOD3);\n                if (null != youngModuleAttribute)\n                {\n                    m_youngModulusZ = (youngModuleAttribute.AsDouble() / ToMetricYoungmodulus).ToString(\"F2\") + \" MPa\";\n                }\n            }\n            else\n            {\n                m_youngModulusX = \"Null\";\n                m_youngModulusY = \"Null\";\n                m_youngModulusZ = \"Null\";\n            }\n        }\n        #endregion\n\n\n        #region Private class memeber methods\n        /// <summary>\n        /// Initialization and find out a slab's Level, Type name, and set the Span Direction properties.\n        /// </summary>\n        /// <param name=\"revit\">The revit object for the active instance of Autodesk Revit.</param>\n        /// <returns>A value that signifies if your initialization was successful for true or failed for false.</returns>\n        private bool Initialize(Autodesk.Revit.UI.UIApplication revit)\n        {\n            m_slabComponent = new ElementSet();\n            foreach (ElementId elementId in revit.ActiveUIDocument.Selection.GetElementIds())\n            {\n               m_slabComponent.Insert(revit.ActiveUIDocument.Document.GetElement(elementId));\n            }\n            m_document = revit.ActiveUIDocument.Document;\n\n            // There must be exactly one slab selected\n            if (m_slabComponent.IsEmpty)\n            {\n                // nothing selected\n                TaskDialog.Show(\"Revit\", \"Please select a slab.\");\n                return false;\n            }\n            else if (1 != m_slabComponent.Size)\n            {\n                // too many things selected\n                TaskDialog.Show(\"Revit\", \"Please select only one slab.\");\n                return false;\n            }\n\n            foreach (Element e in m_slabComponent)\n            {\n                // If the element isn't a slab, give the message and return failure. \n                // Else find out its Level, Type name, and set the Span Direction properties. \n                if (\"Autodesk.Revit.DB.Floor\" != e.GetType().ToString())\n                {\n                    TaskDialog.Show(\"Revit\", \"A slab should be selected.\");\n                    return false;\n                }\n\n                // Change the element type to floor type\n                m_slabFloor = e as Floor;\n\n                // Get the layer information from the type object by using the CompoundStructure property\n                // The Layers property is then used to retrieve all the layers\n                m_slabLayerCollection = m_slabFloor.FloorType.GetCompoundStructure().GetLayers();\n                m_numberOfLayers = m_slabLayerCollection.Count;\n\n                // Get the Level property by the floor's Level property\n                m_level = (m_document.GetElement(m_slabFloor.LevelId) as Level).Name;\n\n                // Get the Type name property by the floor's FloorType property\n                m_typeName = m_slabFloor.FloorType.Name;\n\n                // The span direction can be found using generic parameter access \n                // using the built in parameter FLOOR_PARAM_SPAN_DIRECTION\n                Parameter spanDirectionAttribute;\n                spanDirectionAttribute = m_slabFloor.get_Parameter(BuiltInParameter.FLOOR_PARAM_SPAN_DIRECTION);\n                if (null != spanDirectionAttribute)\n                {\n                    // Set the Span Direction property\n                    this.SetSpanDirection(spanDirectionAttribute.AsDouble());\n                }\n            }\n            return true;\n        }\n\n\n        /// <summary>\n        /// Set SpanDirection property to the class private member\n        /// Because of the property retrieved from the parameter uses radian for unit, we should change it to degree.\n        /// </summary>\n        /// <param name=\"spanDirection\">The value of span direction property</param>\n        private void SetSpanDirection(double spanDirection)\n        {\n            double spanDirectionDegree;\n\n            // Change \"radian\" to \"degree\".\n            spanDirectionDegree = spanDirection / PI * Degree;\n\n            // If the absolute value very small, we consider it to be zero\n            if (Math.Abs(spanDirectionDegree) < 1E-12)\n            {\n                spanDirectionDegree = 0.0;\n            }\n\n            // The precision is 0.01, and unit is \"degree\".\n            m_spanDirection = spanDirectionDegree.ToString(\"F2\");\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_SlabProperties.rtf": "Summary: This sample demonstrates how to get Slab’s properties which consist of Level, Type Name, Span Direction and Slab’s Layers information (Material Name, Thickness, Young Modulus X, Y and Z).\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Floor\nAutodesk.Revit.DB.Structural.CompoundStructureLayer\nAutodesk.Revit.DB.Structural.CompoundStructureLayerArray\nAutodesk.Revit.DB.BuiltInParameter\n\nProject Files: \nCommand.cs\nThis file contains the class Command which inherits from IExternalCommand interface and implements the Execute method; besides, the class implements all functionalities of getting relevant properties of Slab.\n\nSlabPropertiesForm.cs\nThis file contains a Form class which consists of three TextBox controls for showing Level, Type Name, Span direction of Slab respectively; a RichTextBox control will show all the Layers information of Slab.\n\nDescription: This sample uses Structural and Parameters classes mostly to implement the functionality of getting Slab’s properties which consists of Level, Type Name, Span Direction and all Layers information (Material name, Young Modulus.\n-\tSlab objects can be gotten from ActiveDocument.Selection.Elements.\n-\tFloor.Level.Name, Floor.FloorType.Name and Floor.get_Parameter(BuiltInParameter.FLOOR_PARAM_SPAN_DIRECTION) can be used to get the Level, Type name and Span direction of Slab respectively.\n-\tFloor.FloorType.CompoundStructure.Layers can be used to retrieve the Structure Layers collection of Slab.\n-\tCompoundStructureLayer class’s Thickness, Material properties and get_Parameter() method can retrieve the thickness, material and the young modulus of Slab.\n-\tUse BuiltInParameter.PHY_MATERIAL_PARAM_YOUNG_MOD1, PHY_MATERIAL_PARAM_YOUNG_MOD2 and PHY_MATERIAL_PARAM_YOUNG_MOD3 to retrieve the X, Y, Z Young Modulus respectively. \n\nInstructions: \n1.\tStart Revit, draw a Slab, and then define some relevant parameters (such as Level, Material) for this new Slab. One .rvt file named SlabProperties.rvt is available under sample project folder, material and layers have been added, you can open this file and select the existing floor to run the sample. \n2.\tSelect this Slab and click the extern command, Slab properties form will be popped up: Level, Thickness, Span direction and all Layer properties for selected Slab will be showed in TextBox and RichTextBox controls of this Form."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\SlabShapeEditing\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Floor selectFloor = GetSelectFloor(commandData);\n            if (null == selectFloor)\n            {\n                message = \"Make sure selected only one floor (Slab) in Revit.\";\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            SlabShapeEditingForm slabShapeEditingForm = \n                new SlabShapeEditingForm(selectFloor, commandData);\n            slabShapeEditingForm.ShowDialog();\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        /// <summary>\n        /// get selected floor (slab)\n        /// </summary>\n        /// <param name=\"commandData\">object which contains reference of Revit Application.</param>\n        /// <returns>selected floor (slab)</returns>\n        private Floor GetSelectFloor(ExternalCommandData commandData)\n        {\n           ElementSet eleSet = new ElementSet();\n            foreach (ElementId elementId in commandData.Application.ActiveUIDocument.Selection.GetElementIds())\n            {\n               eleSet.Insert(commandData.Application.ActiveUIDocument.Document.GetElement(elementId));\n            }\n            if (eleSet.Size != 1) { return null; }\n\n            IEnumerator iter = eleSet.GetEnumerator();\n            iter.Reset();\n            while (iter.MoveNext())\n            {\n                return iter.Current as Floor;\n            }\n            return null;\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_SlabShapeEditing.rtf": "Summary: This sample demonstrates how to create SlabShapeVertex and SlabShapeCrease, and then use them to edit slab’s shape.\n\nClasses: \nAutodesk.Revit.DB.SlabShapeEditor\nAutodesk.Revit.DB.SlabShapeCrease\nAutodesk.Revit.DB.SlabShapeCreaseArray\nAutodesk.Revit.DB.SlabShapeCreaseArrayIterator\nAutodesk.Revit.DB.SlabShapeVertex\nAutodesk.Revit.DB.Line\nAutodesk.Revit.DB.Edge\nAutodesk.Revit.DB.CurveArray\nAutodesk.Revit.DB.GeometryObject\n\nProject Files: \nCommand.cs\nThis file contains a class Command that implements the IExternalCommand interface, get selected slab, creates SlabShapeEditingForm and gets ExternalCommandData.\n\nSlabShapeEditingForm.cs\nThis file contains a class SlabShapeEditingForm which inherits from Form. This Form has a PictureBox show the geometry info of Slab and some button used to create vertex and crease. \n\nSlabProfile.cs\nThis file contains a class SlabProfile which calculates the geometry info of Slab. SlabProfile consists of methods Draw2D(), AddVertex() and AddCrease(). Draw2D() is used to draw Slab curves on the picture box, and AddVertex() and AddCrease() are used to create vertex and crease on slab.\n\nLineTool.cs\nThis file contains a class named LineTool which provides some methods to draw lines on the form and store the data of drawn lines. It also provide method to draw new created vertex as rectangle\n\nMathTools.cs\nThis file contains Verctor4 and Matrix4 two classes. These two classes are used to transform points between 3D and 2D.\n\nDescription: This sample shows user how to:\n1.\tCreate SlabShapeVertex by \nSlabShapeEditor.DrawPoint(Autodesk.Revit.Geometry.XYZ location) method.\n2.\tCreate SlabShapeCrease by\nSlabShapeEditor.DrawSplitLine(SlabShapeVertex startVertex, SlabShapeVertex endVertex) method. A crease is consisted by two vertices.\n3.\tMove new created vertex by\n SlabShapeEditor.ModifySubElement(SlabShapeVertex pVertex, double offset)\n4.\tMove new created crease by\nSlabShapeEditor.ModifySubElement(SlabShapeCrease pCrease, double offset), offset use to set position of midpoint on crease.\n\n\nInstructions: \n1.\tDraw a slab in Revit or open the CreateComplexAreaRein.rvt, and then select the slab.\n2.\tRun this command.\n3.\tClick “create vertex”  button and click mouse in picture box to create a vertex on slab.\n4.\tClick “create crease”  button and click mouse in picture box to create a crease on slab.\n5.\tClick “select”  button, then move mouse and click in picture box to select new created vertex or crease, when new vertex or crease turn red, it means you have selected it successfully.\n6.\tThen input the distance user want to move in the textbox (just input number, unit is feet), click “Update” button.\n7.\tClick “Reset” button to restore the original shape of slab.\n8.\tIf user wants to observe slab in different direction, just click right mouse button down and move mouse in picture box.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\SolidSolidCut\\CS",
    "key_code": {
      "class_name": "Cut",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            // NOTES: Anything can be done in this method, such as the solid-solid cut operation.\n\n            // Get the application and document from external command data.\n            Application app = commandData.Application.Application;\n            Document activeDoc = commandData.Application.ActiveUIDocument.Document;\n\n            #region Demo how to use the SolidSolidCut API to make one solid cut another.\n\n            long solidToBeCutElementId = 30481; //The cube\n            long cuttingSolidElementId = 30809; //The sphere\n\n            //Get element by ElementId\n            Element solidToBeCut = activeDoc.GetElement(new ElementId(solidToBeCutElementId));\n            Element cuttingSolid = activeDoc.GetElement(new ElementId(cuttingSolidElementId));\n\n            //If the two elements do not exist, notify user to open the family file then try this command.\n            if (solidToBeCut == null || cuttingSolid == null)\n            {\n                TaskDialog.Show(\"Notice\", \"Please open the family file SolidSolidCut.rfa, then try to run this command.\");\n\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n\n            //Check whether the cuttingSolid can cut the solidToBeCut\n            CutFailureReason cutFailureReason = new CutFailureReason();\n            if (SolidSolidCutUtils.CanElementCutElement(cuttingSolid, solidToBeCut, out cutFailureReason))\n            {\n                //cuttingSolid can cut solidToBeCut\n\n                //Do the solid-solid cut operation\n                //Start a transaction\n                Transaction transaction = new Transaction(activeDoc);\n                transaction.Start(\"AddCutBetweenSolids(activeDoc, solidToBeCut, cuttingSolid)\");\n\n                //Let the cuttingSolid cut the solidToBeCut\n                SolidSolidCutUtils.AddCutBetweenSolids(activeDoc, solidToBeCut, cuttingSolid);\n\n                transaction.Commit();\n            }\n\n            #endregion\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n        #endregion\n    }\n\n    /// <summary>\n    /// Demonstrate how to use the SolidSolidCut API to uncut two solids which have the cutting relationship.\n    /// </summary>\n    [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n    [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n    public class Uncut : IExternalCommand\n    {\n        #region IExternalCommand Members\n\n        /// <summary>\n        /// Implement this method as an external command for Revit.\n        /// </summary>\n        /// <param name=\"commandData\">An object that is passed to the external application\n        /// which contains data related to the command,\n        /// such as the application object and active view.</param>\n        /// <param name=\"message\">A message that can be set by the external application\n        /// which will be displayed if a failure or cancellation is returned by\n        /// the external command.</param>\n        /// <param name=\"elements\">A set of elements to which the external application\n        /// can add elements that are to be highlighted in case of failure or cancellation.</param>\n        /// <returns>Return the status of the external command.\n        /// A result of Succeeded means that the API external method functioned as expected.\n        /// Cancelled can be used to signify that the user cancelled the external operation \n        /// at some point. Failure should be returned if the application is unable to proceed with\n        /// the operation.</returns>\n        public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            // NOTES: Anything can be done in this method, such as the solid-solid uncut operation.\n\n            // Get the application and document from external command data.\n            Application app = commandData.Application.Application;\n            Document activeDoc = commandData.Application.ActiveUIDocument.Document;\n\n            #region Demo how to use the SolidSolidCut API to uncut two solids which have the cutting relationship.\n\n            long solidToBeCutElementId = 30481; //The cube\n            long cuttingSolidElementId = 30809; //The sphere\n\n            //Get element by ElementId\n            Element solidToBeCut = activeDoc.GetElement(new ElementId(solidToBeCutElementId));\n            Element cuttingSolid = activeDoc.GetElement(new ElementId(cuttingSolidElementId));\n\n            //If the two elements do not exist, notify user to open the family file then try this command.\n            if (solidToBeCut == null || cuttingSolid == null)\n            {\n                TaskDialog.Show(\"Notice\", \"Please open the family file SolidSolidCut.rfa, then try to run this command.\");\n\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n\n            //Remove the solid-solid cut (Uncut)\n            //Start a transaction\n            Transaction transaction = new Transaction(activeDoc);\n            transaction.Start(\"RemoveCutBetweenSolids(activeDoc, solidToBeCut, cuttingSolid)\");\n\n            //Remove the cutting relationship between solidToBeCut and cuttingSolid (Uncut)\n            SolidSolidCutUtils.RemoveCutBetweenSolids(activeDoc, solidToBeCut, cuttingSolid);\n\n            transaction.Commit();\n\n            #endregion\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_SolidSolidCut.rtf": "Summary: Shows how to use Solid-Solid Cut and Uncut.\n\nClasses: \nAutodesk.Revit.IExternalCommand \nAutodesk.Revit.DB.SolidSolidCutUtils\nProject Files: \n·\tCommand.cs\nThis file contains two classes which inherit from IExternalCommmand interface. \nThe function of the first class Cut is checking and adding cut between two solids. The function of the second class Uncut is removing the cut operation between two solids.\n\nDescription: The sample defines two classes which inherit from IExternalCommand interface, and implement the Execute method with cut or uncut two solids operation.\nThe class Cut implements the function that can let the sphere cut the cube.\nThe class Uncut implements the function that can remove the cutting relationship between the sphere and the cube.\n\nInstructions: \n1.\tOpen Revit application.\n2.\tOpen the family file SolidSolidCut.rfa.\n3.\tRun the command “SolidSolidCut-Cut”.\n4.\tThe sphere will cut the cube.\n5.\tRun the command “SolidSolidCut-Uncut”\n6.\tThe cutting operation between the sphere and the cube will be removed.\n\nNotes:\nThis Solid-Solid Cut operation only works when editing a conceptual mass family.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\SpanDirection\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Autodesk.Revit.UI.UIApplication application = commandData.Application;\n            m_docment = application.ActiveUIDocument.Document;\n            try\n            {\n                // user should select one slab firstly. \n                if (application.ActiveUIDocument.Selection.GetElementIds().Count == 0)\n                {\n                    TaskDialog.Show(\"Revit\", \"Please select one slab firstly.\", TaskDialogCommonButtons.Ok);\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n\n                // get the selected slab and show its span direction\n                ElementSet elementSet = new ElementSet();\n                foreach (ElementId elementId in application.ActiveUIDocument.Selection.GetElementIds())\n                {\n                   elementSet.Insert(application.ActiveUIDocument.Document.GetElement(elementId));\n                }\n                ElementSetIterator elemIter = elementSet.ForwardIterator();\n                elemIter.Reset();\n                while (elemIter.MoveNext())\n                {\n                    Floor floor = elemIter.Current as Floor;\n                    if (floor != null)\n                    {\n                        GetSpanDirectionAndSymobls(floor);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                message = ex.ToString();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n        #endregion\n\n\n        /// <summary>\n        /// Get SpanDirection and SpanDirectionSymobols of Floor\n        /// </summary>\n        /// <param name=\"floor\"></param>\n        void GetSpanDirectionAndSymobls(Floor floor)\n        {\n            if (null != floor)\n            {\n                // get SpanDirection angle of Floor(Slab)\n                // The angle returned is in radians. An exception will be thrown if the floor\n                // is non structural.\n                String spanDirAngle = \"Span direction angle: \" + floor.SpanDirectionAngle.ToString() + \"\\r\\n\";\n\n                // get span direction symbols of Floor(Slab)\n                String symbols = \"Span direction symbols: \\r\\n\\t\";\n                System.Collections.Generic.ICollection<ElementId> symbolArray = floor.GetSpanDirectionSymbolIds();\n                //ElementArrayIterator symbolIter = symbolArray.ForwardIterator();\n                //symbolIter.Reset();\n                //while (symbolIter.MoveNext())\n                foreach (ElementId eid in symbolArray)\n                {\n                    Element elem = m_docment.GetElement(eid);\n                    if (elem != null)\n                    {\n                        symbols += (m_docment.GetElement(elem.GetTypeId()) as ElementType).Name + \"\\r\\n\";\n                    }\n                }\n\n                TaskDialog.Show(\"Revit Direction\", spanDirAngle + symbols, TaskDialogCommonButtons.Ok);\n            }\n            else\n            {\n                new Exception(\"Get Floor and SpanDirectionAngle and Symbols failed!\");\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_SpanDirection.rtf": "Summary: This sample demonstrates how to get span direction and span direction symbols of structural Floor (Slab).\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.ElementSet\nAutodesk.Revit.DB.Floor\nAutodesk.Revit.DB.ElementArray\nAutodesk.Revit.DB.ElementArrayIterator\n\nProject Files: \nCommand.cs\nThis file contains the class Command which inherits from IExternalCommand interface and implements the Execute method, the class implements all functionalities of getting relevant information of Floor.\n\nDescription: This sample uses Floor class mostly to implement the functionality of getting properties of Floor (Slab): span direction angle and span direction symbols.\n-\tFloor objects can be gotten from ActiveDocument.Selection.Elements.\n-\tFloor.SpanDirectionAngle and Floor.SpanDirectionSymbols properties can be used to retrieve the span direction angle and span direction symbols of Floor (Slab).\n-\tTo get span direction symbols, Element.ObjectType.Name \n\nInstructions: \n1.\tStart Revit Structure, draw one slab in Reivt, and then select it.\n2.\tClick the external command, a message box will pop up, the span direction angle and span direction symbols of this slab will be shown afterwards. \n3.\tIf you fail to create a slab with span direction, please use “Structural Analysis-Default.rte” file as Revit Structure default template file.\n4.\tOne .rvt file named SpanDirection.rvt is available under sample project folder, span direction and symbol of span direction have been added, you can open this file and select the existing floor to run the sample."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\SpotDimension\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n                                               ref string message,\n                                               ElementSet elements)\n        {\n            try\n            {\n                Transaction documentTransaction = new Transaction(commandData.Application.ActiveUIDocument.Document, \"Document\");\n                documentTransaction.Start();\n                using (SpotDimensionInfoDlg infoForm = new SpotDimensionInfoDlg(commandData))\n                {\n                    //Highlight the selected spotdimension\n                    if (infoForm.ShowDialog() == System.Windows.Forms.DialogResult.OK \n                        && infoForm.SelectedSpotDimension != null)\n                    {\n                        elements.Insert(infoForm.SelectedSpotDimension);\n                        message = \"High light the selected SpotDimension\";\n                        return Autodesk.Revit.UI.Result.Failed;\n                    }\n                }\n                documentTransaction.Commit();\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception ex)\n            {\n               // If there are something wrong, give error information and return failed\n               message = ex.Message;\n               return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_SpotDimension.rtf": "Summary: This sample demonstrates how to retrieve all the spot dimensions and theirs properties in all views of Revit document.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.SpotDimension\nAutodesk.Revit.DB.Parameter\n\nProject Files:\n\nSpotDimensionsData.cs\nThis file contains the functions that how to get all the spot dimensions.\n\nSpotDimensionParams.cs\nThis file contains the function that how to get a spot dimension’s properties.\n\nDescription: -\tGet spot dimensions in all views. All the spot dimensions can be retrieved by scanning Elements of Document.\n-\tThere is a dialog to show these spot dimensions according to its View property and some information of them.\n-\tIf one spot dimension was selected in dialog when return to Revit, it can be highlighted.\n-\tClassify spot dimension according to its View property. Spot dimensions in same view will be displayed together.\n-\tSelect view from a list, and then spot dimensions in it are displayed.\n-\tSelect spot dimension from a list, then some of its parameters are displayed.\n-\tParameters can be got via DimensionType.get_Parameter() and some properties of the SpotDimension Class.\n\nInstructions: \n1.\tFirst draw an element (for example a wall), and then draw some spot dimensions with Revit Menu Command: Drafting->Spot Dimension tool in Revit UI.\n2.\tLoad and run the SpotDimension.dll.\n3.\tSelect a view to show all the spot dimensions in that selected view. And then select a spot dimension to show its properties in a DataGridView at the bottom of the dialog.\n4.\tSelect a spot dimension, and then close the dialog to return Revit, then the spot dimension will be highlighted afterwards.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\StructSample\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData, ref String message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         try\n         {\n            Autodesk.Revit.UI.UIApplication rvtApp = commandData.Application;\n            Autodesk.Revit.UI.UIDocument rvtDoc = rvtApp.ActiveUIDocument;\n            ElementSet ss = new ElementSet();\n            foreach (ElementId elementId in rvtDoc.Selection.GetElementIds())\n            {\n               ss.Insert(rvtDoc.Document.GetElement(elementId));\n            }\n\n            Transaction tran = new Transaction(rvtDoc.Document, \"StructSample\");\n            tran.Start();\n\n            ElementSet walls = rvtApp.Application.Create.NewElementSet();\n\n            //  iterate through a selection set, and collect walls which are constrained at the top and the bottom.\n            foreach (Autodesk.Revit.DB.Element elem in ss)\n            {\n               if (elem.GetType() == typeof(Autodesk.Revit.DB.Wall))\n               {\n                  if (elem.get_Parameter(Autodesk.Revit.DB.BuiltInParameter.WALL_HEIGHT_TYPE) != null\n                      && elem.get_Parameter(Autodesk.Revit.DB.BuiltInParameter.WALL_BASE_CONSTRAINT) != null)\n                  {\n                     walls.Insert(elem);\n                  }\n               }\n            }\n\n            //  how many did we get? \n            TaskDialog.Show(\"Revit\", \"# of constrained walls in the selection set is \" + walls.Size);\n            if (walls.Size == 0)\n            {\n               message = \"You must select some walls that are constrained top or bottom\";\n               return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            //  next, we need a column symbol. For simplicity, the symbol name is hard-coded here. \n            Autodesk.Revit.DB.FamilySymbol colType = FindFamilySymbol(rvtDoc.Document, \"M_Wood Timber Column\", \"191 x 292mm\");\n            if (colType == null)\n            {\n               TaskDialog.Show(\"Revit\", \"failed to got a symbol. Please load the M_Wood Timber Column : 191 x 292mm family\");\n               message = \"Please load the M_Wood Timber Column : 191 x 292mm family\";\n\n               return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            //  place columns.\n            double spacing = 5;  //  Spacing in feet hard coded. Note: Revit's internal length unit is feet. \n            foreach (Autodesk.Revit.DB.Wall wall in walls)\n            {\n               FrameWall(rvtApp.Application, wall, spacing, colType);\n            }\n            tran.Commit();\n\n            //  return succeeded info. \n            return Autodesk.Revit.UI.Result.Succeeded;\n         }\n         catch (Exception ex)\n         {\n            message = ex.ToString();\n            return Autodesk.Revit.UI.Result.Failed;\n         }\n      }\n      #endregion\n\n\n      /// <summary>\n      /// find Column which will be used to placed to Wall\n      /// </summary>\n      /// <param name=\"rvtDoc\">Revit document</param>\n      /// <param name=\"familyName\">Family name of Column</param>\n      /// <param name=\"symbolName\">Symbol of Column</param>\n      /// <returns></returns>\n      private FamilySymbol FindFamilySymbol(Document rvtDoc, string familyName, string symbolName)\n      {\n         FilteredElementCollector collector = new FilteredElementCollector(rvtDoc);\n         FilteredElementIterator itr = collector.OfClass(typeof(Family)).GetElementIterator();\n         itr.Reset();\n         while (itr.MoveNext())\n         {\n            Autodesk.Revit.DB.Element elem = (Autodesk.Revit.DB.Element)itr.Current;\n            if (elem.GetType() == typeof(Autodesk.Revit.DB.Family))\n            {\n               if (elem.Name == familyName)\n               {\n                  Autodesk.Revit.DB.Family family = (Autodesk.Revit.DB.Family)elem;\n                  foreach (Autodesk.Revit.DB.ElementId symbolId in family.GetFamilySymbolIds())\n                  {\n                     Autodesk.Revit.DB.FamilySymbol symbol = (Autodesk.Revit.DB.FamilySymbol)rvtDoc.GetElement(symbolId);\n                     if (symbol.Name == symbolName)\n                     {\n                        return symbol;\n                     }\n                  }\n               }\n            }\n         }\n         return null;\n      }\n\n\n      /// <summary>\n      /// Frame a Wall\n      /// </summary>\n      /// <param name=\"rvtApp\">Revit application></param>\n      /// <param name=\"wall\">Wall as host to place column objects</param>\n      /// <param name=\"spacing\">spacing between two columns</param>\n      /// <param name=\"columnType\">column type</param>\n      private void FrameWall(Autodesk.Revit.ApplicationServices.Application rvtApp, Autodesk.Revit.DB.Wall wall,\n          double spacing, Autodesk.Revit.DB.FamilySymbol columnType)\n      {\n         Autodesk.Revit.DB.Document rvtDoc = wall.Document;\n\n         // get wall location\n         Autodesk.Revit.DB.LocationCurve loc = (Autodesk.Revit.DB.LocationCurve)wall.Location;\n         Autodesk.Revit.DB.XYZ startPt = loc.Curve.GetEndPoint(0);\n         Autodesk.Revit.DB.XYZ endPt = loc.Curve.GetEndPoint(1);\n\n         // get wall's vector\n         Autodesk.Revit.DB.UV wallVec = new Autodesk.Revit.DB.UV(\n             endPt.X - startPt.X,\n             endPt.Y - startPt.Y);\n\n         // get the axis vector\n         Autodesk.Revit.DB.UV axis = new Autodesk.Revit.DB.UV(1.0, 0.0);\n\n         Autodesk.Revit.DB.ElementId baseLevelId = wall.get_Parameter(BuiltInParameter.WALL_BASE_CONSTRAINT).AsElementId();\n         Autodesk.Revit.DB.ElementId topLevelId = wall.get_Parameter(BuiltInParameter.WALL_HEIGHT_TYPE).AsElementId();\n\n         // get wall length and vector\n         double wallLength = wallVec.GetLength();\n         wallVec = wallVec.Normalize();\n\n         // get # of column\n         int nmax = (int)(wallLength / spacing);\n\n         TaskDialog.Show(\"Revit\", \"wallLength = \" + wallLength + \"\\r\\nspacing = \" + spacing.ToString() + \"\\r\\nnmax = \" + nmax.ToString());\n\n         // get angle of wall and axis\n         double angle = wallVec.AngleTo(axis);\n\n         // place all column\n         Autodesk.Revit.DB.XYZ loc2 = startPt;\n         double dx = wallVec.U * spacing;\n         double dy = wallVec.V * spacing;\n         for (int i = 0; i < nmax; i++)\n         {\n            PlaceColumn(rvtApp, rvtDoc, loc2, angle, columnType, baseLevelId, topLevelId);\n\n            loc2 = new XYZ(loc2.X + dx,\n                loc2.Y + dy,\n                loc2.Z);\n         }\n\n         // place column at end point of wall\n         PlaceColumn(rvtApp, rvtDoc, endPt, angle, columnType, baseLevelId, topLevelId);\n      }\n\n\n      /// <summary>\n      /// create a column instance and place it on the wall line.\n      /// </summary>\n      /// <param name=\"rvtApp\">revit application</param>\n      /// <param name=\"rvtDoc\">revit document</param>\n      /// <param name=\"point2\">location for placing column</param>\n      /// <param name=\"angle\">column angle</param>\n      /// <param name=\"columnType\">column type placed in Wall</param>\n      /// <param name=\"baseLevelId\">level id for base level where column is placed</param>\n      /// <param name=\"topLevelId\">level id for top level where column is placed</param>\n      private void PlaceColumn(Autodesk.Revit.ApplicationServices.Application rvtApp, Document rvtDoc, Autodesk.Revit.DB.XYZ point2,\n          double angle, FamilySymbol columnType, Autodesk.Revit.DB.ElementId baseLevelId, Autodesk.Revit.DB.ElementId topLevelId)\n      {\n         Autodesk.Revit.DB.XYZ point = point2;\n\n         // Note: Must use level-hosted NewFamilyInstance!\n         Level instLevel = (Level)rvtDoc.GetElement(baseLevelId);\n         if (!columnType.IsActive)\n            columnType.Activate();\n         Autodesk.Revit.DB.FamilyInstance column = rvtDoc.Create.NewFamilyInstance(point, columnType,\n             instLevel, Autodesk.Revit.DB.Structure.StructuralType.Column);\n         if (column == null)\n         {\n            TaskDialog.Show(\"Revit\", \"failed to create an instance of a column.\");\n            return;\n         }\n\n         // rotate column to place it to right location\n         Autodesk.Revit.DB.XYZ zVec = new Autodesk.Revit.DB.XYZ(0, 0, 1);\n         Autodesk.Revit.DB.Line axis = Line.CreateUnbound(point, zVec);\n         column.Location.Rotate(axis, angle);\n\n         // Set the level Ids\n         Parameter baseLevelParameter = column.get_Parameter(Autodesk.Revit.DB.BuiltInParameter.FAMILY_BASE_LEVEL_PARAM);\n         Parameter topLevelParameter = column.get_Parameter(Autodesk.Revit.DB.BuiltInParameter.FAMILY_TOP_LEVEL_PARAM); ;\n         baseLevelParameter.Set(baseLevelId);\n         topLevelParameter.Set(topLevelId);\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_StructSample.rtf": "Summary: This sample demonstrates how to place a set of columns in the selected wall.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.ElementSet\nAutodesk.Revit.DB.Wall\nAutodesk.Revit.DB.Parameter\nAutodesk.Revit.DB.BuiltInParameter\nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.Family\nAutodesk.Revit.DB.Symbols.FamilySymbol\nAutodesk.Revit.DB.Geometry.XYZ\nAutodesk.Revit.DB.Geometry.UV\nAutodesk.Revit.DB.Geometry.Line\n\nProject Files: \nCommand.cs\nThis file contains the class Command which inherits from IExternalCommand interface and implements the Execute method. The class implements all functions for placing column to wall, such as finding one specialized column symbol from Family and placing column.\n\nDescription: This sample uses FamilyInstance, Family, FamilySymbol methods mostly to find a specialized column; then place this column to some selected walls with specialized spacing. (Note: the column type and interval between two columns are hard codes).\n-\tTo retrieve all the symbols of one Family, use Autodesk.Revit.Elements.Family.Symbols property and use Autodesk.Revit.Symbols.FamilySymbol.Name to get specialized column type.\n-\tTo create new column, use Autodesk.Revit.Document.Create.NewFamilyInstance method; Use Autodesk.Revit.Elements.FamilyInstance.Location to change or rotate column.\n-\tTo get/set the Column’s base & top levels, use Autodesk.Revit.Parameters.BuiltInParameter.FAMILY_BASE_LEVEL_PARAM and FAMILY_TOP_LEVEL_PARAM parameters in FamilyInstance.get_Parameter () method. \n-\tTo get/set the relevant information (vector, length) of wall and column, use methods and properties of classes Autodesk.Revit.Geometry.XYZ, UV, Line.\n\nInstructions: \n1.\tStart Revit, load “M_Wood Timber Column” column family from Revit library file (M_Wood Timber Column.rfa), afterwards, there should have “191 x 292mm” type column in project. \n2.\tOne .rvt sample named StructSample.rvt is available under sample project folder, this file contain required family symbol and four walls, you can select one or more walls and then run this sample, columns will placed to walls after running. \n3.\tDraw some walls and constrain their top and bottom to the levels in the properties dialog, then select them.\n4.\tRun the command, it will place columns along each selected wall with the interval of 5 feet.\n\nNote:\nThe column type and interval between two columns are hard codes."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\StructuralLayerFunction\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData,\n                                                ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Autodesk.Revit.UI.UIApplication revit = commandData.Application;\n\n            // Get the selected floor\n            UIDocument project = revit.ActiveUIDocument;\n            Selection choices = project.Selection;\n            ElementSet collection = new ElementSet();\n            foreach (ElementId elementId in choices.GetElementIds())\n            {\n               collection.Insert(project.Document.GetElement(elementId));\n            }\n\n            // Only allow to select one floor, or else report the failure\n            if (1 != collection.Size)\n            {\n                message = \"Please select a floor.\";\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            foreach (Element e in collection)\n            {\n                m_slab = e as Autodesk.Revit.DB.Floor;\n                if (null == m_slab)\n                {\n                    message = \"Please select a floor.\";\n                    return Autodesk.Revit.UI.Result.Failed;\n                }\n            }\n\n            // Get the function of each of its structural layers\n            foreach (CompoundStructureLayer e in m_slab.FloorType.GetCompoundStructure().GetLayers())\n            {\n                // With the selected floor, judge if the function of each of its structural layers\n                // is exist, if it's not exist, there should be zero.\n                if (0 == e.Function)\n                {\n                    m_functions.Add(\"No function\");\n                }\n                else\n                {\n                    m_functions.Add(e.Function.ToString());\n                }\n\n            }\n\n            // Display them in a form\n            StructuralLayerFunctionForm displayForm = new StructuralLayerFunctionForm(this);\n            displayForm.ShowDialog();\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_StructuralLayerFunction.rtf": "Summary: This sample demonstrates how to retrieve the function of each structural layer of selected floor in order from outside to inside in a dialog box.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.ElementSet\nAutodesk.Revit.DB.Structural.CompoundStructureLayer\nAutodesk.Revit.DB.Structural.Enum.CompoundStructureLayerFunction\n\nProject Files: \nCommand.cs\nThis file contains the class Command which inherits from IExternalCommand interface and implements the Execute method; besides, the class implements the functionalities: get all functions from all structure layers of selected floor.\n\nStructuralLayerFunctionForm.cs\nThis file contains a form class which will list all the functions for all floor’s structure layers.\n\nDescription: This sample uses Autodesk.Revit.Structural.CompoundStructureLayer and Autodesk.Revit.Structural.Enum.CompoundStructureLayerFunction mostly to get all the layer functions of Floor.\n-\tTo get all the Structure layers of floor, use Floor.FloorType.CompoundStructure.Layers property.\n-\tTo get the function of one layer, use Function property of CompoundStructureLayer class.\n-\tThe layers of the floor are ordered from outside to inside in the structural layers object.\n\nInstructions: \n1.\tDraw one floor in Revit, then edit the floor’s Structure parameter, afterward, insert some layers and select different functions for each layers.\n2.\tSelect the floor then run the command, a dialog will pop up, all available functions of the selected floor’s structure layers will be listed in the ListBox control.\n3.\tUnder sample project folder of SlabProperties, there is one Revit model file named SlabProperties.rvt, this file contains several structural layers, you can open this file and select the existing floor to run this sample."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\TagBeam\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(\n            ExternalCommandData commandData,\n            ref string message,\n            ElementSet elements)\n        {\n            try\n            {\n                //prepare data\n                TagBeamData dataBuffer = new TagBeamData(commandData);\n\n                // show UI\n                using (TagBeamForm displayForm = new TagBeamForm(dataBuffer))\n                {\n                    DialogResult result = displayForm.ShowDialog();\n                    if (DialogResult.OK != result)\n                    {\n                        return Autodesk.Revit.UI.Result.Cancelled;\n                    }\n                }\n\n                return Autodesk.Revit.UI.Result.Succeeded;\n            }\n            catch (Exception e)\n            {\n                message = e.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n        #endregion IExternalCommand Members Implementation\n    }\n\n    [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n    public class TagRebar : IExternalCommand\n    {\n        public Autodesk.Revit.UI.Result Execute(\n          ExternalCommandData commandData,\n          ref string message,\n          ElementSet elements)\n        {\n            try\n            {\n                // Get the active document and view\n                UIDocument revitDoc = commandData.Application.ActiveUIDocument;\n                Autodesk.Revit.DB.View view = revitDoc.Document.ActiveView;\n                foreach (ElementId elemId in revitDoc.Selection.GetElementIds())\n                {\n                   Element elem = revitDoc.Document.GetElement(elemId);\n                    if (elem.GetType() == typeof(Autodesk.Revit.DB.Structure.Rebar))\n                    {\n                        // cast to Rebar and get its first curve\n                        Autodesk.Revit.DB.Structure.Rebar rebar = (Autodesk.Revit.DB.Structure.Rebar)elem;\n                        Autodesk.Revit.DB.Curve curve = rebar.GetCenterlineCurves(false, false, false,MultiplanarOption.IncludeAllMultiplanarCurves,0)[0];\n                        IList<Subelement> subelements = rebar.GetSubelements();  \n\n                        // create a rebar tag at the first end point of the first curve\n                        using( Transaction t = new Transaction(revitDoc.Document))\n                        {\n                           t.Start(\"Create new tag\");\n                           IndependentTag tag = IndependentTag.Create(revitDoc.Document, view.Id, subelements[0].GetReference(), true,\n                               Autodesk.Revit.DB.TagMode.TM_ADDBY_CATEGORY,\n                               Autodesk.Revit.DB.TagOrientation.Horizontal, curve.GetEndPoint(0));\n                           t.Commit();\n                        }\n                        return Autodesk.Revit.UI.Result.Succeeded;\n                    }\n                }\n                message = \"No rebar selected!\";\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            catch (Exception e)\n            {\n                message = e.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n    }\n\n    [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n    public class CreateText : IExternalCommand\n    {\n        public Autodesk.Revit.UI.Result Execute(\n          ExternalCommandData commandData,\n          ref string message,\n          ElementSet elements)\n        {\n            try\n            {\n                // get the active document and view\n                UIDocument revitDoc = commandData.Application.ActiveUIDocument;\n                Autodesk.Revit.DB.View view = revitDoc.ActiveView;\n                Document dbDoc = revitDoc.Document;\n                ElementId currentTextTypeId = dbDoc.GetDefaultElementTypeId(ElementTypeGroup.TextNoteType);\n\n                foreach (ElementId elemId in revitDoc.Selection.GetElementIds())\n                {\n                   Element elem = dbDoc.GetElement(elemId);\n                    if (elem.GetType() == typeof(Autodesk.Revit.DB.Structure.Rebar))\n                    {\n                        // cast to Rebar and get its first curve\n                        Autodesk.Revit.DB.Structure.Rebar rebar = (Autodesk.Revit.DB.Structure.Rebar)elem;\n                        Autodesk.Revit.DB.Curve curve = rebar.GetCenterlineCurves(false, false, false, MultiplanarOption.IncludeAllMultiplanarCurves, 0)[0];\n\n                        // calculate necessary arguments\n                        Autodesk.Revit.DB.XYZ origin = new XYZ(\n                            curve.GetEndPoint(0).X + curve.Length,\n                            curve.GetEndPoint(0).Y,\n                            curve.GetEndPoint(0).Z);\n                        string strText = \"This is \" + rebar.Category.Name + \" : \" + rebar.Name;\n\n                        // create the text\n                        using( Transaction t = new Transaction(dbDoc))\n                        {\n                           t.Start(\"New text note\");\n                           TextNote.Create(dbDoc, view.Id, origin, strText, currentTextTypeId);\n                           t.Commit();\n                        }\n                        return Autodesk.Revit.UI.Result.Succeeded;\n                    }\n                }\n                message = \"No rebar selected!\";\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            catch (Exception e)\n            {\n                message = e.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_TagBeam.rtf": "Summary: This sample demonstrates how to create tags at the start and end of selected beams, how to create a rebar tag at the end of the first curve of selected rebar and how to create a text.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.LocationCurve\nAutodesk.Revit.DB.Family\nAutodesk.Revit.DB.FamilySymbol\nAutodesk.Revit.DB.Document\nAutodesk.Revit.DB.IndependentTag\nAutodesk.Revit.DB.Structure.Rebar\nAutodesk.Revit.DB.TextNote\n\nProject Files: \nCommand.cs\nThis file contains the class “Command” which inherits from “IExternalCommand” interfaces and implements the “Execute” method; class TagRebar which inherits from “IExternalCommand” interface to create a rebar tag at the end of the first curve of selected rebar; Class CreateText inherits from “IExternalCommand” to create a text node at the end of the selected rebar\n\nTagBeamData.cs\nIt contains a class named “TagBeamData” which is used to get the selected beams, get the tag symbols in the document and create tags at the start and end of the beam.\n\nTagBeamForm.cs\n-\tThis file contains a form class TagBeamForm in which user can chose the tag mode, tag type, tag orientation and whether there are leaders with the tag.\n\nDescription: This sample creates tags to the start and end of selected beams. Create a rebar tag at the end of the first curve of the selected rebar and create text node at the right of the rebar..\nImplementations:\n-\tThe selected beam object can be retrieved from Document.Selection.\n-\tThe available Family belonging to the three tag mode--tag by Category, Multi-Category Tag and Material tag can be retrieved from Document.elements by judging familySymbol’s category. \n-\tThe start point and the end point can be retrieved from FamilyInstance.Location.Curve.EndPoint[] property.\n-\tUsing Autodesk.Revit.Creation.Document.NewTag(View, Element, Boolean, TagMode, TagOrientation, XYZ) method to create tag.\n-\tRebar.Curves property to get the curve of the selected rebar.\n-\tUsing Autodesk.Revit.DB.TextNote.Create method to create a text note.\n\nInstructions: \n1.\tDraw some beams and select them.\n2.\tRun the Tag Beam command.\n3.\tSelect tag mode--tag by Category, Multi-Category Tag or Material tag, and then select the tag family symbol of this mode. Select the tag orientation and chooses whether tags have leaders.\n4.\tClick “OK” button to tag beam‘s start and end or click “Cancel” button to abort them.\n5.\tDraw a rebar and select it.\n6.\tRun the Tag Rebar command\n7.\tSample will tag at the end of the first curve of selected rebar.\n8.\tSelect rebar and run the Create Text command.\n9.\tSample will create a text node at the end of selected rebar."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Toposolid\\CS",
    "key_code": {
      "class_name": "ToposolidCreation",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         var uidoc = commandData.Application.ActiveUIDocument;\n         var doc = uidoc.Document;\n         var sel = uidoc.Selection;\n\n         Autodesk.Revit.DB.Toposolid topo = doc.GetElement(sel.PickObject(ObjectType.Element, new ToposolidFilter())) as Autodesk.Revit.DB.Toposolid;\n\n         List<Curve> curveList = new List<Curve>();\n         sel.PickObjects(ObjectType.Element, new ModelCurveFilter()).ToList().ForEach(x => curveList.Add((doc.GetElement(x) as ModelCurve).GeometryCurve));\n         CurveLoop cl = CurveLoop.Create(curveList);\n\n         using (Transaction transaction = new Transaction(doc, \"split\"))\n         {\n            transaction.Start();\n            topo.Split(new List<CurveLoop> { cl });\n            transaction.Commit();\n         }\n\n         return Result.Succeeded;\n      }\n   }\n\n   /// <summary>\n   /// Simplify a toposolid by reducing its inner vertices.\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class SimplifyToposolid : IExternalCommand\n   {\n      /// <summary>\n      /// Implement this method as an external command for Revit.\n      /// </summary>\n      /// <param name=\"commandData\">An object that is passed to the external application \n      /// which contains data related to the command, \n      /// such as the application object and active view.</param>\n      /// <param name=\"message\">A message that can be set by the external application \n      /// which will be displayed if a failure or cancellation is returned by \n      /// the external command.</param>\n      /// <param name=\"elements\">A set of elements to which the external application \n      /// can add elements that are to be highlighted in case of failure or cancellation.</param>\n      /// <returns>Return the status of the external command. \n      /// A result of Succeeded means that the API external method functioned as expected. \n      /// Cancelled can be used to signify that the user cancelled the external operation \n      /// at some point. Failure should be returned if the application is unable to proceed with \n      /// the operation.</returns>\n      public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         var uidoc = commandData.Application.ActiveUIDocument;\n         var doc = uidoc.Document;\n         var sel = uidoc.Selection;\n\n         Autodesk.Revit.DB.Toposolid topo = doc.GetElement(sel.PickObject(ObjectType.Element, new ToposolidFilter())) as Autodesk.Revit.DB.Toposolid;\n\n         using (Transaction transaction = new Transaction(doc, \"simplify\"))\n         {\n            transaction.Start();\n            topo.Simplify(0.6);\n            transaction.Commit();\n         }\n\n         return Result.Succeeded;\n      }\n   }\n\n   /// <summary>\n   /// Toposolid max boolean stability factor sample\n   /// </summary>\n   [Autodesk.Revit.Attributes.Transaction(Autodesk.Revit.Attributes.TransactionMode.Manual)]\n   [Autodesk.Revit.Attributes.Regeneration(Autodesk.Revit.Attributes.RegenerationOption.Manual)]\n   public class ToposolidMaxBooleanStabilityFactor: IExternalCommand\n   {\n      /// <summary>\n      /// Implement this method as an external command for Revit.\n      /// </summary>\n      /// <param name=\"commandData\">An object that is passed to the external application \n      /// which contains data related to the command, \n      /// such as the application object and active view.</param>\n      /// <param name=\"message\">A message that can be set by the external application \n      /// which will be displayed if a failure or cancellation is returned by \n      /// the external command.</param>\n      /// <param name=\"elements\">A set of elements to which the external application \n      /// can add elements that are to be highlighted in case of failure or cancellation.</param>\n      /// <returns>Return the status of the external command. \n      /// A result of Succeeded means that the API external method functioned as expected. \n      /// Cancelled can be used to signify that the user canceled the external operation \n      /// at some point. Failure should be returned if the application is unable to proceed with \n      /// the operation.</returns>\n      public Autodesk.Revit.UI.Result Execute(Autodesk.Revit.UI.ExternalCommandData commandData, ref string message, Autodesk.Revit.DB.ElementSet elements)\n      {\n         var uidoc = commandData.Application.ActiveUIDocument;\n         var doc = uidoc.Document;\n         var sel = uidoc.Selection;\n         using (Transaction transaction = new Transaction(doc, \"ToposolidMaxBooleanStbilityFactor\"))\n         {\n            transaction.Start();\n            try\n            {\n               Autodesk.Revit.DB.Toposolid.SetCutVoidStability(doc, false);\n            }\n            catch(Autodesk.Revit.Exceptions.ArgumentOutOfRangeException ex)\n            {\n               ex.ToString();\n            }\n\n\n            Autodesk.Revit.DB.Toposolid.SetCutVoidStability(doc, false);\n            bool isEnable = Autodesk.Revit.DB.Toposolid.IsCutVoidStabilityEnabled(doc);\n            if (!isEnable)\n            {\n               transaction.RollBack();\n               return Result.Failed;\n            }   \n\n            transaction.Commit();\n         }\n\n         return Result.Succeeded;\n      }\n   }\n\n   /// <summary>\n   /// ImportInstanceFilter\n   /// </summary>\n   public class ImportInstanceFilter : ISelectionFilter\n   {\n      /// <summary>\n      /// Interface implementation\n      /// </summary>\n      /// <param name=\"elem\"></param>\n      /// <returns></returns>\n      public bool AllowElement(Element elem)\n      {\n         return elem is ImportInstance;\n      }\n\n      /// <summary>\n      /// Interface implementation\n      /// </summary>\n      /// <param name=\"reference\"></param>\n      /// <param name=\"position\"></param>\n      /// <returns></returns>\n      public bool AllowReference(Reference reference, XYZ position)\n      {\n         return false;\n      }\n   }\n\n\n   /// <summary>\n   /// TopographySurfaceFilter\n   /// </summary>\n   public class TopographySurfaceFilter : ISelectionFilter\n   {\n      /// <summary>\n      /// Interface implementation\n      /// </summary>\n      /// <param name=\"elem\"></param>\n      /// <returns></returns>\n      public bool AllowElement(Element elem)\n      {\n         return elem is TopographySurface;\n      }\n\n      /// <summary>\n      /// Interface implementation\n      /// </summary>\n      /// <param name=\"reference\"></param>\n      /// <param name=\"position\"></param>\n      /// <returns></returns>\n      public bool AllowReference(Reference reference, XYZ position)\n      {\n         return false;\n      }\n   }\n\n   /// <summary>\n   /// ModelCurveFilter\n   /// </summary>\n   public class ModelCurveFilter : ISelectionFilter\n   {\n      /// <summary>\n      /// Interface implementation\n      /// </summary>\n      /// <param name=\"elem\"></param>\n      /// <returns></returns>\n      public bool AllowElement(Element elem)\n      {\n         return elem is ModelCurve;\n      }\n\n      /// <summary>\n      /// Interface implementation\n      /// </summary>\n      /// <param name=\"reference\"></param>\n      /// <param name=\"position\"></param>\n      /// <returns></returns>\n      public bool AllowReference(Reference reference, XYZ position)\n      {\n         return false;\n      }\n   }\n\n   /// <summary>\n   /// ToposolidFilter\n   /// </summary>\n   public class ToposolidFilter : ISelectionFilter\n   {\n      /// <summary>\n      /// Interface implementation\n      /// </summary>\n      /// <param name=\"elem\"></param>\n      /// <returns></returns>\n      public bool AllowElement(Element elem)\n      {\n         return elem is Autodesk.Revit.DB.Toposolid;\n      }\n\n      /// <summary>\n      /// Interface implementation\n      /// </summary>\n      /// <param name=\"reference\"></param>\n      /// <param name=\"position\"></param>\n      /// <returns></returns>\n      public bool AllowReference(Reference reference, XYZ position)\n      {\n         return false;\n      }\n   }\n}"
    },
    "documentation": {
      "ReadMe_Toposolid.rtf": "Summary: API samples for toposolid related features.\n\nClasses: \nAutodesk.Revit.UI.IExternalCommand\nAutodesk.Revit.DB.Document\nAutodesk.Revit.DB.Element\nAutodesk.Revit.DB.Toposolid\nAutodesk.Revit.DB.ContourSetting\n\nProject Files: \nCommand.cs\nThis file contains eight classes which implement IExternalCommand interface.\nToposolidCreation command gives examples of creating a Toposolid. \nToposolidFromDWG command gives examples of creating a Toposolid by getting geometry information from an ImportInstance. \nContourSettingCreation command gives examples of adding ContourSettingItems to the contour setting of a ToposolidType.\nContourSettingModification command gives examples of disabling, enabling, and removing a ContourSettingItem from the contour setting of a ToposolidType.\nToposolidFromSurface command gives examples of creating a Toposolid by selecting a TopographySurface.\nSSEPointVisibility command gives examples of enabling/disabling the visibility of points created by SlabShapeEditor\nSplitToposolid command gives examples of splitting a toposolid by selecting a set of model curves.\nSimplifyToposolid command gives examples of simplifying the toposolid by a given ratio.\n\nDescription: This sample provides following functionalities.\nCreate a Toposolid using a list of points, a list of curveloops, a ToposolidType id, and a level id.\nCreate a Toposolid by selecting an ImportInstance. \nAdd ContourSettingItems to the contour setting of a ToposolidType.\nModify ContourSettingItems of the contour setting of a ToposolidType. \nCreate a Toposolid by selecting a TopographySurface.\nChange the visibility of SlabShape points for Toposolid category. \nSplit a Toposolid by selecting a list of curves.\nSimplify a Toposolid by a given ratio.  \n\nInstructions: \nOpen Revit application and execute the commands.\nToposolidCreation: Directly execute the command. A toposolid will be created.\nToposolidFromDWG: Execute the command and then select a dwg file that contains topography information. A toposolid will be created according to the geometry information of the dwg file. \nContourSettingCreation: Execute the command and contour setting items will be added to the contour setting of the default toposolid type. Create a toposolid using that type to visualize the changes. \nContourSettingModifiation: Execute the command after contour setting creation. Change the code to test different modification methods. \nToposolidFromSurface: Execute the command and then select a TopographySurface. A toposolid will be created according to the mesh information of the TopographySurface. \nSSEPointVisibility: Execute the command and check a Toposolid edited by SlabShapeEditor to see the visibility change. \nSplitToposolid: Execute the command. Select a toposolid and then select curves. The toposolid will be split into pieces based on the selected curves. \nSimplifyToposolid: Execute the command and select a toposolid edited by SlabShapeEditor. The toposolid will be simplified by a given ratio. Change the ratio in the code to test the effect of different simplify ratios on toposolid."
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\TransactionControl\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n        ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            try\n            {\n                // process data from Revit and show dialog\n                using (TransactionForm transactionFrm = new TransactionForm(commandData))\n                {\n                    if (transactionFrm.ShowDialog() == DialogResult.OK)\n                    {\n                        return Autodesk.Revit.UI.Result.Succeeded;\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                message = ex.Message;\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n            return Autodesk.Revit.UI.Result.Cancelled;\n        }\n    }\n}"
    },
    "documentation": {
      "ReadMe_TransactionControl.rtf": "Summary: This sample demonstrates how to use transaction group, transaction and sub transaction.\n\nClasses: \nAutodesk.Revit.Document\nAutodesk.Revit.DB.TransactionGroup\nAutodesk.Revit.DB.Transaction\nAutodesk.Revit.DB.SubTransaction\n\nProject Files: \nCommand.cs\nIt contains the class Command which implements interface IExternalCommand. This is the entry of this external command.\n\nTransactionForm.cs\nIt contains the class TransactionForm which has options to start, rollback or commit transaction groups and transactions. The form also let user to create, move or delete walls inside transaction. The tree view is used to display all operations and transactions/transaction groups above and their relationship.\n\nCreateWallForm.cs\nIt contains the class CreateWallForm which is used to create a wall. There is a combo box and several text boxes in this form to set parameters used to create wall.\n\nDescription: Functionalities:\n-\tThree buttons in group box of transaction group provide following operations: begin a transaction group, rollback a transaction group, commit a transaction group. \n-\tThree buttons in group box of transaction provide following operations: begin a transaction, rollback a transaction, commit a transaction. \n-\tThree buttons in another operations group box provide following operations: create a wall, move a wall, delete a wall. \n-\tProvide a tree view to display transaction groups, transactions, operations and the relationship between them. \n-\tAllow user to use nested transaction groups to manage their transaction groups and transactions. Transactions cannot be nested and can be created inside or outside a transaction group. Sub transactions must be created inside a transaction. User can do one or more of the operations listed above inside a transaction or sub transaction.\n-\tWhen user clicks “Ok”/”Cancel” and there are some transaction groups or transactions which are not finished, show a message box to ask user whether to end all transactions.\n\nImplements:\n-\tTransaction Group can be started/rolled back/committed via class TransactionGroup’s Start/Rollback/Commit methods.\n-\tTransaction can be started/rolledback/committed via class Transaction’s Start/Rollback/Commit methods.\n-\tWall can be created via Autodesk.Revit.Creation.Document’s NewWall Method and can be moved/deleted via Autodesk.Revit.Document’s Move/Delete methods\n-\tTree node’s ForeColor represents different status, e.g. green means that a transaction or transaction group has been started, black means that a transaction or transaction group has been committed and gray means that a transaction or transaction group has been rolled back.\n\nInstructions: \n1.\tRun this external command.\n2.\tA dialog will be shown. Do some operations such as start a transaction or transaction group or create a wall, and then the tree view adds corresponding nodes to describe these operations and their relationship.\n3.\tWhen closing this dialog, if some transaction groups or transactions are not finished, a message box is shown to ask whether to end all transactions.\n\u0000"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\Truss\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n            ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            TrussForm trussForm = new TrussForm(commandData);\n            // The form is created successfully\n            if (null != trussForm && false == trussForm.IsDisposed)\n            {\n                trussForm.ShowDialog();\n            }\n\n            return Autodesk.Revit.UI.Result.Succeeded;\n        }\n\n        #endregion\n    }\n}"
    },
    "documentation": {
      "ReadMe_Truss.rtf": "Summary: This sample demonstrates how to create a truss and modify its truss members and profile.\n \nClasses: \nAutodesk.Revit.DB.Structure.Truss\nAutodesk.Revit.DB.Structure.TrussType\nAutodesk.Revit.DB.FamilyInstance\nAutodesk.Revit.DB.FamilySymbol\nAutodesk.Revit.DB.ViewPlan\nAutodesk.Revit.DB.Strucure.TrussMemberInfo\nAutodesk.Revit.DB.Line\nAutodesk.Revit.DB.CurveArray\n\nProject Files: \nCommand.cs\nThis file contains a class Command that implements the IExternalCommand interface, creates TrussForm and gets ExternalCommandData.\n\nTrussForm.cs\n·\tThis file contains a class TrussForm which inherits from Form. This Form has a TabControl which contains three pages: “View”, “Truss Member” and “Profile Edit”. \n·\tIn “View” page, User can draw the start point and end point of Truss in a PictureBox to create truss on selected level, all available levels should be listed in a ComboBox. \n·\tIn “Truss Member” page, after user created truss, all the curves of truss should be displayed in a picture box, user can select truss member (beam) by clicking the curve in picture box, and user can change the beam type of selected truss member, all beam types should be listed in a ComboBox. \n·\tIn “ProfileEdit” page, user can edit profile of the new created truss in a picture box which displays geometry information of the truss, and user can withdraw the editing by clicking “Restore” button. This page also gives a “Update” button use to update the geometry of truss after profile been edited.\n\nTrussGeometry.cs\nThis file contains a class TrussGeometry which used to calculate the geometry info of new created truss and change profile of truss. TrussGeometry consists of methods Draw2D() and SetProdile(). Draw2D() is used to draw truss curves on the picture box, and SetProfile() is used to reset the profile of truss by user input.\n\nLineTool.cs\nThis file contains a class named LineTool which provides some methods to draw lines on the form and store the data of drawn lines.\n\nMathTools.cs\nThis file contains Verctor4 and Matrix4 two classes. These two classes are used to transform points between 3D and 2D.\n\nDescription: This sample shows user how to create Truss by \nAutodesk.Revit.Creation.Document.NewTruss(Symbols.TrussType trussType, Elements.SketchPlane sketchPlane, Geometry.Curve baseCurve, Elements.View dbView) method:\nn\tTrussType will specify the type of truss, can be get from Autodesk.Revit.Document.TrussTypes property.\nn\tsketchPlane used to define which sketch plane truss can base on\nn\tbaseCurve used to define the start point and end point of new truss.\nn\tdbView used to specify which level truss create on.\n\nInstructions: \n1.\tSelect two columns or an existed truss in Revit.\n2.\tRun this command. (If there aren’t any templates for truss type or column in the project, you should load some first, or open Truss.rvt)\n3.\tIf user select two columns, should select a Level on which you want to create truss in ComboBox, then click “Create” button to create a truss.\n4.\tAfter creating a new truss, you can open the “Truss Members” and “Profile Edit” tab pages.\n5.\tOpen “Truss Members” page, you can select a truss member by clicking the each curve of truss geometry. After it turns red, you can change its beam type by “Change Type” button, and you can select the beam type you want change to in the ComboBox.\n6.\tOpen “Profile Edit” page, user can draw TopChord line and BottomChord line in picture box and after you finished new profile for truss, click “Update” button, and you can restore the truss profile by “Restore” button.\n\n\u0000",
      "~$adMe_Truss.rtf": "No summary or description found"
    }
  },
  {
    "project_path": "F:\\Revit 2026.2 SDK\\Samples\\ViewPrinter\\CS",
    "key_code": {
      "class_name": "Command",
      "execute_method": "public Autodesk.Revit.UI.Result Execute(ExternalCommandData commandData,\n        ref string message, Autodesk.Revit.DB.ElementSet elements)\n        {\n            Autodesk.Revit.DB.Transaction newTran = null;\n            try\n            {\n                newTran = new Autodesk.Revit.DB.Transaction(commandData.Application.ActiveUIDocument.Document, \"ViewPrinter\");\n                newTran.Start();\n\n                PrintMgr pMgr = new PrintMgr(commandData);\n\n                if (null == pMgr.InstalledPrinterNames)\n                {\n                    PrintMgr.MyMessageBox(\"No installed printer, the external command can't work.\");\n                    return Autodesk.Revit.UI.Result.Cancelled;\n                }\n\n                using (PrintMgrForm pmDlg = new PrintMgrForm(pMgr))\n                {\n                    if (pmDlg.ShowDialog() != DialogResult.Cancel)\n                    {\n                        newTran.Commit();\n                        return Autodesk.Revit.UI.Result.Succeeded;\n                    }\n                    newTran.RollBack();\n                }\n\n            }\n            catch (Exception ex)\n            {\n                if (null != newTran)\n                    newTran.RollBack();\n                message = ex.ToString();\n                return Autodesk.Revit.UI.Result.Failed;\n            }\n\n            return Autodesk.Revit.UI.Result.Cancelled;\n        }\n\n    }\n}"
    },
    "documentation": {
      "ReadMe_ViewPrinter.rtf": "Summary: This sample demonstrates how to print the printable view and sheets.\n\nClasses:\nAutodesk.Revit.DB.Document.PrintManager\nAutodesk.Revit.DB.VirtualPrinterType\nAutodesk.Revit.DB.PrintRange\nAutodesk.Revit.DB.PrintSetup\nAutodesk.Revit.DB.PrintSetting\nAutodesk.Revit.DB.ViewSheetSetting\nAutodesk.Revit.DB.ViewSheetSet\n\nProject Files: \nCommand.cs\nThis is the main DLL source file; it contains the class Command which implements interface IExternalCommand.\nPrintMgr.cs\nExposes the print interfaces just like the Print Dialog (File->Print …) in UI.\nPrintSTP.cs\nChange and save printer setup setting, exposes the print parameters just like the Print Setup Dialog (File->Print Setup…) in UI such as Printer name, paper, zoom, options, etc.\nViewSheets.cs\nExposes the View/Sheet Set interfaces just like the View/Sheet Set Dialog (File->Print …; selected views/sheets->Select…) in UI.\n\nDescription: This sample demonstrates the following functionalities:\n-\tPrint the printable views and sheets.\n-\tChange print setting.\n\nInstructions: \nAssumption: Available printer(s) is installed.\n1.\tRun this command.\n2.\tIn the Print dialog box, select a printer for Name.\n3.\tIf desired, select print to file. You can save the print job as either a PRN or a PLT file. \n4.\tUnder Print range, specify if you are printing the Current window, a visible portion of the current window, or Selected views/sheets. If you are printing selected views/sheets, click Select, choose from the list of available views to print, and click OK.\n5.\tUnder Options, specify the number of copies to print and whether to print a view or sheet set in reverse order. You can select Reverse print order for a multiple-page print job so that the last page is printed first. \n6.\tTo print a complete copy of the project before the first page of the next copy is printed, select Collate. To print all copies of the first page and then print all copies of each subsequent page, clear Collate.\n7.\tUnder Settings, click Setup to change print settings.\n8.\tWhen you are ready to print, click OK.\n\n\u0000"
    }
  }
]